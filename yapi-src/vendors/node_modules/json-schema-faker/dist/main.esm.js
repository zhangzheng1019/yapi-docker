var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// src/main.cjs.js
var require_main_cjs = __commonJS({
  "src/main.cjs.js"(exports) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __markAsModule2 = (target) => __defProp2(target, "__esModule", { value: true });
    var __commonJS2 = (cb, mod) => function __require2() {
      return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export = (target, all) => {
      __markAsModule2(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport2 = (target, module2, desc) => {
      if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames2(module2))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule2 = (module2) => {
      return __reExport2(__markAsModule2(__defProp2(module2 != null ? __create2(__getProtoOf2(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
    };
    var require_vendor = __commonJS2({
      "src/lib/vendor.js"(exports2, module2) {
        var DEPENDENCIES = {};
        var getDependencies = () => {
          return DEPENDENCIES;
        };
        var setDependencies2 = (value) => {
          Object.assign(DEPENDENCIES, value);
        };
        Object.assign(module2.exports, { getDependencies, setDependencies: setDependencies2 });
      }
    });
    var require_Registry = __commonJS2({
      "src/lib/class/Registry.js"(exports2, module2) {
        var Registry = class {
          constructor() {
            this.data = {};
          }
          unregister(name) {
            if (!name) {
              this.data = {};
            } else {
              delete this.data[name];
            }
          }
          register(name, callback) {
            this.data[name] = callback;
          }
          registerMany(formats) {
            Object.keys(formats).forEach((name) => {
              this.data[name] = formats[name];
            });
          }
          get(name) {
            const format = this.data[name];
            return format;
          }
          list() {
            return this.data;
          }
        };
        var Registry_default = Registry;
        module2.exports = Registry_default;
      }
    });
    var require_defaults = __commonJS2({
      "src/lib/api/defaults.js"(exports2, module2) {
        var defaults = {};
        var defaults_default = defaults;
        defaults.defaultInvalidTypeProduct = void 0;
        defaults.defaultRandExpMax = 10;
        defaults.ignoreProperties = [];
        defaults.ignoreMissingRefs = false;
        defaults.failOnInvalidTypes = true;
        defaults.failOnInvalidFormat = true;
        defaults.alwaysFakeOptionals = false;
        defaults.optionalsProbability = null;
        defaults.fixedProbabilities = false;
        defaults.useExamplesValue = false;
        defaults.useDefaultValue = false;
        defaults.requiredOnly = false;
        defaults.minItems = 0;
        defaults.maxItems = null;
        defaults.minLength = 0;
        defaults.maxLength = null;
        defaults.resolveJsonPath = false;
        defaults.reuseProperties = false;
        defaults.fillProperties = true;
        defaults.replaceEmptyByRandomValue = false;
        defaults.random = Math.random;
        defaults.renderTitle = true;
        defaults.renderDescription = true;
        defaults.renderComment = false;
        module2.exports = defaults_default;
      }
    });
    var require_OptionRegistry = __commonJS2({
      "src/lib/class/OptionRegistry.js"(exports2, module2) {
        var Registry = require_Registry();
        var defaults = require_defaults();
        var OptionRegistry = class extends Registry {
          constructor() {
            super();
            this.data = __spreadValues({}, defaults);
            this._defaults = defaults;
          }
          get defaults() {
            return __spreadValues({}, this._defaults);
          }
        };
        var OptionRegistry_default = OptionRegistry;
        module2.exports = OptionRegistry_default;
      }
    });
    var require_option = __commonJS2({
      "src/lib/api/option.js"(exports2, module2) {
        var OptionRegistry = require_OptionRegistry();
        var registry = new OptionRegistry();
        function optionAPI(nameOrOptionMap, optionalValue) {
          if (typeof nameOrOptionMap === "string") {
            if (typeof optionalValue !== "undefined") {
              return registry.register(nameOrOptionMap, optionalValue);
            }
            return registry.get(nameOrOptionMap);
          }
          return registry.registerMany(nameOrOptionMap);
        }
        optionAPI.getDefaults = () => registry.defaults;
        var option_default = optionAPI;
        module2.exports = option_default;
      }
    });
    var require_constants = __commonJS2({
      "src/lib/core/constants.js"(exports2, module2) {
        var ALLOWED_TYPES = ["integer", "number", "string", "boolean"];
        var SCALAR_TYPES = ALLOWED_TYPES.concat(["null"]);
        var ALL_TYPES = ["array", "object"].concat(SCALAR_TYPES);
        var MOST_NEAR_DATETIME = 2524608e6;
        var MIN_INTEGER = -1e8;
        var MAX_INTEGER = 1e8;
        var MIN_NUMBER = -100;
        var MAX_NUMBER = 100;
        var constants_default = {
          ALLOWED_TYPES,
          SCALAR_TYPES,
          ALL_TYPES,
          MIN_NUMBER,
          MAX_NUMBER,
          MIN_INTEGER,
          MAX_INTEGER,
          MOST_NEAR_DATETIME
        };
        module2.exports = constants_default;
      }
    });
    var require_types = __commonJS2({
      "node_modules/ret/lib/types.js"(exports2, module2) {
        module2.exports = {
          ROOT: 0,
          GROUP: 1,
          POSITION: 2,
          SET: 3,
          RANGE: 4,
          REPETITION: 5,
          REFERENCE: 6,
          CHAR: 7
        };
      }
    });
    var require_sets = __commonJS2({
      "node_modules/ret/lib/sets.js"(exports2) {
        var types = require_types();
        var INTS = () => [{ type: types.RANGE, from: 48, to: 57 }];
        var WORDS = () => {
          return [
            { type: types.CHAR, value: 95 },
            { type: types.RANGE, from: 97, to: 122 },
            { type: types.RANGE, from: 65, to: 90 }
          ].concat(INTS());
        };
        var WHITESPACE = () => {
          return [
            { type: types.CHAR, value: 9 },
            { type: types.CHAR, value: 10 },
            { type: types.CHAR, value: 11 },
            { type: types.CHAR, value: 12 },
            { type: types.CHAR, value: 13 },
            { type: types.CHAR, value: 32 },
            { type: types.CHAR, value: 160 },
            { type: types.CHAR, value: 5760 },
            { type: types.RANGE, from: 8192, to: 8202 },
            { type: types.CHAR, value: 8232 },
            { type: types.CHAR, value: 8233 },
            { type: types.CHAR, value: 8239 },
            { type: types.CHAR, value: 8287 },
            { type: types.CHAR, value: 12288 },
            { type: types.CHAR, value: 65279 }
          ];
        };
        var NOTANYCHAR = () => {
          return [
            { type: types.CHAR, value: 10 },
            { type: types.CHAR, value: 13 },
            { type: types.CHAR, value: 8232 },
            { type: types.CHAR, value: 8233 }
          ];
        };
        exports2.words = () => ({ type: types.SET, set: WORDS(), not: false });
        exports2.notWords = () => ({ type: types.SET, set: WORDS(), not: true });
        exports2.ints = () => ({ type: types.SET, set: INTS(), not: false });
        exports2.notInts = () => ({ type: types.SET, set: INTS(), not: true });
        exports2.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });
        exports2.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });
        exports2.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });
      }
    });
    var require_util = __commonJS2({
      "node_modules/ret/lib/util.js"(exports2) {
        var types = require_types();
        var sets = require_sets();
        var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
        var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
        exports2.strToChars = function(str) {
          var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
          str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
            if (lbs) {
              return s;
            }
            var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
            var c = String.fromCharCode(code);
            if (/[[\]{}^$.|?*+()]/.test(c)) {
              c = "\\" + c;
            }
            return c;
          });
          return str;
        };
        exports2.tokenizeClass = (str, regexpStr) => {
          var tokens = [];
          var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
          var rs, c;
          while ((rs = regexp.exec(str)) != null) {
            if (rs[1]) {
              tokens.push(sets.words());
            } else if (rs[2]) {
              tokens.push(sets.ints());
            } else if (rs[3]) {
              tokens.push(sets.whitespace());
            } else if (rs[4]) {
              tokens.push(sets.notWords());
            } else if (rs[5]) {
              tokens.push(sets.notInts());
            } else if (rs[6]) {
              tokens.push(sets.notWhitespace());
            } else if (rs[7]) {
              tokens.push({
                type: types.RANGE,
                from: (rs[8] || rs[9]).charCodeAt(0),
                to: rs[10].charCodeAt(0)
              });
            } else if (c = rs[12]) {
              tokens.push({
                type: types.CHAR,
                value: c.charCodeAt(0)
              });
            } else {
              return [tokens, regexp.lastIndex];
            }
          }
          exports2.error(regexpStr, "Unterminated character class");
        };
        exports2.error = (regexp, msg) => {
          throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
        };
      }
    });
    var require_positions = __commonJS2({
      "node_modules/ret/lib/positions.js"(exports2) {
        var types = require_types();
        exports2.wordBoundary = () => ({ type: types.POSITION, value: "b" });
        exports2.nonWordBoundary = () => ({ type: types.POSITION, value: "B" });
        exports2.begin = () => ({ type: types.POSITION, value: "^" });
        exports2.end = () => ({ type: types.POSITION, value: "$" });
      }
    });
    var require_lib = __commonJS2({
      "node_modules/ret/lib/index.js"(exports2, module2) {
        var util = require_util();
        var types = require_types();
        var sets = require_sets();
        var positions = require_positions();
        module2.exports = (regexpStr) => {
          var i = 0, l, c, start = { type: types.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
          var repeatErr = (i2) => {
            util.error(regexpStr, `Nothing to repeat at column ${i2 - 1}`);
          };
          var str = util.strToChars(regexpStr);
          l = str.length;
          while (i < l) {
            c = str[i++];
            switch (c) {
              case "\\":
                c = str[i++];
                switch (c) {
                  case "b":
                    last.push(positions.wordBoundary());
                    break;
                  case "B":
                    last.push(positions.nonWordBoundary());
                    break;
                  case "w":
                    last.push(sets.words());
                    break;
                  case "W":
                    last.push(sets.notWords());
                    break;
                  case "d":
                    last.push(sets.ints());
                    break;
                  case "D":
                    last.push(sets.notInts());
                    break;
                  case "s":
                    last.push(sets.whitespace());
                    break;
                  case "S":
                    last.push(sets.notWhitespace());
                    break;
                  default:
                    if (/\d/.test(c)) {
                      last.push({ type: types.REFERENCE, value: parseInt(c, 10) });
                    } else {
                      last.push({ type: types.CHAR, value: c.charCodeAt(0) });
                    }
                }
                break;
              case "^":
                last.push(positions.begin());
                break;
              case "$":
                last.push(positions.end());
                break;
              case "[":
                var not;
                if (str[i] === "^") {
                  not = true;
                  i++;
                } else {
                  not = false;
                }
                var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
                i += classTokens[1];
                last.push({
                  type: types.SET,
                  set: classTokens[0],
                  not
                });
                break;
              case ".":
                last.push(sets.anyChar());
                break;
              case "(":
                var group = {
                  type: types.GROUP,
                  stack: [],
                  remember: true
                };
                c = str[i];
                if (c === "?") {
                  c = str[i + 1];
                  i += 2;
                  if (c === "=") {
                    group.followedBy = true;
                  } else if (c === "!") {
                    group.notFollowedBy = true;
                  } else if (c !== ":") {
                    util.error(regexpStr, `Invalid group, character '${c}' after '?' at column ${i - 1}`);
                  }
                  group.remember = false;
                }
                last.push(group);
                groupStack.push(lastGroup);
                lastGroup = group;
                last = group.stack;
                break;
              case ")":
                if (groupStack.length === 0) {
                  util.error(regexpStr, `Unmatched ) at column ${i - 1}`);
                }
                lastGroup = groupStack.pop();
                last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
                break;
              case "|":
                if (!lastGroup.options) {
                  lastGroup.options = [lastGroup.stack];
                  delete lastGroup.stack;
                }
                var stack = [];
                lastGroup.options.push(stack);
                last = stack;
                break;
              case "{":
                var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
                if (rs !== null) {
                  if (last.length === 0) {
                    repeatErr(i);
                  }
                  min = parseInt(rs[1], 10);
                  max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
                  i += rs[0].length;
                  last.push({
                    type: types.REPETITION,
                    min,
                    max,
                    value: last.pop()
                  });
                } else {
                  last.push({
                    type: types.CHAR,
                    value: 123
                  });
                }
                break;
              case "?":
                if (last.length === 0) {
                  repeatErr(i);
                }
                last.push({
                  type: types.REPETITION,
                  min: 0,
                  max: 1,
                  value: last.pop()
                });
                break;
              case "+":
                if (last.length === 0) {
                  repeatErr(i);
                }
                last.push({
                  type: types.REPETITION,
                  min: 1,
                  max: Infinity,
                  value: last.pop()
                });
                break;
              case "*":
                if (last.length === 0) {
                  repeatErr(i);
                }
                last.push({
                  type: types.REPETITION,
                  min: 0,
                  max: Infinity,
                  value: last.pop()
                });
                break;
              default:
                last.push({
                  type: types.CHAR,
                  value: c.charCodeAt(0)
                });
            }
          }
          if (groupStack.length !== 0) {
            util.error(regexpStr, "Unterminated group");
          }
          return start;
        };
        module2.exports.types = types;
      }
    });
    var require_lib2 = __commonJS2({
      "node_modules/drange/lib/index.js"(exports2, module2) {
        "use strict";
        var SubRange = class {
          constructor(low, high) {
            this.low = low;
            this.high = high;
            this.length = 1 + high - low;
          }
          overlaps(range) {
            return !(this.high < range.low || this.low > range.high);
          }
          touches(range) {
            return !(this.high + 1 < range.low || this.low - 1 > range.high);
          }
          add(range) {
            return new SubRange(Math.min(this.low, range.low), Math.max(this.high, range.high));
          }
          subtract(range) {
            if (range.low <= this.low && range.high >= this.high) {
              return [];
            } else if (range.low > this.low && range.high < this.high) {
              return [
                new SubRange(this.low, range.low - 1),
                new SubRange(range.high + 1, this.high)
              ];
            } else if (range.low <= this.low) {
              return [new SubRange(range.high + 1, this.high)];
            } else {
              return [new SubRange(this.low, range.low - 1)];
            }
          }
          toString() {
            return this.low == this.high ? this.low.toString() : this.low + "-" + this.high;
          }
        };
        var DRange = class {
          constructor(a, b) {
            this.ranges = [];
            this.length = 0;
            if (a != null)
              this.add(a, b);
          }
          _update_length() {
            this.length = this.ranges.reduce((previous, range) => {
              return previous + range.length;
            }, 0);
          }
          add(a, b) {
            var _add = (subrange) => {
              var i = 0;
              while (i < this.ranges.length && !subrange.touches(this.ranges[i])) {
                i++;
              }
              var newRanges = this.ranges.slice(0, i);
              while (i < this.ranges.length && subrange.touches(this.ranges[i])) {
                subrange = subrange.add(this.ranges[i]);
                i++;
              }
              newRanges.push(subrange);
              this.ranges = newRanges.concat(this.ranges.slice(i));
              this._update_length();
            };
            if (a instanceof DRange) {
              a.ranges.forEach(_add);
            } else {
              if (b == null)
                b = a;
              _add(new SubRange(a, b));
            }
            return this;
          }
          subtract(a, b) {
            var _subtract = (subrange) => {
              var i = 0;
              while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {
                i++;
              }
              var newRanges = this.ranges.slice(0, i);
              while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {
                newRanges = newRanges.concat(this.ranges[i].subtract(subrange));
                i++;
              }
              this.ranges = newRanges.concat(this.ranges.slice(i));
              this._update_length();
            };
            if (a instanceof DRange) {
              a.ranges.forEach(_subtract);
            } else {
              if (b == null)
                b = a;
              _subtract(new SubRange(a, b));
            }
            return this;
          }
          intersect(a, b) {
            var newRanges = [];
            var _intersect = (subrange) => {
              var i = 0;
              while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {
                i++;
              }
              while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {
                var low = Math.max(this.ranges[i].low, subrange.low);
                var high = Math.min(this.ranges[i].high, subrange.high);
                newRanges.push(new SubRange(low, high));
                i++;
              }
            };
            if (a instanceof DRange) {
              a.ranges.forEach(_intersect);
            } else {
              if (b == null)
                b = a;
              _intersect(new SubRange(a, b));
            }
            this.ranges = newRanges;
            this._update_length();
            return this;
          }
          index(index) {
            var i = 0;
            while (i < this.ranges.length && this.ranges[i].length <= index) {
              index -= this.ranges[i].length;
              i++;
            }
            return this.ranges[i].low + index;
          }
          toString() {
            return "[ " + this.ranges.join(", ") + " ]";
          }
          clone() {
            return new DRange(this);
          }
          numbers() {
            return this.ranges.reduce((result, subrange) => {
              var i = subrange.low;
              while (i <= subrange.high) {
                result.push(i);
                i++;
              }
              return result;
            }, []);
          }
          subranges() {
            return this.ranges.map((subrange) => ({
              low: subrange.low,
              high: subrange.high,
              length: 1 + subrange.high - subrange.low
            }));
          }
        };
        module2.exports = DRange;
      }
    });
    var require_randexp = __commonJS2({
      "node_modules/randexp/lib/randexp.js"(exports2, module2) {
        var ret = require_lib();
        var DRange = require_lib2();
        var types = ret.types;
        module2.exports = class RandExp {
          constructor(regexp, m) {
            this._setDefaults(regexp);
            if (regexp instanceof RegExp) {
              this.ignoreCase = regexp.ignoreCase;
              this.multiline = regexp.multiline;
              regexp = regexp.source;
            } else if (typeof regexp === "string") {
              this.ignoreCase = m && m.indexOf("i") !== -1;
              this.multiline = m && m.indexOf("m") !== -1;
            } else {
              throw new Error("Expected a regexp or string");
            }
            this.tokens = ret(regexp);
          }
          _setDefaults(regexp) {
            this.max = regexp.max != null ? regexp.max : RandExp.prototype.max != null ? RandExp.prototype.max : 100;
            this.defaultRange = regexp.defaultRange ? regexp.defaultRange : this.defaultRange.clone();
            if (regexp.randInt) {
              this.randInt = regexp.randInt;
            }
          }
          gen() {
            return this._gen(this.tokens, []);
          }
          _gen(token, groups) {
            var stack, str, n, i, l;
            switch (token.type) {
              case types.ROOT:
              case types.GROUP:
                if (token.followedBy || token.notFollowedBy) {
                  return "";
                }
                if (token.remember && token.groupNumber === void 0) {
                  token.groupNumber = groups.push(null) - 1;
                }
                stack = token.options ? this._randSelect(token.options) : token.stack;
                str = "";
                for (i = 0, l = stack.length; i < l; i++) {
                  str += this._gen(stack[i], groups);
                }
                if (token.remember) {
                  groups[token.groupNumber] = str;
                }
                return str;
              case types.POSITION:
                return "";
              case types.SET:
                var expandedSet = this._expand(token);
                if (!expandedSet.length) {
                  return "";
                }
                return String.fromCharCode(this._randSelect(expandedSet));
              case types.REPETITION:
                n = this.randInt(token.min, token.max === Infinity ? token.min + this.max : token.max);
                str = "";
                for (i = 0; i < n; i++) {
                  str += this._gen(token.value, groups);
                }
                return str;
              case types.REFERENCE:
                return groups[token.value - 1] || "";
              case types.CHAR:
                var code = this.ignoreCase && this._randBool() ? this._toOtherCase(token.value) : token.value;
                return String.fromCharCode(code);
            }
          }
          _toOtherCase(code) {
            return code + (97 <= code && code <= 122 ? -32 : 65 <= code && code <= 90 ? 32 : 0);
          }
          _randBool() {
            return !this.randInt(0, 1);
          }
          _randSelect(arr) {
            if (arr instanceof DRange) {
              return arr.index(this.randInt(0, arr.length - 1));
            }
            return arr[this.randInt(0, arr.length - 1)];
          }
          _expand(token) {
            if (token.type === ret.types.CHAR) {
              return new DRange(token.value);
            } else if (token.type === ret.types.RANGE) {
              return new DRange(token.from, token.to);
            } else {
              let drange = new DRange();
              for (let i = 0; i < token.set.length; i++) {
                let subrange = this._expand(token.set[i]);
                drange.add(subrange);
                if (this.ignoreCase) {
                  for (let j = 0; j < subrange.length; j++) {
                    let code = subrange.index(j);
                    let otherCaseCode = this._toOtherCase(code);
                    if (code !== otherCaseCode) {
                      drange.add(otherCaseCode);
                    }
                  }
                }
              }
              if (token.not) {
                return this.defaultRange.clone().subtract(drange);
              } else {
                return this.defaultRange.clone().intersect(drange);
              }
            }
          }
          randInt(a, b) {
            return a + Math.floor(Math.random() * (1 + b - a));
          }
          get defaultRange() {
            return this._range = this._range || new DRange(32, 126);
          }
          set defaultRange(range) {
            this._range = range;
          }
          static randexp(regexp, m) {
            var randexp;
            if (typeof regexp === "string") {
              regexp = new RegExp(regexp, m);
            }
            if (regexp._randexp === void 0) {
              randexp = new RandExp(regexp, m);
              regexp._randexp = randexp;
            } else {
              randexp = regexp._randexp;
              randexp._setDefaults(regexp);
            }
            return randexp.gen();
          }
          static sugar() {
            RegExp.prototype.gen = function() {
              return RandExp.randexp(this);
            };
          }
        };
      }
    });
    var require_random = __commonJS2({
      "src/lib/core/random.js"(exports2, module2) {
        var RandExp = require_randexp();
        var optionAPI = require_option();
        var env = require_constants();
        function getRandomInteger(min, max) {
          min = typeof min === "undefined" ? env.MIN_INTEGER : min;
          max = typeof max === "undefined" ? env.MAX_INTEGER : max;
          return Math.floor(optionAPI("random")() * (max - min + 1)) + min;
        }
        function _randexp(value) {
          RandExp.prototype.max = optionAPI("defaultRandExpMax");
          RandExp.prototype.randInt = (a, b) => a + Math.floor(optionAPI("random")() * (1 + (b - a)));
          const re = new RandExp(value);
          return re.gen();
        }
        function pick(collection) {
          return collection[Math.floor(optionAPI("random")() * collection.length)];
        }
        function shuffle(collection) {
          let tmp;
          let key;
          let length = collection.length;
          const copy = collection.slice();
          for (; length > 0; ) {
            key = Math.floor(optionAPI("random")() * length);
            length -= 1;
            tmp = copy[length];
            copy[length] = copy[key];
            copy[key] = tmp;
          }
          return copy;
        }
        function getRandom(min, max) {
          return optionAPI("random")() * (max - min) + min;
        }
        function number(min, max, defMin, defMax, hasPrecision = false) {
          defMin = typeof defMin === "undefined" ? env.MIN_NUMBER : defMin;
          defMax = typeof defMax === "undefined" ? env.MAX_NUMBER : defMax;
          min = typeof min === "undefined" ? defMin : min;
          max = typeof max === "undefined" ? defMax : max;
          if (max < min) {
            max += min;
          }
          if (hasPrecision) {
            return getRandom(min, max);
          }
          return getRandomInteger(min, max);
        }
        function by(type) {
          switch (type) {
            case "seconds":
              return number(0, 60) * 60;
            case "minutes":
              return number(15, 50) * 612;
            case "hours":
              return number(12, 72) * 36123;
            case "days":
              return number(7, 30) * 86412345;
            case "weeks":
              return number(4, 52) * 604812345;
            case "months":
              return number(2, 13) * 2592012345;
            case "years":
              return number(1, 20) * 31104012345;
            default:
              break;
          }
        }
        function date(step) {
          if (step) {
            return by(step);
          }
          const now = new Date();
          const days = number(-1e3, env.MOST_NEAR_DATETIME);
          now.setTime(now.getTime() - days);
          return now;
        }
        var random_default = {
          pick,
          date,
          shuffle,
          number,
          randexp: _randexp
        };
        module2.exports = random_default;
      }
    });
    var require_utils = __commonJS2({
      "src/lib/core/utils.js"(exports2, module2) {
        var optionAPI = require_option();
        var env = require_constants();
        var random = require_random();
        function getLocalRef(obj, path, refs) {
          const keyElements = path.replace("#/", "/").split("/");
          let schema = obj.$ref && refs ? refs[obj.$ref] : obj;
          if (refs && path.includes("#/") && refs[keyElements[0]]) {
            schema = refs[keyElements.shift()];
          }
          if (!keyElements[0])
            keyElements.shift();
          while (schema && keyElements.length > 0) {
            const prop = keyElements.shift();
            if (!schema[prop]) {
              throw new Error(`Prop not found: ${prop} (${path})`);
            }
            schema = schema[prop];
          }
          return schema;
        }
        function hasProperties(obj, ...properties) {
          return properties.filter((key) => {
            return typeof obj[key] !== "undefined";
          }).length > 0;
        }
        function clampDate(value) {
          if (value.includes(" ")) {
            return new Date(value).toISOString().substr(0, 10);
          }
          let [year, month, day] = value.split("T")[0].split("-");
          month = Math.max(1, Math.min(12, month));
          day = Math.max(1, Math.min(31, day));
          return `${year}-${month}-${day}`;
        }
        function typecast(type, schema, callback) {
          const params = {};
          switch (type || schema.type) {
            case "integer":
            case "number":
              if (typeof schema.minimum !== "undefined") {
                params.minimum = schema.minimum;
              }
              if (typeof schema.maximum !== "undefined") {
                params.maximum = schema.maximum;
              }
              if (schema.enum) {
                let min = Math.max(params.minimum || 0, 0);
                let max = Math.min(params.maximum || Infinity, Infinity);
                if (schema.exclusiveMinimum && min === schema.minimum) {
                  min += schema.multipleOf || 1;
                }
                if (schema.exclusiveMaximum && max === schema.maximum) {
                  max -= schema.multipleOf || 1;
                }
                if (min || max !== Infinity) {
                  schema.enum = schema.enum.filter((x) => {
                    if (x >= min && x <= max) {
                      return true;
                    }
                    return false;
                  });
                }
              }
              break;
            case "string": {
              params.minLength = optionAPI("minLength") || 0;
              params.maxLength = optionAPI("maxLength") || Number.MAX_SAFE_INTEGER;
              if (typeof schema.minLength !== "undefined") {
                params.minLength = Math.max(params.minLength, schema.minLength);
              }
              if (typeof schema.maxLength !== "undefined") {
                params.maxLength = Math.min(params.maxLength, schema.maxLength);
              }
              break;
            }
            default:
              break;
          }
          let value = callback(params);
          if (value === null || value === void 0) {
            return null;
          }
          switch (type || schema.type) {
            case "number":
              value = parseFloat(value);
              break;
            case "integer":
              value = parseInt(value, 10);
              break;
            case "boolean":
              value = !!value;
              break;
            case "string": {
              value = String(value);
              const min = Math.max(params.minLength || 0, 0);
              const max = Math.min(params.maxLength || Infinity, Infinity);
              let prev;
              let noChangeCount = 0;
              while (value.length < min) {
                prev = value;
                if (!schema.pattern) {
                  value += `${random.pick([" ", "/", "_", "-", "+", "=", "@", "^"])}${value}`;
                } else {
                  value += random.randexp(schema.pattern);
                }
                if (value === prev) {
                  noChangeCount += 1;
                  if (noChangeCount === 3) {
                    break;
                  }
                } else {
                  noChangeCount = 0;
                }
              }
              if (value.length > max) {
                value = value.substr(0, max);
              }
              switch (schema.format) {
                case "date-time":
                case "datetime":
                  value = new Date(clampDate(value)).toISOString().replace(/([0-9])0+Z$/, "$1Z");
                  break;
                case "full-date":
                case "date":
                  value = new Date(clampDate(value)).toISOString().substr(0, 10);
                  break;
                case "time":
                  value = new Date(`1969-01-01 ${value}`).toISOString().substr(11);
                  break;
                default:
                  break;
              }
              break;
            }
            default:
              break;
          }
          return value;
        }
        function merge(a, b) {
          Object.keys(b).forEach((key) => {
            if (typeof b[key] !== "object" || b[key] === null) {
              a[key] = b[key];
            } else if (Array.isArray(b[key])) {
              a[key] = a[key] || [];
              b[key].forEach((value) => {
                if (Array.isArray(a[key]) && a[key].indexOf(value) === -1) {
                  a[key].push(value);
                }
              });
            } else if (typeof a[key] !== "object" || a[key] === null || Array.isArray(a[key])) {
              a[key] = merge({}, b[key]);
            } else {
              a[key] = merge(a[key], b[key]);
            }
          });
          return a;
        }
        function clone(obj, cache = new Map()) {
          if (!obj || typeof obj !== "object") {
            return obj;
          }
          if (cache.has(obj)) {
            return cache.get(obj);
          }
          if (Array.isArray(obj)) {
            const arr = [];
            cache.set(obj, arr);
            arr.push(...obj.map((x) => clone(x, cache)));
            return arr;
          }
          const clonedObj = {};
          cache.set(obj, clonedObj);
          return Object.keys(obj).reduce((prev, cur) => {
            prev[cur] = clone(obj[cur], cache);
            return prev;
          }, clonedObj);
        }
        function short(schema) {
          const s = JSON.stringify(schema);
          const l = JSON.stringify(schema, null, 2);
          return s.length > 400 ? `${l.substr(0, 400)}...` : l;
        }
        function anyValue() {
          return random.pick([
            false,
            true,
            null,
            -1,
            NaN,
            Math.PI,
            Infinity,
            void 0,
            [],
            {},
            Math.random(),
            Math.random().toString(36).substr(2)
          ]);
        }
        function notValue(schema, parent) {
          const copy = merge({}, parent);
          if (typeof schema.minimum !== "undefined") {
            copy.maximum = schema.minimum;
            copy.exclusiveMaximum = true;
          }
          if (typeof schema.maximum !== "undefined") {
            copy.minimum = schema.maximum > copy.maximum ? 0 : schema.maximum;
            copy.exclusiveMinimum = true;
          }
          if (typeof schema.minLength !== "undefined") {
            copy.maxLength = schema.minLength;
          }
          if (typeof schema.maxLength !== "undefined") {
            copy.minLength = schema.maxLength > copy.maxLength ? 0 : schema.maxLength;
          }
          if (schema.type) {
            copy.type = random.pick(env.SCALAR_TYPES.filter((x) => {
              const types = Array.isArray(schema.type) ? schema.type : [schema.type];
              return types.every((type) => {
                if (x === "number" || x === "integer") {
                  return type !== "number" && type !== "integer";
                }
                return x !== type;
              });
            }));
          } else if (schema.enum) {
            let value;
            do {
              value = anyValue();
            } while (schema.enum.indexOf(value) !== -1);
            copy.enum = [value];
          }
          if (schema.required && copy.properties) {
            schema.required.forEach((prop) => {
              delete copy.properties[prop];
            });
          }
          return copy;
        }
        function validateValueForSchema(value, schema) {
          const schemaHasMin = schema.minimum !== void 0;
          const schemaHasMax = schema.maximum !== void 0;
          return (schemaHasMin || schemaHasMax) && (!schemaHasMin || value >= schema.minimum) && (!schemaHasMax || value <= schema.maximum);
        }
        function validate(value, schemas) {
          return !schemas.every((schema) => validateValueForSchema(value, schema));
        }
        function validateValueForOneOf(value, oneOf) {
          const validCount = oneOf.reduce((count, schema) => count + (validateValueForSchema(value, schema) ? 1 : 0), 0);
          return validCount === 1;
        }
        function isKey(prop) {
          return ["enum", "const", "default", "examples", "required", "definitions", "items", "properties"].includes(prop);
        }
        function omitProps(obj, props) {
          return Object.keys(obj).filter((key) => !props.includes(key)).reduce((copy, k) => {
            if (Array.isArray(obj[k])) {
              copy[k] = obj[k].slice();
            } else {
              copy[k] = obj[k] instanceof Object ? merge({}, obj[k]) : obj[k];
            }
            return copy;
          }, {});
        }
        function template(value, schema) {
          if (Array.isArray(value)) {
            return value.map((x) => template(x, schema));
          }
          if (typeof value === "string") {
            value = value.replace(/#\{([\w.-]+)\}/g, (_, $1) => schema[$1]);
          }
          return value;
        }
        function isEmpty(value) {
          return Object.prototype.toString.call(value) === "[object Object]" && !Object.keys(value).length;
        }
        function shouldClean(key, schema) {
          const isRequired = Array.isArray(schema.required) && schema.required.includes(key);
          const wasCleaned = typeof schema.thunk === "function" || schema.additionalProperties && typeof schema.additionalProperties.thunk === "function";
          return !isRequired && !wasCleaned;
        }
        function clean(obj, schema, isArray = false) {
          if (!obj || typeof obj !== "object") {
            return obj;
          }
          if (Array.isArray(obj)) {
            return obj.map((value) => clean(value, schema, true)).filter((value) => typeof value !== "undefined");
          }
          Object.keys(obj).forEach((k) => {
            if (isEmpty(obj[k])) {
              if (shouldClean(k, schema)) {
                delete obj[k];
              }
            } else {
              const value = clean(obj[k], schema);
              if (!isEmpty(value)) {
                obj[k] = value;
              }
            }
            if (typeof obj[k] === "undefined") {
              delete obj[k];
            }
          });
          if (!Object.keys(obj).length && isArray) {
            return void 0;
          }
          return obj;
        }
        var utils_default = {
          hasProperties,
          getLocalRef,
          omitProps,
          typecast,
          merge,
          clone,
          short,
          notValue,
          anyValue,
          validate,
          validateValueForSchema,
          validateValueForOneOf,
          isKey,
          template,
          shouldClean,
          clean,
          isEmpty,
          clampDate
        };
        module2.exports = utils_default;
      }
    });
    var require_Container = __commonJS2({
      "src/lib/class/Container.js"(exports2, module2) {
        var import_utils = __toModule2(require_utils());
        function proxy(gen) {
          return (value, schema, property, rootSchema) => {
            let fn = value;
            let args = [];
            if (typeof value === "object") {
              fn = Object.keys(value)[0];
              if (Array.isArray(value[fn])) {
                args = value[fn];
              } else {
                args.push(value[fn]);
              }
            }
            const props = fn.split(".");
            let ctx = gen();
            while (props.length > 1) {
              ctx = ctx[props.shift()];
            }
            value = typeof ctx === "object" ? ctx[props[0]] : ctx;
            if (typeof value === "function") {
              value = value.apply(ctx, args.map((x) => import_utils.default.template(x, rootSchema)));
            }
            if (Object.prototype.toString.call(value) === "[object Object]") {
              Object.keys(value).forEach((key) => {
                if (typeof value[key] === "function") {
                  throw new Error(`Cannot resolve value for '${property}: ${fn}', given: ${value}`);
                }
              });
            }
            return value;
          };
        }
        var Container = class {
          constructor() {
            this.registry = {};
            this.support = {};
          }
          reset(name) {
            if (!name) {
              this.registry = {};
              this.support = {};
            } else {
              delete this.registry[name];
              delete this.support[name];
            }
          }
          extend(name, callback) {
            this.registry[name] = callback(this.registry[name]);
            if (!this.support[name]) {
              this.support[name] = proxy(() => this.registry[name]);
            }
          }
          define(name, callback) {
            this.support[name] = callback;
          }
          get(name) {
            if (typeof this.registry[name] === "undefined") {
              throw new ReferenceError(`'${name}' dependency doesn't exist.`);
            }
            return this.registry[name];
          }
          wrap(schema) {
            if (!("generate" in schema)) {
              const keys = Object.keys(schema);
              const context = {};
              let length = keys.length;
              while (length--) {
                const fn = keys[length].replace(/^x-/, "");
                const gen = this.support[fn];
                if (typeof gen === "function") {
                  Object.defineProperty(schema, "generate", {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: (rootSchema, key) => gen.call(context, schema[keys[length]], schema, keys[length], rootSchema, key.slice())
                  });
                  break;
                }
              }
            }
            return schema;
          }
        };
        var Container_default = Container;
        module2.exports = Container_default;
      }
    });
    var require_format = __commonJS2({
      "src/lib/api/format.js"(exports2, module2) {
        var Registry = require_Registry();
        var registry = new Registry();
        function formatAPI(nameOrFormatMap, callback) {
          if (typeof nameOrFormatMap === "undefined") {
            return registry.list();
          }
          if (typeof nameOrFormatMap === "string") {
            if (typeof callback === "function") {
              registry.register(nameOrFormatMap, callback);
            } else if (callback === null || callback === false) {
              registry.unregister(nameOrFormatMap);
            } else {
              return registry.get(nameOrFormatMap);
            }
          } else {
            registry.registerMany(nameOrFormatMap);
          }
        }
        var format_default = formatAPI;
        module2.exports = format_default;
      }
    });
    var require_error = __commonJS2({
      "src/lib/core/error.js"(exports2, module2) {
        var ParseError = class extends Error {
          constructor(message, path) {
            super();
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
            this.name = "ParseError";
            this.message = message;
            this.path = path;
          }
        };
        var error_default = ParseError;
        module2.exports = error_default;
      }
    });
    var require_infer = __commonJS2({
      "src/lib/core/infer.js"(exports2, module2) {
        var inferredProperties = {
          array: [
            "additionalItems",
            "items",
            "maxItems",
            "minItems",
            "uniqueItems"
          ],
          integer: [
            "exclusiveMaximum",
            "exclusiveMinimum",
            "maximum",
            "minimum",
            "multipleOf"
          ],
          object: [
            "additionalProperties",
            "dependencies",
            "maxProperties",
            "minProperties",
            "patternProperties",
            "properties",
            "required"
          ],
          string: [
            "maxLength",
            "minLength",
            "pattern",
            "format"
          ]
        };
        inferredProperties.number = inferredProperties.integer;
        var subschemaProperties = [
          "additionalItems",
          "items",
          "additionalProperties",
          "dependencies",
          "patternProperties",
          "properties"
        ];
        function matchesType(obj, lastElementInPath, inferredTypeProperties) {
          return Object.keys(obj).filter((prop) => {
            const isSubschema = subschemaProperties.indexOf(lastElementInPath) > -1;
            const inferredPropertyFound = inferredTypeProperties.indexOf(prop) > -1;
            if (inferredPropertyFound && !isSubschema) {
              return true;
            }
            return false;
          }).length > 0;
        }
        function inferType(obj, schemaPath) {
          const keys = Object.keys(inferredProperties);
          for (let i = 0; i < keys.length; i += 1) {
            const typeName = keys[i];
            const lastElementInPath = schemaPath[schemaPath.length - 1];
            if (matchesType(obj, lastElementInPath, inferredProperties[typeName])) {
              return typeName;
            }
          }
        }
        var infer_default = inferType;
        module2.exports = infer_default;
      }
    });
    var require_boolean = __commonJS2({
      "src/lib/generators/boolean.js"(exports2, module2) {
        var optionAPI = require_option();
        function booleanGenerator() {
          return optionAPI("random")() > 0.5;
        }
        var boolean_default = booleanGenerator;
        module2.exports = boolean_default;
      }
    });
    var require_boolean2 = __commonJS2({
      "src/lib/types/boolean.js"(exports2, module2) {
        var booleanGenerator = require_boolean();
        var booleanType = booleanGenerator;
        var boolean_default = booleanType;
        module2.exports = boolean_default;
      }
    });
    var require_null = __commonJS2({
      "src/lib/generators/null.js"(exports2, module2) {
        function nullGenerator() {
          return null;
        }
        var null_default = nullGenerator;
        module2.exports = null_default;
      }
    });
    var require_null2 = __commonJS2({
      "src/lib/types/null.js"(exports2, module2) {
        var nullGenerator = require_null();
        var nullType = nullGenerator;
        var null_default = nullType;
        module2.exports = null_default;
      }
    });
    var require_array = __commonJS2({
      "src/lib/types/array.js"(exports2, module2) {
        var random = require_random();
        var utils = require_utils();
        var ParseError = require_error();
        var optionAPI = require_option();
        function unique(path, items, value, sample, resolve, traverseCallback) {
          const tmp = [];
          const seen = [];
          function walk(obj) {
            const json = JSON.stringify(obj);
            if (seen.indexOf(json) === -1) {
              seen.push(json);
              tmp.push(obj);
              return true;
            }
            return false;
          }
          items.forEach(walk);
          let limit = 100;
          while (tmp.length !== items.length) {
            if (!walk(traverseCallback(value.items || sample, path, resolve))) {
              limit -= 1;
            }
            if (!limit) {
              break;
            }
          }
          return tmp;
        }
        function arrayType(value, path, resolve, traverseCallback) {
          const items = [];
          if (!(value.items || value.additionalItems)) {
            if (utils.hasProperties(value, "minItems", "maxItems", "uniqueItems")) {
              throw new ParseError(`missing items for ${utils.short(value)}`, path);
            }
            return items;
          }
          if (Array.isArray(value.items)) {
            return value.items.map((item, key) => {
              const itemSubpath = path.concat(["items", key]);
              return traverseCallback(item, itemSubpath, resolve);
            });
          }
          let minItems = value.minItems;
          let maxItems = value.maxItems;
          const defaultMinItems = optionAPI("minItems");
          const defaultMaxItems = optionAPI("maxItems");
          if (defaultMinItems) {
            minItems = typeof minItems === "undefined" ? defaultMinItems : Math.min(defaultMinItems, minItems);
          }
          if (defaultMaxItems) {
            maxItems = typeof maxItems === "undefined" ? defaultMaxItems : Math.min(defaultMaxItems, maxItems);
            if (maxItems && maxItems > defaultMaxItems) {
              maxItems = defaultMaxItems;
            }
            if (minItems && minItems > defaultMaxItems) {
              minItems = maxItems;
            }
          }
          const optionalsProbability = optionAPI("alwaysFakeOptionals") === true ? 1 : optionAPI("optionalsProbability");
          const fixedProbabilities = optionAPI("alwaysFakeOptionals") || optionAPI("fixedProbabilities") || false;
          let length = random.number(minItems, maxItems, 1, 5);
          if (optionalsProbability !== null) {
            length = Math.max(fixedProbabilities ? Math.round((maxItems || length) * optionalsProbability) : Math.abs(random.number(minItems, maxItems) * optionalsProbability), minItems || 0);
          }
          const sample = typeof value.additionalItems === "object" ? value.additionalItems : {};
          for (let current = items.length; current < length; current += 1) {
            const itemSubpath = path.concat(["items", current]);
            const element = traverseCallback(value.items || sample, itemSubpath, resolve);
            items.push(element);
          }
          if (value.contains && length > 0) {
            const idx = random.number(0, length - 1);
            items[idx] = traverseCallback(value.contains, path.concat(["items", idx]), resolve);
          }
          if (value.uniqueItems) {
            return unique(path.concat(["items"]), items, value, sample, resolve, traverseCallback);
          }
          return items;
        }
        var array_default = arrayType;
        module2.exports = array_default;
      }
    });
    var require_number = __commonJS2({
      "src/lib/types/number.js"(exports2, module2) {
        var random = require_random();
        var env = require_constants();
        function numberType(value) {
          let min = typeof value.minimum === "undefined" ? env.MIN_INTEGER : value.minimum;
          let max = typeof value.maximum === "undefined" ? env.MAX_INTEGER : value.maximum;
          const multipleOf = value.multipleOf;
          if (multipleOf) {
            max = Math.floor(max / multipleOf) * multipleOf;
            min = Math.ceil(min / multipleOf) * multipleOf;
          }
          if (value.exclusiveMinimum && min === value.minimum) {
            min += multipleOf || 1;
          }
          if (value.exclusiveMaximum && max === value.maximum) {
            max -= multipleOf || 1;
          }
          if (min > max) {
            return NaN;
          }
          if (multipleOf) {
            if (String(multipleOf).indexOf(".") === -1) {
              let base = random.number(Math.floor(min / multipleOf), Math.floor(max / multipleOf)) * multipleOf;
              while (base < min) {
                base += value.multipleOf;
              }
              return base;
            }
            const boundary = (max - min) / multipleOf;
            let num;
            let fix;
            do {
              num = random.number(0, boundary) * multipleOf;
              fix = num / multipleOf % 1;
            } while (fix !== 0);
            return min + num;
          }
          return random.number(min, max, void 0, void 0, true);
        }
        var number_default = numberType;
        module2.exports = number_default;
      }
    });
    var require_integer = __commonJS2({
      "src/lib/types/integer.js"(exports2, module2) {
        var number = require_number();
        function integerType(value) {
          return number(__spreadValues({ multipleOf: 1 }, value));
        }
        var integer_default = integerType;
        module2.exports = integer_default;
      }
    });
    var require_words = __commonJS2({
      "src/lib/generators/words.js"(exports2, module2) {
        var random = require_random();
        var LIPSUM_WORDS = `Lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut labore
et dolore magna aliqua Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
commodo consequat Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
pariatur Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est
laborum`.split(/\W/);
        function wordsGenerator(length) {
          const words = random.shuffle(LIPSUM_WORDS);
          return words.slice(0, length);
        }
        var words_default = wordsGenerator;
        module2.exports = words_default;
      }
    });
    var require_object = __commonJS2({
      "src/lib/types/object.js"(exports2, module2) {
        var constants = require_constants();
        var random = require_random();
        var words = require_words();
        var utils = require_utils();
        var optionAPI = require_option();
        var anyType = { type: constants.ALLOWED_TYPES };
        function objectType(value, path, resolve, traverseCallback) {
          const props = {};
          const properties = value.properties || {};
          const patternProperties = value.patternProperties || {};
          const requiredProperties = typeof value.required === "boolean" ? [] : (value.required || []).slice();
          const allowsAdditional = value.additionalProperties !== false;
          const propertyKeys = Object.keys(properties);
          const patternPropertyKeys = Object.keys(patternProperties);
          const optionalProperties = propertyKeys.concat(patternPropertyKeys).reduce((_response, _key) => {
            if (requiredProperties.indexOf(_key) === -1)
              _response.push(_key);
            return _response;
          }, []);
          const allProperties = requiredProperties.concat(optionalProperties);
          const additionalProperties = allowsAdditional ? value.additionalProperties === true ? anyType : value.additionalProperties : value.additionalProperties;
          if (!allowsAdditional && propertyKeys.length === 0 && patternPropertyKeys.length === 0 && utils.hasProperties(value, "minProperties", "maxProperties", "dependencies", "required")) {
            return null;
          }
          if (optionAPI("requiredOnly") === true) {
            requiredProperties.forEach((key) => {
              if (properties[key]) {
                props[key] = properties[key];
              }
            });
            return traverseCallback(props, path.concat(["properties"]), resolve, value);
          }
          const optionalsProbability = optionAPI("alwaysFakeOptionals") === true ? 1 : optionAPI("optionalsProbability");
          const fixedProbabilities = optionAPI("alwaysFakeOptionals") || optionAPI("fixedProbabilities") || false;
          const ignoreProperties = optionAPI("ignoreProperties") || [];
          const reuseProps = optionAPI("reuseProperties");
          const fillProps = optionAPI("fillProperties");
          const max = value.maxProperties || allProperties.length + (allowsAdditional ? random.number(1, 5) : 0);
          let min = Math.max(value.minProperties || 0, requiredProperties.length);
          let neededExtras = Math.max(0, allProperties.length - min);
          if (allProperties.length === 1 && !requiredProperties.length) {
            min = Math.max(random.number(fillProps ? 1 : 0, max), min);
          }
          if (optionalsProbability !== null) {
            if (fixedProbabilities === true) {
              neededExtras = Math.round(min - requiredProperties.length + optionalsProbability * (allProperties.length - min));
            } else {
              neededExtras = random.number(min - requiredProperties.length, optionalsProbability * (allProperties.length - min));
            }
          }
          const extraPropertiesRandomOrder = random.shuffle(optionalProperties).slice(0, neededExtras);
          const extraProperties = optionalProperties.filter((_item) => {
            return extraPropertiesRandomOrder.indexOf(_item) !== -1;
          });
          const _limit = optionalsProbability !== null || requiredProperties.length === max ? max : random.number(0, max);
          const _props = requiredProperties.concat(random.shuffle(extraProperties).slice(0, _limit)).slice(0, max);
          const _defns = [];
          if (value.dependencies) {
            Object.keys(value.dependencies).forEach((prop) => {
              const _required = value.dependencies[prop];
              if (_props.indexOf(prop) !== -1) {
                if (Array.isArray(_required)) {
                  _required.forEach((sub) => {
                    if (_props.indexOf(sub) === -1) {
                      _props.push(sub);
                    }
                  });
                } else {
                  _defns.push(_required);
                }
              }
            });
            if (_defns.length) {
              delete value.dependencies;
              return traverseCallback({
                allOf: _defns.concat(value)
              }, path.concat(["properties"]), resolve, value);
            }
          }
          const skipped = [];
          const missing = [];
          _props.forEach((key) => {
            for (let i = 0; i < ignoreProperties.length; i += 1) {
              if (ignoreProperties[i] instanceof RegExp && ignoreProperties[i].test(key) || typeof ignoreProperties[i] === "string" && ignoreProperties[i] === key || typeof ignoreProperties[i] === "function" && ignoreProperties[i](properties[key], key)) {
                skipped.push(key);
                return;
              }
            }
            if (additionalProperties === false) {
              if (requiredProperties.indexOf(key) !== -1) {
                props[key] = properties[key];
              }
            }
            if (properties[key]) {
              props[key] = properties[key];
            }
            let found;
            patternPropertyKeys.forEach((_key) => {
              if (key.match(new RegExp(_key))) {
                found = true;
                if (props[key]) {
                  utils.merge(props[key], patternProperties[_key]);
                } else {
                  props[random.randexp(key)] = patternProperties[_key];
                }
              }
            });
            if (!found) {
              const subschema = patternProperties[key] || additionalProperties;
              if (subschema && additionalProperties !== false) {
                props[patternProperties[key] ? random.randexp(key) : key] = properties[key] || subschema;
              } else {
                missing.push(key);
              }
            }
          });
          let current = Object.keys(props).length + (fillProps ? 0 : skipped.length);
          const hash = (suffix) => random.randexp(`_?[_a-f\\d]{1,3}${suffix ? "\\$?" : ""}`);
          function get(from) {
            let one;
            do {
              if (!from.length)
                break;
              one = from.shift();
            } while (props[one]);
            return one;
          }
          let minProps = min;
          if (allowsAdditional && !requiredProperties.length) {
            minProps = Math.max(optionalsProbability === null || additionalProperties ? random.number(fillProps ? 1 : 0, max) : 0, min);
          }
          while (fillProps) {
            if (!(patternPropertyKeys.length || allowsAdditional)) {
              break;
            }
            if (current >= minProps) {
              break;
            }
            if (allowsAdditional) {
              if (reuseProps && propertyKeys.length - current > minProps) {
                let count = 0;
                let key;
                do {
                  count += 1;
                  if (count > 1e3) {
                    break;
                  }
                  key = get(requiredProperties) || random.pick(propertyKeys);
                } while (typeof props[key] !== "undefined");
                if (typeof props[key] === "undefined") {
                  props[key] = properties[key];
                  current += 1;
                }
              } else if (patternPropertyKeys.length && !additionalProperties) {
                const prop = random.pick(patternPropertyKeys);
                const word = random.randexp(prop);
                if (!props[word]) {
                  props[word] = patternProperties[prop];
                  current += 1;
                }
              } else {
                const word = get(requiredProperties) || words(1) + hash();
                if (!props[word]) {
                  props[word] = additionalProperties || anyType;
                  current += 1;
                }
              }
            }
            for (let i = 0; current < min && i < patternPropertyKeys.length; i += 1) {
              const _key = patternPropertyKeys[i];
              const word = random.randexp(_key);
              if (!props[word]) {
                props[word] = patternProperties[_key];
                current += 1;
              }
            }
          }
          if (requiredProperties.length === 0 && (!allowsAdditional || optionalsProbability === false)) {
            const maximum = random.number(min, max);
            for (; current < maximum; ) {
              const word = get(propertyKeys);
              if (word) {
                props[word] = properties[word];
              }
              current += 1;
            }
          }
          return traverseCallback(props, path.concat(["properties"]), resolve, value);
        }
        var object_default = objectType;
        module2.exports = object_default;
      }
    });
    var require_thunk = __commonJS2({
      "src/lib/generators/thunk.js"(exports2, module2) {
        var words = require_words();
        var random = require_random();
        function produce() {
          const length = random.number(1, 5);
          return words(length).join(" ");
        }
        function thunkGenerator(min = 0, max = 140) {
          const _min = Math.max(0, min);
          const _max = random.number(_min, max);
          let result = produce();
          while (result.length < _min) {
            result += produce();
          }
          if (result.length > _max) {
            result = result.substr(0, _max);
          }
          return result;
        }
        var thunk_default = thunkGenerator;
        module2.exports = thunk_default;
      }
    });
    var require_ipv4 = __commonJS2({
      "src/lib/generators/ipv4.js"(exports2, module2) {
        var random = require_random();
        function ipv4Generator() {
          return [0, 0, 0, 0].map(() => {
            return random.number(0, 255);
          }).join(".");
        }
        var ipv4_default = ipv4Generator;
        module2.exports = ipv4_default;
      }
    });
    var require_dateTime = __commonJS2({
      "src/lib/generators/dateTime.js"(exports2, module2) {
        var random = require_random();
        function dateTimeGenerator() {
          return random.date().toISOString();
        }
        var dateTime_default = dateTimeGenerator;
        module2.exports = dateTime_default;
      }
    });
    var require_date = __commonJS2({
      "src/lib/generators/date.js"(exports2, module2) {
        var dateTimeGenerator = require_dateTime();
        function dateGenerator() {
          return dateTimeGenerator().slice(0, 10);
        }
        var date_default = dateGenerator;
        module2.exports = date_default;
      }
    });
    var require_time = __commonJS2({
      "src/lib/generators/time.js"(exports2, module2) {
        var dateTimeGenerator = require_dateTime();
        function timeGenerator() {
          return dateTimeGenerator().slice(11);
        }
        var time_default = timeGenerator;
        module2.exports = time_default;
      }
    });
    var require_coreFormat = __commonJS2({
      "src/lib/generators/coreFormat.js"(exports2, module2) {
        var random = require_random();
        var FRAGMENT = "[a-zA-Z][a-zA-Z0-9+-.]*";
        var URI_PATTERN = `https?://{hostname}(?:${FRAGMENT})+`;
        var PARAM_PATTERN = "(?:\\?([a-z]{1,7}(=\\w{1,5})?&){0,3})?";
        var regexps = {
          email: "[a-zA-Z\\d][a-zA-Z\\d-]{1,13}[a-zA-Z\\d]@{hostname}",
          hostname: "[a-zA-Z]{1,33}\\.[a-z]{2,4}",
          ipv6: "[a-f\\d]{4}(:[a-f\\d]{4}){7}",
          uri: URI_PATTERN,
          slug: "[a-zA-Z\\d_-]+",
          "uri-reference": `${URI_PATTERN}${PARAM_PATTERN}`,
          "uri-template": URI_PATTERN.replace("(?:", "(?:/\\{[a-z][:a-zA-Z0-9-]*\\}|"),
          "json-pointer": `(/(?:${FRAGMENT.replace("]*", "/]*")}|~[01]))+`,
          uuid: "^[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$"
        };
        regexps.iri = regexps["uri-reference"];
        regexps["iri-reference"] = regexps["uri-reference"];
        regexps["idn-email"] = regexps.email;
        regexps["idn-hostname"] = regexps.hostname;
        var ALLOWED_FORMATS = new RegExp(`\\{(${Object.keys(regexps).join("|")})\\}`);
        function coreFormatGenerator(coreFormat) {
          return random.randexp(regexps[coreFormat]).replace(ALLOWED_FORMATS, (match, key) => {
            return random.randexp(regexps[key]);
          });
        }
        var coreFormat_default = coreFormatGenerator;
        module2.exports = coreFormat_default;
      }
    });
    var require_string = __commonJS2({
      "src/lib/types/string.js"(exports2, module2) {
        var thunk = require_thunk();
        var ipv4 = require_ipv4();
        var dateTime = require_dateTime();
        var date = require_date();
        var time = require_time();
        var coreFormat = require_coreFormat();
        var optionAPI = require_option();
        var format = require_format();
        var random = require_random();
        var utils = require_utils();
        function generateFormat(value, invalid) {
          const callback = format(value.format);
          if (typeof callback === "function") {
            return callback(value);
          }
          switch (value.format) {
            case "date-time":
            case "datetime":
              return dateTime();
            case "date":
              return date();
            case "time":
              return time();
            case "ipv4":
              return ipv4();
            case "regex":
              return ".+?";
            case "email":
            case "hostname":
            case "ipv6":
            case "uri":
            case "uri-reference":
            case "iri":
            case "iri-reference":
            case "idn-email":
            case "idn-hostname":
            case "json-pointer":
            case "slug":
            case "uri-template":
            case "uuid":
              return coreFormat(value.format);
            default:
              if (typeof callback === "undefined") {
                if (optionAPI("failOnInvalidFormat")) {
                  throw new Error(`unknown registry key ${utils.short(value.format)}`);
                } else {
                  return invalid();
                }
              }
              throw new Error(`unsupported format '${value.format}'`);
          }
        }
        function stringType(value) {
          const output = utils.typecast("string", value, (opts) => {
            if (value.format) {
              return generateFormat(value, () => thunk(opts.minLength, opts.maxLength));
            }
            if (value.pattern) {
              return random.randexp(value.pattern);
            }
            return thunk(opts.minLength, opts.maxLength);
          });
          return output;
        }
        var string_default = stringType;
        module2.exports = string_default;
      }
    });
    var require_types2 = __commonJS2({
      "src/lib/types/index.js"(exports2, module2) {
        var _boolean = require_boolean2();
        var _null = require_null2();
        var _array = require_array();
        var _integer = require_integer();
        var _number = require_number();
        var _object = require_object();
        var _string = require_string();
        var typeMap = {
          boolean: _boolean,
          null: _null,
          array: _array,
          integer: _integer,
          number: _number,
          object: _object,
          string: _string
        };
        var types_default = typeMap;
        module2.exports = types_default;
      }
    });
    var require_traverse = __commonJS2({
      "src/lib/core/traverse.js"(exports2, module2) {
        var utils = require_utils();
        var random = require_random();
        var ParseError = require_error();
        var inferType = require_infer();
        var types = require_types2();
        var optionAPI = require_option();
        function getMeta({ $comment: comment, title, description }) {
          return Object.entries({ comment, title, description }).filter(([, value]) => value).reduce((memo, [k, v]) => {
            memo[k] = v;
            return memo;
          }, {});
        }
        function traverse(schema, path, resolve, rootSchema) {
          schema = resolve(schema, null, path);
          if (schema && (schema.oneOf || schema.anyOf || schema.allOf)) {
            schema = resolve(schema, null, path);
          }
          if (!schema) {
            return;
          }
          const context = getMeta(schema);
          if (path[path.length - 1] !== "properties") {
            if (optionAPI("useExamplesValue") && Array.isArray(schema.examples)) {
              const fixedExamples = schema.examples.concat("default" in schema ? [schema.default] : []);
              return { value: utils.typecast(null, schema, () => random.pick(fixedExamples)), context };
            }
            if (optionAPI("useDefaultValue") && "default" in schema) {
              if (schema.default !== "" || !optionAPI("replaceEmptyByRandomValue")) {
                return { value: schema.default, context };
              }
            }
            if ("template" in schema) {
              return { value: utils.template(schema.template, rootSchema), context };
            }
            if ("const" in schema) {
              return { value: schema.const, context };
            }
          }
          if (schema.not && typeof schema.not === "object") {
            schema = utils.notValue(schema.not, utils.omitProps(schema, ["not"]));
            if (schema.type && schema.type === "object") {
              const { value, context: innerContext } = traverse(schema, path.concat(["not"]), resolve, rootSchema);
              return { value: utils.clean(value, schema, false), context: __spreadProps(__spreadValues({}, context), { items: innerContext }) };
            }
          }
          if (typeof schema.thunk === "function") {
            const { value, context: innerContext } = traverse(schema.thunk(rootSchema), path, resolve);
            return { value, context: __spreadProps(__spreadValues({}, context), { items: innerContext }) };
          }
          if (typeof schema.generate === "function") {
            const retval = utils.typecast(null, schema, () => schema.generate(rootSchema, path));
            const type2 = retval === null ? "null" : typeof retval;
            if (type2 === schema.type || Array.isArray(schema.type) && schema.type.includes(type2) || type2 === "number" && schema.type === "integer" || Array.isArray(retval) && schema.type === "array") {
              return { value: retval, context };
            }
          }
          if (typeof schema.pattern === "string") {
            return { value: utils.typecast("string", schema, () => random.randexp(schema.pattern)), context };
          }
          if (Array.isArray(schema.enum)) {
            return { value: utils.typecast(null, schema, () => random.pick(schema.enum)), context };
          }
          if (schema.jsonPath) {
            return { value: schema, context };
          }
          let type = schema.type;
          if (Array.isArray(type)) {
            type = random.pick(type);
          } else if (typeof type === "undefined") {
            type = inferType(schema, path) || type;
            if (type) {
              schema.type = type;
            }
          }
          if (typeof type === "string") {
            if (!types[type]) {
              if (optionAPI("failOnInvalidTypes")) {
                throw new ParseError(`unknown primitive ${utils.short(type)}`, path.concat(["type"]));
              } else {
                const value = optionAPI("defaultInvalidTypeProduct");
                if (typeof value === "string" && types[value]) {
                  return { value: types[value](schema, path, resolve, traverse), context };
                }
                return { value, context };
              }
            } else {
              try {
                const innerResult = types[type](schema, path, resolve, traverse);
                if (type === "array") {
                  return {
                    value: innerResult.map(({ value }) => value),
                    context: __spreadProps(__spreadValues({}, context), {
                      items: innerResult.map(({ context: c }) => c)
                    })
                  };
                }
                if (type === "object") {
                  return { value: innerResult.value, context: __spreadProps(__spreadValues({}, context), { items: innerResult.context }) };
                }
                return { value: innerResult, context };
              } catch (e) {
                if (typeof e.path === "undefined") {
                  throw new ParseError(e.stack, path);
                }
                throw e;
              }
            }
          }
          let valueCopy = {};
          let contextCopy = __spreadValues({}, context);
          if (Array.isArray(schema)) {
            valueCopy = [];
          }
          Object.keys(schema).forEach((prop) => {
            if (typeof schema[prop] === "object" && prop !== "definitions") {
              const { value, context: innerContext } = traverse(schema[prop], path.concat([prop]), resolve, valueCopy);
              valueCopy[prop] = utils.clean(value, schema[prop], false);
              contextCopy[prop] = innerContext;
            } else {
              valueCopy[prop] = schema[prop];
            }
          });
          return { value: valueCopy, context: contextCopy };
        }
        var traverse_default = traverse;
        module2.exports = traverse_default;
      }
    });
    var require_buildResolveSchema = __commonJS2({
      "src/lib/core/buildResolveSchema.js"(exports2, module2) {
        var optionAPI = require_option();
        var random = require_random();
        var utils = require_utils();
        var buildResolveSchema = ({
          refs,
          schema,
          container,
          synchronous,
          refDepthMax,
          refDepthMin
        }) => {
          const recursiveUtil = {};
          const seenRefs = {};
          let depth = 0;
          let lastRef;
          let lastPath;
          recursiveUtil.resolveSchema = (sub, index, rootPath) => {
            if (sub === null || sub === void 0) {
              return null;
            }
            if (typeof sub.generate === "function") {
              return sub;
            }
            const _id = sub.$id || sub.id;
            if (typeof _id === "string") {
              delete sub.id;
              delete sub.$id;
              delete sub.$schema;
            }
            if (typeof sub.$ref === "string") {
              const maxDepth = Math.max(refDepthMin, refDepthMax) - 1;
              if (sub.$ref === "#" || seenRefs[sub.$ref] < 0 || lastRef === sub.$ref && ++depth > maxDepth) {
                if (sub.$ref !== "#" && lastPath && lastPath.length === rootPath.length) {
                  return utils.getLocalRef(schema, sub.$ref, synchronous && refs);
                }
                delete sub.$ref;
                return sub;
              }
              if (typeof seenRefs[sub.$ref] === "undefined") {
                seenRefs[sub.$ref] = random.number(refDepthMin, refDepthMax) - 1;
              }
              lastPath = rootPath;
              lastRef = sub.$ref;
              let ref;
              if (sub.$ref.indexOf("#/") === -1) {
                ref = refs[sub.$ref] || null;
              } else {
                ref = utils.getLocalRef(schema, sub.$ref, synchronous && refs) || null;
              }
              if (typeof ref !== "undefined") {
                if (!ref && optionAPI("ignoreMissingRefs") !== true) {
                  throw new Error(`Reference not found: ${sub.$ref}`);
                }
                seenRefs[sub.$ref] -= 1;
                utils.merge(sub, ref || {});
              }
              delete sub.$ref;
              return sub;
            }
            if (Array.isArray(sub.allOf)) {
              const schemas = sub.allOf;
              delete sub.allOf;
              schemas.forEach((subSchema) => {
                const _sub = recursiveUtil.resolveSchema(subSchema, null, rootPath);
                utils.merge(sub, typeof _sub.thunk === "function" ? _sub.thunk(sub) : _sub);
                if (Array.isArray(sub.allOf)) {
                  recursiveUtil.resolveSchema(sub, index, rootPath);
                }
              });
            }
            if (Array.isArray(sub.oneOf || sub.anyOf)) {
              const mix = sub.oneOf || sub.anyOf;
              if (sub.enum && sub.oneOf) {
                sub.enum = sub.enum.filter((x) => utils.validate(x, mix));
              }
              return {
                thunk(rootSchema) {
                  const copy = utils.omitProps(sub, ["anyOf", "oneOf"]);
                  const fixed = random.pick(mix);
                  utils.merge(copy, fixed);
                  mix.forEach((omit) => {
                    if (omit.required && omit !== fixed) {
                      omit.required.forEach((key) => {
                        const includesKey = copy.required && copy.required.includes(key);
                        if (copy.properties && !includesKey) {
                          delete copy.properties[key];
                        }
                        if (rootSchema && rootSchema.properties) {
                          delete rootSchema.properties[key];
                        }
                      });
                    }
                  });
                  return copy;
                }
              };
            }
            Object.keys(sub).forEach((prop) => {
              if ((Array.isArray(sub[prop]) || typeof sub[prop] === "object") && !utils.isKey(prop)) {
                sub[prop] = recursiveUtil.resolveSchema(sub[prop], prop, rootPath.concat(prop));
              }
            });
            if (rootPath) {
              const lastProp = rootPath[rootPath.length - 1];
              if (lastProp === "properties" || lastProp === "items") {
                return sub;
              }
            }
            return container.wrap(sub);
          };
          return recursiveUtil;
        };
        var buildResolveSchema_default = buildResolveSchema;
        module2.exports = buildResolveSchema_default;
      }
    });
    var require_run = __commonJS2({
      "src/lib/core/run.js"(exports2, module2) {
        var { getDependencies } = require_vendor();
        var optionAPI = require_option();
        var traverse = require_traverse();
        var random = require_random();
        var utils = require_utils();
        var buildResolveSchema = require_buildResolveSchema();
        function pick(data) {
          return Array.isArray(data) ? random.pick(data) : data;
        }
        function cycle(data, reverse) {
          if (!Array.isArray(data)) {
            return data;
          }
          const value = reverse ? data.pop() : data.shift();
          if (reverse) {
            data.unshift(value);
          } else {
            data.push(value);
          }
          return value;
        }
        function resolve(obj, data, values, property) {
          if (!obj || typeof obj !== "object") {
            return obj;
          }
          if (!values) {
            values = {};
          }
          if (!data) {
            data = obj;
          }
          if (Array.isArray(obj)) {
            return obj.map((x) => resolve(x, data, values, property));
          }
          if (obj.jsonPath) {
            const { JSONPath: JSONPath2 } = getDependencies();
            const params = typeof obj.jsonPath !== "object" ? { path: obj.jsonPath } : obj.jsonPath;
            params.group = obj.group || params.group || property;
            params.cycle = obj.cycle || params.cycle || false;
            params.reverse = obj.reverse || params.reverse || false;
            params.count = obj.count || params.count || 1;
            const key = `${params.group}__${params.path}`;
            if (!values[key]) {
              if (params.count > 1) {
                values[key] = JSONPath2(params.path, data).slice(0, params.count);
              } else {
                values[key] = JSONPath2(params.path, data);
              }
            }
            if (params.cycle || params.reverse) {
              return cycle(values[key], params.reverse);
            }
            return pick(values[key]);
          }
          Object.keys(obj).forEach((k) => {
            obj[k] = resolve(obj[k], data, values, k);
          });
          return obj;
        }
        function run(refs, schema, container, synchronous) {
          if (Object.prototype.toString.call(schema) !== "[object Object]") {
            throw new Error(`Invalid input, expecting object but given ${typeof schema}`);
          }
          const refDepthMin = optionAPI("refDepthMin") || 0;
          const refDepthMax = optionAPI("refDepthMax") || 3;
          try {
            const { resolveSchema } = buildResolveSchema({
              refs,
              schema,
              container,
              synchronous,
              refDepthMin,
              refDepthMax
            });
            const result = traverse(utils.clone(schema), [], resolveSchema);
            if (optionAPI("resolveJsonPath")) {
              return {
                value: resolve(result.value),
                context: result.context
              };
            }
            return result;
          } catch (e) {
            if (e.path) {
              throw new Error(`${e.message} in /${e.path.join("/")}`);
            } else {
              throw e;
            }
          }
        }
        var run_default = run;
        module2.exports = run_default;
      }
    });
    var require_js = __commonJS2({
      "src/lib/renderers/js.js"(exports2, module2) {
        function renderJS(res) {
          return res.value;
        }
        var js_default = renderJS;
        module2.exports = js_default;
      }
    });
    var require_PlainValue_ec8e588e = __commonJS2({
      "node_modules/yaml/dist/PlainValue-ec8e588e.js"(exports2) {
        "use strict";
        var Char = {
          ANCHOR: "&",
          COMMENT: "#",
          TAG: "!",
          DIRECTIVES_END: "-",
          DOCUMENT_END: "."
        };
        var Type = {
          ALIAS: "ALIAS",
          BLANK_LINE: "BLANK_LINE",
          BLOCK_FOLDED: "BLOCK_FOLDED",
          BLOCK_LITERAL: "BLOCK_LITERAL",
          COMMENT: "COMMENT",
          DIRECTIVE: "DIRECTIVE",
          DOCUMENT: "DOCUMENT",
          FLOW_MAP: "FLOW_MAP",
          FLOW_SEQ: "FLOW_SEQ",
          MAP: "MAP",
          MAP_KEY: "MAP_KEY",
          MAP_VALUE: "MAP_VALUE",
          PLAIN: "PLAIN",
          QUOTE_DOUBLE: "QUOTE_DOUBLE",
          QUOTE_SINGLE: "QUOTE_SINGLE",
          SEQ: "SEQ",
          SEQ_ITEM: "SEQ_ITEM"
        };
        var defaultTagPrefix = "tag:yaml.org,2002:";
        var defaultTags = {
          MAP: "tag:yaml.org,2002:map",
          SEQ: "tag:yaml.org,2002:seq",
          STR: "tag:yaml.org,2002:str"
        };
        function findLineStarts(src) {
          const ls = [0];
          let offset = src.indexOf("\n");
          while (offset !== -1) {
            offset += 1;
            ls.push(offset);
            offset = src.indexOf("\n", offset);
          }
          return ls;
        }
        function getSrcInfo(cst) {
          let lineStarts, src;
          if (typeof cst === "string") {
            lineStarts = findLineStarts(cst);
            src = cst;
          } else {
            if (Array.isArray(cst))
              cst = cst[0];
            if (cst && cst.context) {
              if (!cst.lineStarts)
                cst.lineStarts = findLineStarts(cst.context.src);
              lineStarts = cst.lineStarts;
              src = cst.context.src;
            }
          }
          return {
            lineStarts,
            src
          };
        }
        function getLinePos(offset, cst) {
          if (typeof offset !== "number" || offset < 0)
            return null;
          const {
            lineStarts,
            src
          } = getSrcInfo(cst);
          if (!lineStarts || !src || offset > src.length)
            return null;
          for (let i = 0; i < lineStarts.length; ++i) {
            const start = lineStarts[i];
            if (offset < start) {
              return {
                line: i,
                col: offset - lineStarts[i - 1] + 1
              };
            }
            if (offset === start)
              return {
                line: i + 1,
                col: 1
              };
          }
          const line = lineStarts.length;
          return {
            line,
            col: offset - lineStarts[line - 1] + 1
          };
        }
        function getLine(line, cst) {
          const {
            lineStarts,
            src
          } = getSrcInfo(cst);
          if (!lineStarts || !(line >= 1) || line > lineStarts.length)
            return null;
          const start = lineStarts[line - 1];
          let end = lineStarts[line];
          while (end && end > start && src[end - 1] === "\n")
            --end;
          return src.slice(start, end);
        }
        function getPrettyContext({
          start,
          end
        }, cst, maxWidth = 80) {
          let src = getLine(start.line, cst);
          if (!src)
            return null;
          let {
            col
          } = start;
          if (src.length > maxWidth) {
            if (col <= maxWidth - 10) {
              src = src.substr(0, maxWidth - 1) + "\u2026";
            } else {
              const halfWidth = Math.round(maxWidth / 2);
              if (src.length > col + halfWidth)
                src = src.substr(0, col + halfWidth - 1) + "\u2026";
              col -= src.length - maxWidth;
              src = "\u2026" + src.substr(1 - maxWidth);
            }
          }
          let errLen = 1;
          let errEnd = "";
          if (end) {
            if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
              errLen = end.col - start.col;
            } else {
              errLen = Math.min(src.length + 1, maxWidth) - col;
              errEnd = "\u2026";
            }
          }
          const offset = col > 1 ? " ".repeat(col - 1) : "";
          const err = "^".repeat(errLen);
          return `${src}
${offset}${err}${errEnd}`;
        }
        var Range = class {
          static copy(orig) {
            return new Range(orig.start, orig.end);
          }
          constructor(start, end) {
            this.start = start;
            this.end = end || start;
          }
          isEmpty() {
            return typeof this.start !== "number" || !this.end || this.end <= this.start;
          }
          setOrigRange(cr, offset) {
            const {
              start,
              end
            } = this;
            if (cr.length === 0 || end <= cr[0]) {
              this.origStart = start;
              this.origEnd = end;
              return offset;
            }
            let i = offset;
            while (i < cr.length) {
              if (cr[i] > start)
                break;
              else
                ++i;
            }
            this.origStart = start + i;
            const nextOffset = i;
            while (i < cr.length) {
              if (cr[i] >= end)
                break;
              else
                ++i;
            }
            this.origEnd = end + i;
            return nextOffset;
          }
        };
        var Node = class {
          static addStringTerminator(src, offset, str) {
            if (str[str.length - 1] === "\n")
              return str;
            const next = Node.endOfWhiteSpace(src, offset);
            return next >= src.length || src[next] === "\n" ? str + "\n" : str;
          }
          static atDocumentBoundary(src, offset, sep) {
            const ch0 = src[offset];
            if (!ch0)
              return true;
            const prev = src[offset - 1];
            if (prev && prev !== "\n")
              return false;
            if (sep) {
              if (ch0 !== sep)
                return false;
            } else {
              if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
                return false;
            }
            const ch1 = src[offset + 1];
            const ch2 = src[offset + 2];
            if (ch1 !== ch0 || ch2 !== ch0)
              return false;
            const ch3 = src[offset + 3];
            return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
          }
          static endOfIdentifier(src, offset) {
            let ch = src[offset];
            const isVerbatim = ch === "<";
            const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
            while (ch && notOk.indexOf(ch) === -1)
              ch = src[offset += 1];
            if (isVerbatim && ch === ">")
              offset += 1;
            return offset;
          }
          static endOfIndent(src, offset) {
            let ch = src[offset];
            while (ch === " ")
              ch = src[offset += 1];
            return offset;
          }
          static endOfLine(src, offset) {
            let ch = src[offset];
            while (ch && ch !== "\n")
              ch = src[offset += 1];
            return offset;
          }
          static endOfWhiteSpace(src, offset) {
            let ch = src[offset];
            while (ch === "	" || ch === " ")
              ch = src[offset += 1];
            return offset;
          }
          static startOfLine(src, offset) {
            let ch = src[offset - 1];
            if (ch === "\n")
              return offset;
            while (ch && ch !== "\n")
              ch = src[offset -= 1];
            return offset + 1;
          }
          static endOfBlockIndent(src, indent, lineStart) {
            const inEnd = Node.endOfIndent(src, lineStart);
            if (inEnd > lineStart + indent) {
              return inEnd;
            } else {
              const wsEnd = Node.endOfWhiteSpace(src, inEnd);
              const ch = src[wsEnd];
              if (!ch || ch === "\n")
                return wsEnd;
            }
            return null;
          }
          static atBlank(src, offset, endAsBlank) {
            const ch = src[offset];
            return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
          }
          static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
            if (!ch || indentDiff < 0)
              return false;
            if (indentDiff > 0)
              return true;
            return indicatorAsIndent && ch === "-";
          }
          static normalizeOffset(src, offset) {
            const ch = src[offset];
            return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node.endOfWhiteSpace(src, offset);
          }
          static foldNewline(src, offset, indent) {
            let inCount = 0;
            let error = false;
            let fold = "";
            let ch = src[offset + 1];
            while (ch === " " || ch === "	" || ch === "\n") {
              switch (ch) {
                case "\n":
                  inCount = 0;
                  offset += 1;
                  fold += "\n";
                  break;
                case "	":
                  if (inCount <= indent)
                    error = true;
                  offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
                  break;
                case " ":
                  inCount += 1;
                  offset += 1;
                  break;
              }
              ch = src[offset + 1];
            }
            if (!fold)
              fold = " ";
            if (ch && inCount <= indent)
              error = true;
            return {
              fold,
              offset,
              error
            };
          }
          constructor(type, props, context) {
            Object.defineProperty(this, "context", {
              value: context || null,
              writable: true
            });
            this.error = null;
            this.range = null;
            this.valueRange = null;
            this.props = props || [];
            this.type = type;
            this.value = null;
          }
          getPropValue(idx, key, skipKey) {
            if (!this.context)
              return null;
            const {
              src
            } = this.context;
            const prop = this.props[idx];
            return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
          }
          get anchor() {
            for (let i = 0; i < this.props.length; ++i) {
              const anchor = this.getPropValue(i, Char.ANCHOR, true);
              if (anchor != null)
                return anchor;
            }
            return null;
          }
          get comment() {
            const comments = [];
            for (let i = 0; i < this.props.length; ++i) {
              const comment = this.getPropValue(i, Char.COMMENT, true);
              if (comment != null)
                comments.push(comment);
            }
            return comments.length > 0 ? comments.join("\n") : null;
          }
          commentHasRequiredWhitespace(start) {
            const {
              src
            } = this.context;
            if (this.header && start === this.header.end)
              return false;
            if (!this.valueRange)
              return false;
            const {
              end
            } = this.valueRange;
            return start !== end || Node.atBlank(src, end - 1);
          }
          get hasComment() {
            if (this.context) {
              const {
                src
              } = this.context;
              for (let i = 0; i < this.props.length; ++i) {
                if (src[this.props[i].start] === Char.COMMENT)
                  return true;
              }
            }
            return false;
          }
          get hasProps() {
            if (this.context) {
              const {
                src
              } = this.context;
              for (let i = 0; i < this.props.length; ++i) {
                if (src[this.props[i].start] !== Char.COMMENT)
                  return true;
              }
            }
            return false;
          }
          get includesTrailingLines() {
            return false;
          }
          get jsonLike() {
            const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
            return jsonLikeTypes.indexOf(this.type) !== -1;
          }
          get rangeAsLinePos() {
            if (!this.range || !this.context)
              return void 0;
            const start = getLinePos(this.range.start, this.context.root);
            if (!start)
              return void 0;
            const end = getLinePos(this.range.end, this.context.root);
            return {
              start,
              end
            };
          }
          get rawValue() {
            if (!this.valueRange || !this.context)
              return null;
            const {
              start,
              end
            } = this.valueRange;
            return this.context.src.slice(start, end);
          }
          get tag() {
            for (let i = 0; i < this.props.length; ++i) {
              const tag = this.getPropValue(i, Char.TAG, false);
              if (tag != null) {
                if (tag[1] === "<") {
                  return {
                    verbatim: tag.slice(2, -1)
                  };
                } else {
                  const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
                  return {
                    handle,
                    suffix
                  };
                }
              }
            }
            return null;
          }
          get valueRangeContainsNewline() {
            if (!this.valueRange || !this.context)
              return false;
            const {
              start,
              end
            } = this.valueRange;
            const {
              src
            } = this.context;
            for (let i = start; i < end; ++i) {
              if (src[i] === "\n")
                return true;
            }
            return false;
          }
          parseComment(start) {
            const {
              src
            } = this.context;
            if (src[start] === Char.COMMENT) {
              const end = Node.endOfLine(src, start + 1);
              const commentRange = new Range(start, end);
              this.props.push(commentRange);
              return end;
            }
            return start;
          }
          setOrigRanges(cr, offset) {
            if (this.range)
              offset = this.range.setOrigRange(cr, offset);
            if (this.valueRange)
              this.valueRange.setOrigRange(cr, offset);
            this.props.forEach((prop) => prop.setOrigRange(cr, offset));
            return offset;
          }
          toString() {
            const {
              context: {
                src
              },
              range,
              value
            } = this;
            if (value != null)
              return value;
            const str = src.slice(range.start, range.end);
            return Node.addStringTerminator(src, range.end, str);
          }
        };
        var YAMLError = class extends Error {
          constructor(name, source, message) {
            if (!message || !(source instanceof Node))
              throw new Error(`Invalid arguments for new ${name}`);
            super();
            this.name = name;
            this.message = message;
            this.source = source;
          }
          makePretty() {
            if (!this.source)
              return;
            this.nodeType = this.source.type;
            const cst = this.source.context && this.source.context.root;
            if (typeof this.offset === "number") {
              this.range = new Range(this.offset, this.offset + 1);
              const start = cst && getLinePos(this.offset, cst);
              if (start) {
                const end = {
                  line: start.line,
                  col: start.col + 1
                };
                this.linePos = {
                  start,
                  end
                };
              }
              delete this.offset;
            } else {
              this.range = this.source.range;
              this.linePos = this.source.rangeAsLinePos;
            }
            if (this.linePos) {
              const {
                line,
                col
              } = this.linePos.start;
              this.message += ` at line ${line}, column ${col}`;
              const ctx = cst && getPrettyContext(this.linePos, cst);
              if (ctx)
                this.message += `:

${ctx}
`;
            }
            delete this.source;
          }
        };
        var YAMLReferenceError = class extends YAMLError {
          constructor(source, message) {
            super("YAMLReferenceError", source, message);
          }
        };
        var YAMLSemanticError = class extends YAMLError {
          constructor(source, message) {
            super("YAMLSemanticError", source, message);
          }
        };
        var YAMLSyntaxError = class extends YAMLError {
          constructor(source, message) {
            super("YAMLSyntaxError", source, message);
          }
        };
        var YAMLWarning = class extends YAMLError {
          constructor(source, message) {
            super("YAMLWarning", source, message);
          }
        };
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var PlainValue = class extends Node {
          static endOfLine(src, start, inFlow) {
            let ch = src[start];
            let offset = start;
            while (ch && ch !== "\n") {
              if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ","))
                break;
              const next = src[offset + 1];
              if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
                break;
              if ((ch === " " || ch === "	") && next === "#")
                break;
              offset += 1;
              ch = next;
            }
            return offset;
          }
          get strValue() {
            if (!this.valueRange || !this.context)
              return null;
            let {
              start,
              end
            } = this.valueRange;
            const {
              src
            } = this.context;
            let ch = src[end - 1];
            while (start < end && (ch === "\n" || ch === "	" || ch === " "))
              ch = src[--end - 1];
            let str = "";
            for (let i = start; i < end; ++i) {
              const ch2 = src[i];
              if (ch2 === "\n") {
                const {
                  fold,
                  offset
                } = Node.foldNewline(src, i, -1);
                str += fold;
                i = offset;
              } else if (ch2 === " " || ch2 === "	") {
                const wsStart = i;
                let next = src[i + 1];
                while (i < end && (next === " " || next === "	")) {
                  i += 1;
                  next = src[i + 1];
                }
                if (next !== "\n")
                  str += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
              } else {
                str += ch2;
              }
            }
            const ch0 = src[start];
            switch (ch0) {
              case "	": {
                const msg = "Plain value cannot start with a tab character";
                const errors = [new YAMLSemanticError(this, msg)];
                return {
                  errors,
                  str
                };
              }
              case "@":
              case "`": {
                const msg = `Plain value cannot start with reserved character ${ch0}`;
                const errors = [new YAMLSemanticError(this, msg)];
                return {
                  errors,
                  str
                };
              }
              default:
                return str;
            }
          }
          parseBlockValue(start) {
            const {
              indent,
              inFlow,
              src
            } = this.context;
            let offset = start;
            let valueEnd = start;
            for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
              if (Node.atDocumentBoundary(src, offset + 1))
                break;
              const end = Node.endOfBlockIndent(src, indent, offset + 1);
              if (end === null || src[end] === "#")
                break;
              if (src[end] === "\n") {
                offset = end;
              } else {
                valueEnd = PlainValue.endOfLine(src, end, inFlow);
                offset = valueEnd;
              }
            }
            if (this.valueRange.isEmpty())
              this.valueRange.start = start;
            this.valueRange.end = valueEnd;
            return valueEnd;
          }
          parse(context, start) {
            this.context = context;
            const {
              inFlow,
              src
            } = context;
            let offset = start;
            const ch = src[offset];
            if (ch && ch !== "#" && ch !== "\n") {
              offset = PlainValue.endOfLine(src, start, inFlow);
            }
            this.valueRange = new Range(start, offset);
            offset = Node.endOfWhiteSpace(src, offset);
            offset = this.parseComment(offset);
            if (!this.hasComment || this.valueRange.isEmpty()) {
              offset = this.parseBlockValue(offset);
            }
            return offset;
          }
        };
        exports2.Char = Char;
        exports2.Node = Node;
        exports2.PlainValue = PlainValue;
        exports2.Range = Range;
        exports2.Type = Type;
        exports2.YAMLError = YAMLError;
        exports2.YAMLReferenceError = YAMLReferenceError;
        exports2.YAMLSemanticError = YAMLSemanticError;
        exports2.YAMLSyntaxError = YAMLSyntaxError;
        exports2.YAMLWarning = YAMLWarning;
        exports2._defineProperty = _defineProperty;
        exports2.defaultTagPrefix = defaultTagPrefix;
        exports2.defaultTags = defaultTags;
      }
    });
    var require_resolveSeq_d03cb037 = __commonJS2({
      "node_modules/yaml/dist/resolveSeq-d03cb037.js"(exports2) {
        "use strict";
        var PlainValue = require_PlainValue_ec8e588e();
        function addCommentBefore(str, indent, comment) {
          if (!comment)
            return str;
          const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
          return `#${cc}
${indent}${str}`;
        }
        function addComment(str, indent, comment) {
          return !comment ? str : comment.indexOf("\n") === -1 ? `${str} #${comment}` : `${str}
` + comment.replace(/^/gm, `${indent || ""}#`);
        }
        var Node = class {
        };
        function toJSON(value, arg, ctx) {
          if (Array.isArray(value))
            return value.map((v, i) => toJSON(v, String(i), ctx));
          if (value && typeof value.toJSON === "function") {
            const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
            if (anchor)
              ctx.onCreate = (res2) => {
                anchor.res = res2;
                delete ctx.onCreate;
              };
            const res = value.toJSON(arg, ctx);
            if (anchor && ctx.onCreate)
              ctx.onCreate(res);
            return res;
          }
          if ((!ctx || !ctx.keep) && typeof value === "bigint")
            return Number(value);
          return value;
        }
        var Scalar = class extends Node {
          constructor(value) {
            super();
            this.value = value;
          }
          toJSON(arg, ctx) {
            return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
          }
          toString() {
            return String(this.value);
          }
        };
        function collectionFromPath(schema, path, value) {
          let v = value;
          for (let i = path.length - 1; i >= 0; --i) {
            const k = path[i];
            if (Number.isInteger(k) && k >= 0) {
              const a = [];
              a[k] = v;
              v = a;
            } else {
              const o = {};
              Object.defineProperty(o, k, {
                value: v,
                writable: true,
                enumerable: true,
                configurable: true
              });
              v = o;
            }
          }
          return schema.createNode(v, false);
        }
        var isEmptyPath = (path) => path == null || typeof path === "object" && path[Symbol.iterator]().next().done;
        var Collection = class extends Node {
          constructor(schema) {
            super();
            PlainValue._defineProperty(this, "items", []);
            this.schema = schema;
          }
          addIn(path, value) {
            if (isEmptyPath(path))
              this.add(value);
            else {
              const [key, ...rest] = path;
              const node = this.get(key, true);
              if (node instanceof Collection)
                node.addIn(rest, value);
              else if (node === void 0 && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
              else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
            }
          }
          deleteIn([key, ...rest]) {
            if (rest.length === 0)
              return this.delete(key);
            const node = this.get(key, true);
            if (node instanceof Collection)
              return node.deleteIn(rest);
            else
              throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
          }
          getIn([key, ...rest], keepScalar) {
            const node = this.get(key, true);
            if (rest.length === 0)
              return !keepScalar && node instanceof Scalar ? node.value : node;
            else
              return node instanceof Collection ? node.getIn(rest, keepScalar) : void 0;
          }
          hasAllNullValues() {
            return this.items.every((node) => {
              if (!node || node.type !== "PAIR")
                return false;
              const n = node.value;
              return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
            });
          }
          hasIn([key, ...rest]) {
            if (rest.length === 0)
              return this.has(key);
            const node = this.get(key, true);
            return node instanceof Collection ? node.hasIn(rest) : false;
          }
          setIn([key, ...rest], value) {
            if (rest.length === 0) {
              this.set(key, value);
            } else {
              const node = this.get(key, true);
              if (node instanceof Collection)
                node.setIn(rest, value);
              else if (node === void 0 && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
              else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
            }
          }
          toJSON() {
            return null;
          }
          toString(ctx, {
            blockItem,
            flowChars,
            isMap,
            itemIndent
          }, onComment, onChompKeep) {
            const {
              indent,
              indentStep,
              stringify
            } = ctx;
            const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
            if (inFlow)
              itemIndent += indentStep;
            const allNullValues = isMap && this.hasAllNullValues();
            ctx = Object.assign({}, ctx, {
              allNullValues,
              indent: itemIndent,
              inFlow,
              type: null
            });
            let chompKeep = false;
            let hasItemWithNewLine = false;
            const nodes = this.items.reduce((nodes2, item, i) => {
              let comment;
              if (item) {
                if (!chompKeep && item.spaceBefore)
                  nodes2.push({
                    type: "comment",
                    str: ""
                  });
                if (item.commentBefore)
                  item.commentBefore.match(/^.*$/gm).forEach((line) => {
                    nodes2.push({
                      type: "comment",
                      str: `#${line}`
                    });
                  });
                if (item.comment)
                  comment = item.comment;
                if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
                  hasItemWithNewLine = true;
              }
              chompKeep = false;
              let str2 = stringify(item, ctx, () => comment = null, () => chompKeep = true);
              if (inFlow && !hasItemWithNewLine && str2.includes("\n"))
                hasItemWithNewLine = true;
              if (inFlow && i < this.items.length - 1)
                str2 += ",";
              str2 = addComment(str2, itemIndent, comment);
              if (chompKeep && (comment || inFlow))
                chompKeep = false;
              nodes2.push({
                type: "item",
                str: str2
              });
              return nodes2;
            }, []);
            let str;
            if (nodes.length === 0) {
              str = flowChars.start + flowChars.end;
            } else if (inFlow) {
              const {
                start,
                end
              } = flowChars;
              const strings = nodes.map((n) => n.str);
              if (hasItemWithNewLine || strings.reduce((sum, str2) => sum + str2.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
                str = start;
                for (const s of strings) {
                  str += s ? `
${indentStep}${indent}${s}` : "\n";
                }
                str += `
${indent}${end}`;
              } else {
                str = `${start} ${strings.join(" ")} ${end}`;
              }
            } else {
              const strings = nodes.map(blockItem);
              str = strings.shift();
              for (const s of strings)
                str += s ? `
${indent}${s}` : "\n";
            }
            if (this.comment) {
              str += "\n" + this.comment.replace(/^/gm, `${indent}#`);
              if (onComment)
                onComment();
            } else if (chompKeep && onChompKeep)
              onChompKeep();
            return str;
          }
        };
        PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
        function asItemIndex(key) {
          let idx = key instanceof Scalar ? key.value : key;
          if (idx && typeof idx === "string")
            idx = Number(idx);
          return Number.isInteger(idx) && idx >= 0 ? idx : null;
        }
        var YAMLSeq = class extends Collection {
          add(value) {
            this.items.push(value);
          }
          delete(key) {
            const idx = asItemIndex(key);
            if (typeof idx !== "number")
              return false;
            const del = this.items.splice(idx, 1);
            return del.length > 0;
          }
          get(key, keepScalar) {
            const idx = asItemIndex(key);
            if (typeof idx !== "number")
              return void 0;
            const it = this.items[idx];
            return !keepScalar && it instanceof Scalar ? it.value : it;
          }
          has(key) {
            const idx = asItemIndex(key);
            return typeof idx === "number" && idx < this.items.length;
          }
          set(key, value) {
            const idx = asItemIndex(key);
            if (typeof idx !== "number")
              throw new Error(`Expected a valid index, not ${key}.`);
            this.items[idx] = value;
          }
          toJSON(_, ctx) {
            const seq = [];
            if (ctx && ctx.onCreate)
              ctx.onCreate(seq);
            let i = 0;
            for (const item of this.items)
              seq.push(toJSON(item, String(i++), ctx));
            return seq;
          }
          toString(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            return super.toString(ctx, {
              blockItem: (n) => n.type === "comment" ? n.str : `- ${n.str}`,
              flowChars: {
                start: "[",
                end: "]"
              },
              isMap: false,
              itemIndent: (ctx.indent || "") + "  "
            }, onComment, onChompKeep);
          }
        };
        var stringifyKey = (key, jsKey, ctx) => {
          if (jsKey === null)
            return "";
          if (typeof jsKey !== "object")
            return String(jsKey);
          if (key instanceof Node && ctx && ctx.doc)
            return key.toString({
              anchors: Object.create(null),
              doc: ctx.doc,
              indent: "",
              indentStep: ctx.indentStep,
              inFlow: true,
              inStringifyKey: true,
              stringify: ctx.stringify
            });
          return JSON.stringify(jsKey);
        };
        var Pair = class extends Node {
          constructor(key, value = null) {
            super();
            this.key = key;
            this.value = value;
            this.type = Pair.Type.PAIR;
          }
          get commentBefore() {
            return this.key instanceof Node ? this.key.commentBefore : void 0;
          }
          set commentBefore(cb) {
            if (this.key == null)
              this.key = new Scalar(null);
            if (this.key instanceof Node)
              this.key.commentBefore = cb;
            else {
              const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
              throw new Error(msg);
            }
          }
          addToJSMap(ctx, map) {
            const key = toJSON(this.key, "", ctx);
            if (map instanceof Map) {
              const value = toJSON(this.value, key, ctx);
              map.set(key, value);
            } else if (map instanceof Set) {
              map.add(key);
            } else {
              const stringKey = stringifyKey(this.key, key, ctx);
              const value = toJSON(this.value, stringKey, ctx);
              if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                  value,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              else
                map[stringKey] = value;
            }
            return map;
          }
          toJSON(_, ctx) {
            const pair = ctx && ctx.mapAsMap ? new Map() : {};
            return this.addToJSMap(ctx, pair);
          }
          toString(ctx, onComment, onChompKeep) {
            if (!ctx || !ctx.doc)
              return JSON.stringify(this);
            const {
              indent: indentSize,
              indentSeq,
              simpleKeys
            } = ctx.doc.options;
            let {
              key,
              value
            } = this;
            let keyComment = key instanceof Node && key.comment;
            if (simpleKeys) {
              if (keyComment) {
                throw new Error("With simple keys, key nodes cannot have comments");
              }
              if (key instanceof Collection) {
                const msg = "With simple keys, collection cannot be used as a key value";
                throw new Error(msg);
              }
            }
            let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === "object"));
            const {
              doc,
              indent,
              indentStep,
              stringify
            } = ctx;
            ctx = Object.assign({}, ctx, {
              implicitKey: !explicitKey,
              indent: indent + indentStep
            });
            let chompKeep = false;
            let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
            str = addComment(str, ctx.indent, keyComment);
            if (!explicitKey && str.length > 1024) {
              if (simpleKeys)
                throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
              explicitKey = true;
            }
            if (ctx.allNullValues && !simpleKeys) {
              if (this.comment) {
                str = addComment(str, ctx.indent, this.comment);
                if (onComment)
                  onComment();
              } else if (chompKeep && !keyComment && onChompKeep)
                onChompKeep();
              return ctx.inFlow && !explicitKey ? str : `? ${str}`;
            }
            str = explicitKey ? `? ${str}
${indent}:` : `${str}:`;
            if (this.comment) {
              str = addComment(str, ctx.indent, this.comment);
              if (onComment)
                onComment();
            }
            let vcb = "";
            let valueComment = null;
            if (value instanceof Node) {
              if (value.spaceBefore)
                vcb = "\n";
              if (value.commentBefore) {
                const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
                vcb += `
${cs}`;
              }
              valueComment = value.comment;
            } else if (value && typeof value === "object") {
              value = doc.schema.createNode(value, true);
            }
            ctx.implicitKey = false;
            if (!explicitKey && !this.comment && value instanceof Scalar)
              ctx.indentAtStart = str.length + 1;
            chompKeep = false;
            if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
              ctx.indent = ctx.indent.substr(2);
            }
            const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
            let ws = " ";
            if (vcb || this.comment) {
              ws = `${vcb}
${ctx.indent}`;
            } else if (!explicitKey && value instanceof Collection) {
              const flow = valueStr[0] === "[" || valueStr[0] === "{";
              if (!flow || valueStr.includes("\n"))
                ws = `
${ctx.indent}`;
            } else if (valueStr[0] === "\n")
              ws = "";
            if (chompKeep && !valueComment && onChompKeep)
              onChompKeep();
            return addComment(str + ws + valueStr, ctx.indent, valueComment);
          }
        };
        PlainValue._defineProperty(Pair, "Type", {
          PAIR: "PAIR",
          MERGE_PAIR: "MERGE_PAIR"
        });
        var getAliasCount = (node, anchors) => {
          if (node instanceof Alias) {
            const anchor = anchors.get(node.source);
            return anchor.count * anchor.aliasCount;
          } else if (node instanceof Collection) {
            let count = 0;
            for (const item of node.items) {
              const c = getAliasCount(item, anchors);
              if (c > count)
                count = c;
            }
            return count;
          } else if (node instanceof Pair) {
            const kc = getAliasCount(node.key, anchors);
            const vc = getAliasCount(node.value, anchors);
            return Math.max(kc, vc);
          }
          return 1;
        };
        var Alias = class extends Node {
          static stringify({
            range,
            source
          }, {
            anchors,
            doc,
            implicitKey,
            inStringifyKey
          }) {
            let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
            if (!anchor && inStringifyKey)
              anchor = doc.anchors.getName(source) || doc.anchors.newName();
            if (anchor)
              return `*${anchor}${implicitKey ? " " : ""}`;
            const msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
            throw new Error(`${msg} [${range}]`);
          }
          constructor(source) {
            super();
            this.source = source;
            this.type = PlainValue.Type.ALIAS;
          }
          set tag(t) {
            throw new Error("Alias nodes cannot have tags");
          }
          toJSON(arg, ctx) {
            if (!ctx)
              return toJSON(this.source, arg, ctx);
            const {
              anchors,
              maxAliasCount
            } = ctx;
            const anchor = anchors.get(this.source);
            if (!anchor || anchor.res === void 0) {
              const msg = "This should not happen: Alias anchor was not resolved?";
              if (this.cstNode)
                throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
              else
                throw new ReferenceError(msg);
            }
            if (maxAliasCount >= 0) {
              anchor.count += 1;
              if (anchor.aliasCount === 0)
                anchor.aliasCount = getAliasCount(this.source, anchors);
              if (anchor.count * anchor.aliasCount > maxAliasCount) {
                const msg = "Excessive alias count indicates a resource exhaustion attack";
                if (this.cstNode)
                  throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
                else
                  throw new ReferenceError(msg);
              }
            }
            return anchor.res;
          }
          toString(ctx) {
            return Alias.stringify(this, ctx);
          }
        };
        PlainValue._defineProperty(Alias, "default", true);
        function findPair(items, key) {
          const k = key instanceof Scalar ? key.value : key;
          for (const it of items) {
            if (it instanceof Pair) {
              if (it.key === key || it.key === k)
                return it;
              if (it.key && it.key.value === k)
                return it;
            }
          }
          return void 0;
        }
        var YAMLMap = class extends Collection {
          add(pair, overwrite) {
            if (!pair)
              pair = new Pair(pair);
            else if (!(pair instanceof Pair))
              pair = new Pair(pair.key || pair, pair.value);
            const prev = findPair(this.items, pair.key);
            const sortEntries = this.schema && this.schema.sortMapEntries;
            if (prev) {
              if (overwrite)
                prev.value = pair.value;
              else
                throw new Error(`Key ${pair.key} already set`);
            } else if (sortEntries) {
              const i = this.items.findIndex((item) => sortEntries(pair, item) < 0);
              if (i === -1)
                this.items.push(pair);
              else
                this.items.splice(i, 0, pair);
            } else {
              this.items.push(pair);
            }
          }
          delete(key) {
            const it = findPair(this.items, key);
            if (!it)
              return false;
            const del = this.items.splice(this.items.indexOf(it), 1);
            return del.length > 0;
          }
          get(key, keepScalar) {
            const it = findPair(this.items, key);
            const node = it && it.value;
            return !keepScalar && node instanceof Scalar ? node.value : node;
          }
          has(key) {
            return !!findPair(this.items, key);
          }
          set(key, value) {
            this.add(new Pair(key, value), true);
          }
          toJSON(_, ctx, Type) {
            const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
            if (ctx && ctx.onCreate)
              ctx.onCreate(map);
            for (const item of this.items)
              item.addToJSMap(ctx, map);
            return map;
          }
          toString(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            for (const item of this.items) {
              if (!(item instanceof Pair))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
            }
            return super.toString(ctx, {
              blockItem: (n) => n.str,
              flowChars: {
                start: "{",
                end: "}"
              },
              isMap: true,
              itemIndent: ctx.indent || ""
            }, onComment, onChompKeep);
          }
        };
        var MERGE_KEY = "<<";
        var Merge = class extends Pair {
          constructor(pair) {
            if (pair instanceof Pair) {
              let seq = pair.value;
              if (!(seq instanceof YAMLSeq)) {
                seq = new YAMLSeq();
                seq.items.push(pair.value);
                seq.range = pair.value.range;
              }
              super(pair.key, seq);
              this.range = pair.range;
            } else {
              super(new Scalar(MERGE_KEY), new YAMLSeq());
            }
            this.type = Pair.Type.MERGE_PAIR;
          }
          addToJSMap(ctx, map) {
            for (const {
              source
            } of this.value.items) {
              if (!(source instanceof YAMLMap))
                throw new Error("Merge sources must be maps");
              const srcMap = source.toJSON(null, ctx, Map);
              for (const [key, value] of srcMap) {
                if (map instanceof Map) {
                  if (!map.has(key))
                    map.set(key, value);
                } else if (map instanceof Set) {
                  map.add(key);
                } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
                  Object.defineProperty(map, key, {
                    value,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                }
              }
            }
            return map;
          }
          toString(ctx, onComment) {
            const seq = this.value;
            if (seq.items.length > 1)
              return super.toString(ctx, onComment);
            this.value = seq.items[0];
            const str = super.toString(ctx, onComment);
            this.value = seq;
            return str;
          }
        };
        var binaryOptions = {
          defaultType: PlainValue.Type.BLOCK_LITERAL,
          lineWidth: 76
        };
        var boolOptions = {
          trueStr: "true",
          falseStr: "false"
        };
        var intOptions = {
          asBigInt: false
        };
        var nullOptions = {
          nullStr: "null"
        };
        var strOptions = {
          defaultType: PlainValue.Type.PLAIN,
          doubleQuoted: {
            jsonEncoding: false,
            minMultiLineLength: 40
          },
          fold: {
            lineWidth: 80,
            minContentWidth: 20
          }
        };
        function resolveScalar(str, tags, scalarFallback) {
          for (const {
            format,
            test,
            resolve
          } of tags) {
            if (test) {
              const match = str.match(test);
              if (match) {
                let res = resolve.apply(null, match);
                if (!(res instanceof Scalar))
                  res = new Scalar(res);
                if (format)
                  res.format = format;
                return res;
              }
            }
          }
          if (scalarFallback)
            str = scalarFallback(str);
          return new Scalar(str);
        }
        var FOLD_FLOW = "flow";
        var FOLD_BLOCK = "block";
        var FOLD_QUOTED = "quoted";
        var consumeMoreIndentedLines = (text, i) => {
          let ch = text[i + 1];
          while (ch === " " || ch === "	") {
            do {
              ch = text[i += 1];
            } while (ch && ch !== "\n");
            ch = text[i + 1];
          }
          return i;
        };
        function foldFlowLines(text, indent, mode, {
          indentAtStart,
          lineWidth = 80,
          minContentWidth = 20,
          onFold,
          onOverflow
        }) {
          if (!lineWidth || lineWidth < 0)
            return text;
          const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
          if (text.length <= endStep)
            return text;
          const folds = [];
          const escapedFolds = {};
          let end = lineWidth - indent.length;
          if (typeof indentAtStart === "number") {
            if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
              folds.push(0);
            else
              end = lineWidth - indentAtStart;
          }
          let split = void 0;
          let prev = void 0;
          let overflow = false;
          let i = -1;
          let escStart = -1;
          let escEnd = -1;
          if (mode === FOLD_BLOCK) {
            i = consumeMoreIndentedLines(text, i);
            if (i !== -1)
              end = i + endStep;
          }
          for (let ch; ch = text[i += 1]; ) {
            if (mode === FOLD_QUOTED && ch === "\\") {
              escStart = i;
              switch (text[i + 1]) {
                case "x":
                  i += 3;
                  break;
                case "u":
                  i += 5;
                  break;
                case "U":
                  i += 9;
                  break;
                default:
                  i += 1;
              }
              escEnd = i;
            }
            if (ch === "\n") {
              if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i);
              end = i + endStep;
              split = void 0;
            } else {
              if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
                const next = text[i + 1];
                if (next && next !== " " && next !== "\n" && next !== "	")
                  split = i;
              }
              if (i >= end) {
                if (split) {
                  folds.push(split);
                  end = split + endStep;
                  split = void 0;
                } else if (mode === FOLD_QUOTED) {
                  while (prev === " " || prev === "	") {
                    prev = ch;
                    ch = text[i += 1];
                    overflow = true;
                  }
                  const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                  if (escapedFolds[j])
                    return text;
                  folds.push(j);
                  escapedFolds[j] = true;
                  end = j + endStep;
                  split = void 0;
                } else {
                  overflow = true;
                }
              }
            }
            prev = ch;
          }
          if (overflow && onOverflow)
            onOverflow();
          if (folds.length === 0)
            return text;
          if (onFold)
            onFold();
          let res = text.slice(0, folds[0]);
          for (let i2 = 0; i2 < folds.length; ++i2) {
            const fold = folds[i2];
            const end2 = folds[i2 + 1] || text.length;
            if (fold === 0)
              res = `
${indent}${text.slice(0, end2)}`;
            else {
              if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
              res += `
${indent}${text.slice(fold + 1, end2)}`;
            }
          }
          return res;
        }
        var getFoldOptions = ({
          indentAtStart
        }) => indentAtStart ? Object.assign({
          indentAtStart
        }, strOptions.fold) : strOptions.fold;
        var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
        function lineLengthOverLimit(str, lineWidth, indentLength) {
          if (!lineWidth || lineWidth < 0)
            return false;
          const limit = lineWidth - indentLength;
          const strLen = str.length;
          if (strLen <= limit)
            return false;
          for (let i = 0, start = 0; i < strLen; ++i) {
            if (str[i] === "\n") {
              if (i - start > limit)
                return true;
              start = i + 1;
              if (strLen - start <= limit)
                return false;
            }
          }
          return true;
        }
        function doubleQuotedString(value, ctx) {
          const {
            implicitKey
          } = ctx;
          const {
            jsonEncoding,
            minMultiLineLength
          } = strOptions.doubleQuoted;
          const json = JSON.stringify(value);
          if (jsonEncoding)
            return json;
          const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
          let str = "";
          let start = 0;
          for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
            if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
              str += json.slice(start, i) + "\\ ";
              i += 1;
              start = i;
              ch = "\\";
            }
            if (ch === "\\")
              switch (json[i + 1]) {
                case "u":
                  {
                    str += json.slice(start, i);
                    const code = json.substr(i + 2, 4);
                    switch (code) {
                      case "0000":
                        str += "\\0";
                        break;
                      case "0007":
                        str += "\\a";
                        break;
                      case "000b":
                        str += "\\v";
                        break;
                      case "001b":
                        str += "\\e";
                        break;
                      case "0085":
                        str += "\\N";
                        break;
                      case "00a0":
                        str += "\\_";
                        break;
                      case "2028":
                        str += "\\L";
                        break;
                      case "2029":
                        str += "\\P";
                        break;
                      default:
                        if (code.substr(0, 2) === "00")
                          str += "\\x" + code.substr(2);
                        else
                          str += json.substr(i, 6);
                    }
                    i += 5;
                    start = i + 1;
                  }
                  break;
                case "n":
                  if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                    i += 1;
                  } else {
                    str += json.slice(start, i) + "\n\n";
                    while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                      str += "\n";
                      i += 2;
                    }
                    str += indent;
                    if (json[i + 2] === " ")
                      str += "\\";
                    i += 1;
                    start = i + 1;
                  }
                  break;
                default:
                  i += 1;
              }
          }
          str = start ? str + json.slice(start) : json;
          return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
        }
        function singleQuotedString(value, ctx) {
          if (ctx.implicitKey) {
            if (/\n/.test(value))
              return doubleQuotedString(value, ctx);
          } else {
            if (/[ \t]\n|\n[ \t]/.test(value))
              return doubleQuotedString(value, ctx);
          }
          const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
          const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
          return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
        }
        function blockString({
          comment,
          type,
          value
        }, ctx, onComment, onChompKeep) {
          if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
            return doubleQuotedString(value, ctx);
          }
          const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
          const indentSize = indent ? "2" : "1";
          const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
          let header = literal ? "|" : ">";
          if (!value)
            return header + "\n";
          let wsStart = "";
          let wsEnd = "";
          value = value.replace(/[\n\t ]*$/, (ws) => {
            const n = ws.indexOf("\n");
            if (n === -1) {
              header += "-";
            } else if (value === ws || n !== ws.length - 1) {
              header += "+";
              if (onChompKeep)
                onChompKeep();
            }
            wsEnd = ws.replace(/\n$/, "");
            return "";
          }).replace(/^[\n ]*/, (ws) => {
            if (ws.indexOf(" ") !== -1)
              header += indentSize;
            const m = ws.match(/ +$/);
            if (m) {
              wsStart = ws.slice(0, -m[0].length);
              return m[0];
            } else {
              wsStart = ws;
              return "";
            }
          });
          if (wsEnd)
            wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
          if (wsStart)
            wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
          if (comment) {
            header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
            if (onComment)
              onComment();
          }
          if (!value)
            return `${header}${indentSize}
${indent}${wsEnd}`;
          if (literal) {
            value = value.replace(/\n+/g, `$&${indent}`);
            return `${header}
${indent}${wsStart}${value}${wsEnd}`;
          }
          value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
          const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
          return `${header}
${indent}${body}`;
        }
        function plainString(item, ctx, onComment, onChompKeep) {
          const {
            comment,
            type,
            value
          } = item;
          const {
            actualString,
            implicitKey,
            indent,
            inFlow
          } = ctx;
          if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
            return doubleQuotedString(value, ctx);
          }
          if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
            return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
          }
          if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf("\n") !== -1) {
            return blockString(item, ctx, onComment, onChompKeep);
          }
          if (indent === "" && containsDocumentMarker(value)) {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
          }
          const str = value.replace(/\n+/g, `$&
${indent}`);
          if (actualString) {
            const {
              tags
            } = ctx.doc.schema;
            const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
            if (typeof resolved !== "string")
              return doubleQuotedString(value, ctx);
          }
          const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
          if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
            if (onComment)
              onComment();
            return addCommentBefore(body, indent, comment);
          }
          return body;
        }
        function stringifyString(item, ctx, onComment, onChompKeep) {
          const {
            defaultType
          } = strOptions;
          const {
            implicitKey,
            inFlow
          } = ctx;
          let {
            type,
            value
          } = item;
          if (typeof value !== "string") {
            value = String(value);
            item = Object.assign({}, item, {
              value
            });
          }
          const _stringify = (_type) => {
            switch (_type) {
              case PlainValue.Type.BLOCK_FOLDED:
              case PlainValue.Type.BLOCK_LITERAL:
                return blockString(item, ctx, onComment, onChompKeep);
              case PlainValue.Type.QUOTE_DOUBLE:
                return doubleQuotedString(value, ctx);
              case PlainValue.Type.QUOTE_SINGLE:
                return singleQuotedString(value, ctx);
              case PlainValue.Type.PLAIN:
                return plainString(item, ctx, onComment, onChompKeep);
              default:
                return null;
            }
          };
          if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
            type = PlainValue.Type.QUOTE_DOUBLE;
          } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {
            type = PlainValue.Type.QUOTE_DOUBLE;
          }
          let res = _stringify(type);
          if (res === null) {
            res = _stringify(defaultType);
            if (res === null)
              throw new Error(`Unsupported default string type ${defaultType}`);
          }
          return res;
        }
        function stringifyNumber({
          format,
          minFractionDigits,
          tag,
          value
        }) {
          if (typeof value === "bigint")
            return String(value);
          if (!isFinite(value))
            return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
          let n = JSON.stringify(value);
          if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
            let i = n.indexOf(".");
            if (i < 0) {
              i = n.length;
              n += ".";
            }
            let d = minFractionDigits - (n.length - i - 1);
            while (d-- > 0)
              n += "0";
          }
          return n;
        }
        function checkFlowCollectionEnd(errors, cst) {
          let char, name;
          switch (cst.type) {
            case PlainValue.Type.FLOW_MAP:
              char = "}";
              name = "flow map";
              break;
            case PlainValue.Type.FLOW_SEQ:
              char = "]";
              name = "flow sequence";
              break;
            default:
              errors.push(new PlainValue.YAMLSemanticError(cst, "Not a flow collection!?"));
              return;
          }
          let lastItem;
          for (let i = cst.items.length - 1; i >= 0; --i) {
            const item = cst.items[i];
            if (!item || item.type !== PlainValue.Type.COMMENT) {
              lastItem = item;
              break;
            }
          }
          if (lastItem && lastItem.char !== char) {
            const msg = `Expected ${name} to end with ${char}`;
            let err;
            if (typeof lastItem.offset === "number") {
              err = new PlainValue.YAMLSemanticError(cst, msg);
              err.offset = lastItem.offset + 1;
            } else {
              err = new PlainValue.YAMLSemanticError(lastItem, msg);
              if (lastItem.range && lastItem.range.end)
                err.offset = lastItem.range.end - lastItem.range.start;
            }
            errors.push(err);
          }
        }
        function checkFlowCommentSpace(errors, comment) {
          const prev = comment.context.src[comment.range.start - 1];
          if (prev !== "\n" && prev !== "	" && prev !== " ") {
            const msg = "Comments must be separated from other tokens by white space characters";
            errors.push(new PlainValue.YAMLSemanticError(comment, msg));
          }
        }
        function getLongKeyError(source, key) {
          const sk = String(key);
          const k = sk.substr(0, 8) + "..." + sk.substr(-8);
          return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
        }
        function resolveComments(collection, comments) {
          for (const {
            afterKey,
            before,
            comment
          } of comments) {
            let item = collection.items[before];
            if (!item) {
              if (comment !== void 0) {
                if (collection.comment)
                  collection.comment += "\n" + comment;
                else
                  collection.comment = comment;
              }
            } else {
              if (afterKey && item.value)
                item = item.value;
              if (comment === void 0) {
                if (afterKey || !item.commentBefore)
                  item.spaceBefore = true;
              } else {
                if (item.commentBefore)
                  item.commentBefore += "\n" + comment;
                else
                  item.commentBefore = comment;
              }
            }
          }
        }
        function resolveString(doc, node) {
          const res = node.strValue;
          if (!res)
            return "";
          if (typeof res === "string")
            return res;
          res.errors.forEach((error) => {
            if (!error.source)
              error.source = node;
            doc.errors.push(error);
          });
          return res.str;
        }
        function resolveTagHandle(doc, node) {
          const {
            handle,
            suffix
          } = node.tag;
          let prefix = doc.tagPrefixes.find((p) => p.handle === handle);
          if (!prefix) {
            const dtp = doc.getDefaults().tagPrefixes;
            if (dtp)
              prefix = dtp.find((p) => p.handle === handle);
            if (!prefix)
              throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
          }
          if (!suffix)
            throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);
          if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
            if (suffix[0] === "^") {
              doc.warnings.push(new PlainValue.YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
              return suffix;
            }
            if (/[:/]/.test(suffix)) {
              const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
              return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
            }
          }
          return prefix.prefix + decodeURIComponent(suffix);
        }
        function resolveTagName(doc, node) {
          const {
            tag,
            type
          } = node;
          let nonSpecific = false;
          if (tag) {
            const {
              handle,
              suffix,
              verbatim
            } = tag;
            if (verbatim) {
              if (verbatim !== "!" && verbatim !== "!!")
                return verbatim;
              const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
              doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
            } else if (handle === "!" && !suffix) {
              nonSpecific = true;
            } else {
              try {
                return resolveTagHandle(doc, node);
              } catch (error) {
                doc.errors.push(error);
              }
            }
          }
          switch (type) {
            case PlainValue.Type.BLOCK_FOLDED:
            case PlainValue.Type.BLOCK_LITERAL:
            case PlainValue.Type.QUOTE_DOUBLE:
            case PlainValue.Type.QUOTE_SINGLE:
              return PlainValue.defaultTags.STR;
            case PlainValue.Type.FLOW_MAP:
            case PlainValue.Type.MAP:
              return PlainValue.defaultTags.MAP;
            case PlainValue.Type.FLOW_SEQ:
            case PlainValue.Type.SEQ:
              return PlainValue.defaultTags.SEQ;
            case PlainValue.Type.PLAIN:
              return nonSpecific ? PlainValue.defaultTags.STR : null;
            default:
              return null;
          }
        }
        function resolveByTagName(doc, node, tagName) {
          const {
            tags
          } = doc.schema;
          const matchWithTest = [];
          for (const tag of tags) {
            if (tag.tag === tagName) {
              if (tag.test)
                matchWithTest.push(tag);
              else {
                const res = tag.resolve(doc, node);
                return res instanceof Collection ? res : new Scalar(res);
              }
            }
          }
          const str = resolveString(doc, node);
          if (typeof str === "string" && matchWithTest.length > 0)
            return resolveScalar(str, matchWithTest, tags.scalarFallback);
          return null;
        }
        function getFallbackTagName({
          type
        }) {
          switch (type) {
            case PlainValue.Type.FLOW_MAP:
            case PlainValue.Type.MAP:
              return PlainValue.defaultTags.MAP;
            case PlainValue.Type.FLOW_SEQ:
            case PlainValue.Type.SEQ:
              return PlainValue.defaultTags.SEQ;
            default:
              return PlainValue.defaultTags.STR;
          }
        }
        function resolveTag(doc, node, tagName) {
          try {
            const res = resolveByTagName(doc, node, tagName);
            if (res) {
              if (tagName && node.tag)
                res.tag = tagName;
              return res;
            }
          } catch (error) {
            if (!error.source)
              error.source = node;
            doc.errors.push(error);
            return null;
          }
          try {
            const fallback = getFallbackTagName(node);
            if (!fallback)
              throw new Error(`The tag ${tagName} is unavailable`);
            const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
            doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
            const res = resolveByTagName(doc, node, fallback);
            res.tag = tagName;
            return res;
          } catch (error) {
            const refError = new PlainValue.YAMLReferenceError(node, error.message);
            refError.stack = error.stack;
            doc.errors.push(refError);
            return null;
          }
        }
        var isCollectionItem = (node) => {
          if (!node)
            return false;
          const {
            type
          } = node;
          return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;
        };
        function resolveNodeProps(errors, node) {
          const comments = {
            before: [],
            after: []
          };
          let hasAnchor = false;
          let hasTag = false;
          const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
          for (const {
            start,
            end
          } of props) {
            switch (node.context.src[start]) {
              case PlainValue.Char.COMMENT: {
                if (!node.commentHasRequiredWhitespace(start)) {
                  const msg = "Comments must be separated from other tokens by white space characters";
                  errors.push(new PlainValue.YAMLSemanticError(node, msg));
                }
                const {
                  header,
                  valueRange
                } = node;
                const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
                cc.push(node.context.src.slice(start + 1, end));
                break;
              }
              case PlainValue.Char.ANCHOR:
                if (hasAnchor) {
                  const msg = "A node can have at most one anchor";
                  errors.push(new PlainValue.YAMLSemanticError(node, msg));
                }
                hasAnchor = true;
                break;
              case PlainValue.Char.TAG:
                if (hasTag) {
                  const msg = "A node can have at most one tag";
                  errors.push(new PlainValue.YAMLSemanticError(node, msg));
                }
                hasTag = true;
                break;
            }
          }
          return {
            comments,
            hasAnchor,
            hasTag
          };
        }
        function resolveNodeValue(doc, node) {
          const {
            anchors,
            errors,
            schema
          } = doc;
          if (node.type === PlainValue.Type.ALIAS) {
            const name = node.rawValue;
            const src = anchors.getNode(name);
            if (!src) {
              const msg = `Aliased anchor not found: ${name}`;
              errors.push(new PlainValue.YAMLReferenceError(node, msg));
              return null;
            }
            const res = new Alias(src);
            anchors._cstAliases.push(res);
            return res;
          }
          const tagName = resolveTagName(doc, node);
          if (tagName)
            return resolveTag(doc, node, tagName);
          if (node.type !== PlainValue.Type.PLAIN) {
            const msg = `Failed to resolve ${node.type} node here`;
            errors.push(new PlainValue.YAMLSyntaxError(node, msg));
            return null;
          }
          try {
            const str = resolveString(doc, node);
            return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
          } catch (error) {
            if (!error.source)
              error.source = node;
            errors.push(error);
            return null;
          }
        }
        function resolveNode(doc, node) {
          if (!node)
            return null;
          if (node.error)
            doc.errors.push(node.error);
          const {
            comments,
            hasAnchor,
            hasTag
          } = resolveNodeProps(doc.errors, node);
          if (hasAnchor) {
            const {
              anchors
            } = doc;
            const name = node.anchor;
            const prev = anchors.getNode(name);
            if (prev)
              anchors.map[anchors.newName(name)] = prev;
            anchors.map[name] = node;
          }
          if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
            const msg = "An alias node must not specify any properties";
            doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
          }
          const res = resolveNodeValue(doc, node);
          if (res) {
            res.range = [node.range.start, node.range.end];
            if (doc.options.keepCstNodes)
              res.cstNode = node;
            if (doc.options.keepNodeTypes)
              res.type = node.type;
            const cb = comments.before.join("\n");
            if (cb) {
              res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
            }
            const ca = comments.after.join("\n");
            if (ca)
              res.comment = res.comment ? `${res.comment}
${ca}` : ca;
          }
          return node.resolved = res;
        }
        function resolveMap(doc, cst) {
          if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
            const msg = `A ${cst.type} node cannot be resolved as a mapping`;
            doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
            return null;
          }
          const {
            comments,
            items
          } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
          const map = new YAMLMap();
          map.items = items;
          resolveComments(map, comments);
          let hasCollectionKey = false;
          for (let i = 0; i < items.length; ++i) {
            const {
              key: iKey
            } = items[i];
            if (iKey instanceof Collection)
              hasCollectionKey = true;
            if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
              items[i] = new Merge(items[i]);
              const sources = items[i].value.items;
              let error = null;
              sources.some((node) => {
                if (node instanceof Alias) {
                  const {
                    type
                  } = node.source;
                  if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP)
                    return false;
                  return error = "Merge nodes aliases can only point to maps";
                }
                return error = "Merge nodes can only have Alias nodes as values";
              });
              if (error)
                doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
            } else {
              for (let j = i + 1; j < items.length; ++j) {
                const {
                  key: jKey
                } = items[j];
                if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
                  const msg = `Map keys must be unique; "${iKey}" is repeated`;
                  doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
                  break;
                }
              }
            }
          }
          if (hasCollectionKey && !doc.options.mapAsMap) {
            const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
            doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
          }
          cst.resolved = map;
          return map;
        }
        var valueHasPairComment = ({
          context: {
            lineStart,
            node,
            src
          },
          props
        }) => {
          if (props.length === 0)
            return false;
          const {
            start
          } = props[0];
          if (node && start > node.valueRange.start)
            return false;
          if (src[start] !== PlainValue.Char.COMMENT)
            return false;
          for (let i = lineStart; i < start; ++i)
            if (src[i] === "\n")
              return false;
          return true;
        };
        function resolvePairComment(item, pair) {
          if (!valueHasPairComment(item))
            return;
          const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
          let found = false;
          const cb = pair.value.commentBefore;
          if (cb && cb.startsWith(comment)) {
            pair.value.commentBefore = cb.substr(comment.length + 1);
            found = true;
          } else {
            const cc = pair.value.comment;
            if (!item.node && cc && cc.startsWith(comment)) {
              pair.value.comment = cc.substr(comment.length + 1);
              found = true;
            }
          }
          if (found)
            pair.comment = comment;
        }
        function resolveBlockMapItems(doc, cst) {
          const comments = [];
          const items = [];
          let key = void 0;
          let keyStart = null;
          for (let i = 0; i < cst.items.length; ++i) {
            const item = cst.items[i];
            switch (item.type) {
              case PlainValue.Type.BLANK_LINE:
                comments.push({
                  afterKey: !!key,
                  before: items.length
                });
                break;
              case PlainValue.Type.COMMENT:
                comments.push({
                  afterKey: !!key,
                  before: items.length,
                  comment: item.comment
                });
                break;
              case PlainValue.Type.MAP_KEY:
                if (key !== void 0)
                  items.push(new Pair(key));
                if (item.error)
                  doc.errors.push(item.error);
                key = resolveNode(doc, item.node);
                keyStart = null;
                break;
              case PlainValue.Type.MAP_VALUE:
                {
                  if (key === void 0)
                    key = null;
                  if (item.error)
                    doc.errors.push(item.error);
                  if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
                    const msg = "Nested mappings are not allowed in compact mappings";
                    doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
                  }
                  let valueNode = item.node;
                  if (!valueNode && item.props.length > 0) {
                    valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                    valueNode.context = {
                      parent: item,
                      src: item.context.src
                    };
                    const pos = item.range.start + 1;
                    valueNode.range = {
                      start: pos,
                      end: pos
                    };
                    valueNode.valueRange = {
                      start: pos,
                      end: pos
                    };
                    if (typeof item.range.origStart === "number") {
                      const origPos = item.range.origStart + 1;
                      valueNode.range.origStart = valueNode.range.origEnd = origPos;
                      valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                    }
                  }
                  const pair = new Pair(key, resolveNode(doc, valueNode));
                  resolvePairComment(item, pair);
                  items.push(pair);
                  if (key && typeof keyStart === "number") {
                    if (item.range.start > keyStart + 1024)
                      doc.errors.push(getLongKeyError(cst, key));
                  }
                  key = void 0;
                  keyStart = null;
                }
                break;
              default:
                if (key !== void 0)
                  items.push(new Pair(key));
                key = resolveNode(doc, item);
                keyStart = item.range.start;
                if (item.error)
                  doc.errors.push(item.error);
                next:
                  for (let j = i + 1; ; ++j) {
                    const nextItem = cst.items[j];
                    switch (nextItem && nextItem.type) {
                      case PlainValue.Type.BLANK_LINE:
                      case PlainValue.Type.COMMENT:
                        continue next;
                      case PlainValue.Type.MAP_VALUE:
                        break next;
                      default: {
                        const msg = "Implicit map keys need to be followed by map values";
                        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                        break next;
                      }
                    }
                  }
                if (item.valueRangeContainsNewline) {
                  const msg = "Implicit map keys need to be on a single line";
                  doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                }
            }
          }
          if (key !== void 0)
            items.push(new Pair(key));
          return {
            comments,
            items
          };
        }
        function resolveFlowMapItems(doc, cst) {
          const comments = [];
          const items = [];
          let key = void 0;
          let explicitKey = false;
          let next = "{";
          for (let i = 0; i < cst.items.length; ++i) {
            const item = cst.items[i];
            if (typeof item.char === "string") {
              const {
                char,
                offset
              } = item;
              if (char === "?" && key === void 0 && !explicitKey) {
                explicitKey = true;
                next = ":";
                continue;
              }
              if (char === ":") {
                if (key === void 0)
                  key = null;
                if (next === ":") {
                  next = ",";
                  continue;
                }
              } else {
                if (explicitKey) {
                  if (key === void 0 && char !== ",")
                    key = null;
                  explicitKey = false;
                }
                if (key !== void 0) {
                  items.push(new Pair(key));
                  key = void 0;
                  if (char === ",") {
                    next = ":";
                    continue;
                  }
                }
              }
              if (char === "}") {
                if (i === cst.items.length - 1)
                  continue;
              } else if (char === next) {
                next = ":";
                continue;
              }
              const msg = `Flow map contains an unexpected ${char}`;
              const err = new PlainValue.YAMLSyntaxError(cst, msg);
              err.offset = offset;
              doc.errors.push(err);
            } else if (item.type === PlainValue.Type.BLANK_LINE) {
              comments.push({
                afterKey: !!key,
                before: items.length
              });
            } else if (item.type === PlainValue.Type.COMMENT) {
              checkFlowCommentSpace(doc.errors, item);
              comments.push({
                afterKey: !!key,
                before: items.length,
                comment: item.comment
              });
            } else if (key === void 0) {
              if (next === ",")
                doc.errors.push(new PlainValue.YAMLSemanticError(item, "Separator , missing in flow map"));
              key = resolveNode(doc, item);
            } else {
              if (next !== ",")
                doc.errors.push(new PlainValue.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
              items.push(new Pair(key, resolveNode(doc, item)));
              key = void 0;
              explicitKey = false;
            }
          }
          checkFlowCollectionEnd(doc.errors, cst);
          if (key !== void 0)
            items.push(new Pair(key));
          return {
            comments,
            items
          };
        }
        function resolveSeq(doc, cst) {
          if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
            const msg = `A ${cst.type} node cannot be resolved as a sequence`;
            doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
            return null;
          }
          const {
            comments,
            items
          } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
          const seq = new YAMLSeq();
          seq.items = items;
          resolveComments(seq, comments);
          if (!doc.options.mapAsMap && items.some((it) => it instanceof Pair && it.key instanceof Collection)) {
            const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
            doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
          }
          cst.resolved = seq;
          return seq;
        }
        function resolveBlockSeqItems(doc, cst) {
          const comments = [];
          const items = [];
          for (let i = 0; i < cst.items.length; ++i) {
            const item = cst.items[i];
            switch (item.type) {
              case PlainValue.Type.BLANK_LINE:
                comments.push({
                  before: items.length
                });
                break;
              case PlainValue.Type.COMMENT:
                comments.push({
                  comment: item.comment,
                  before: items.length
                });
                break;
              case PlainValue.Type.SEQ_ITEM:
                if (item.error)
                  doc.errors.push(item.error);
                items.push(resolveNode(doc, item.node));
                if (item.hasProps) {
                  const msg = "Sequence items cannot have tags or anchors before the - indicator";
                  doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                }
                break;
              default:
                if (item.error)
                  doc.errors.push(item.error);
                doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
            }
          }
          return {
            comments,
            items
          };
        }
        function resolveFlowSeqItems(doc, cst) {
          const comments = [];
          const items = [];
          let explicitKey = false;
          let key = void 0;
          let keyStart = null;
          let next = "[";
          let prevItem = null;
          for (let i = 0; i < cst.items.length; ++i) {
            const item = cst.items[i];
            if (typeof item.char === "string") {
              const {
                char,
                offset
              } = item;
              if (char !== ":" && (explicitKey || key !== void 0)) {
                if (explicitKey && key === void 0)
                  key = next ? items.pop() : null;
                items.push(new Pair(key));
                explicitKey = false;
                key = void 0;
                keyStart = null;
              }
              if (char === next) {
                next = null;
              } else if (!next && char === "?") {
                explicitKey = true;
              } else if (next !== "[" && char === ":" && key === void 0) {
                if (next === ",") {
                  key = items.pop();
                  if (key instanceof Pair) {
                    const msg = "Chaining flow sequence pairs is invalid";
                    const err = new PlainValue.YAMLSemanticError(cst, msg);
                    err.offset = offset;
                    doc.errors.push(err);
                  }
                  if (!explicitKey && typeof keyStart === "number") {
                    const keyEnd = item.range ? item.range.start : item.offset;
                    if (keyEnd > keyStart + 1024)
                      doc.errors.push(getLongKeyError(cst, key));
                    const {
                      src
                    } = prevItem.context;
                    for (let i2 = keyStart; i2 < keyEnd; ++i2)
                      if (src[i2] === "\n") {
                        const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                        doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                        break;
                      }
                  }
                } else {
                  key = null;
                }
                keyStart = null;
                explicitKey = false;
                next = null;
              } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
                const msg = `Flow sequence contains an unexpected ${char}`;
                const err = new PlainValue.YAMLSyntaxError(cst, msg);
                err.offset = offset;
                doc.errors.push(err);
              }
            } else if (item.type === PlainValue.Type.BLANK_LINE) {
              comments.push({
                before: items.length
              });
            } else if (item.type === PlainValue.Type.COMMENT) {
              checkFlowCommentSpace(doc.errors, item);
              comments.push({
                comment: item.comment,
                before: items.length
              });
            } else {
              if (next) {
                const msg = `Expected a ${next} in flow sequence`;
                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
              }
              const value = resolveNode(doc, item);
              if (key === void 0) {
                items.push(value);
                prevItem = item;
              } else {
                items.push(new Pair(key, value));
                key = void 0;
              }
              keyStart = item.range.start;
              next = ",";
            }
          }
          checkFlowCollectionEnd(doc.errors, cst);
          if (key !== void 0)
            items.push(new Pair(key));
          return {
            comments,
            items
          };
        }
        exports2.Alias = Alias;
        exports2.Collection = Collection;
        exports2.Merge = Merge;
        exports2.Node = Node;
        exports2.Pair = Pair;
        exports2.Scalar = Scalar;
        exports2.YAMLMap = YAMLMap;
        exports2.YAMLSeq = YAMLSeq;
        exports2.addComment = addComment;
        exports2.binaryOptions = binaryOptions;
        exports2.boolOptions = boolOptions;
        exports2.findPair = findPair;
        exports2.intOptions = intOptions;
        exports2.isEmptyPath = isEmptyPath;
        exports2.nullOptions = nullOptions;
        exports2.resolveMap = resolveMap;
        exports2.resolveNode = resolveNode;
        exports2.resolveSeq = resolveSeq;
        exports2.resolveString = resolveString;
        exports2.strOptions = strOptions;
        exports2.stringifyNumber = stringifyNumber;
        exports2.stringifyString = stringifyString;
        exports2.toJSON = toJSON;
      }
    });
    var require_warnings_1000a372 = __commonJS2({
      "node_modules/yaml/dist/warnings-1000a372.js"(exports2) {
        "use strict";
        var PlainValue = require_PlainValue_ec8e588e();
        var resolveSeq = require_resolveSeq_d03cb037();
        var binary = {
          identify: (value) => value instanceof Uint8Array,
          default: false,
          tag: "tag:yaml.org,2002:binary",
          resolve: (doc, node) => {
            const src = resolveSeq.resolveString(doc, node);
            if (typeof Buffer === "function") {
              return Buffer.from(src, "base64");
            } else if (typeof atob === "function") {
              const str = atob(src.replace(/[\n\r]/g, ""));
              const buffer = new Uint8Array(str.length);
              for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
              return buffer;
            } else {
              const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
              doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
              return null;
            }
          },
          options: resolveSeq.binaryOptions,
          stringify: ({
            comment,
            type,
            value
          }, ctx, onComment, onChompKeep) => {
            let src;
            if (typeof Buffer === "function") {
              src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
            } else if (typeof btoa === "function") {
              let s = "";
              for (let i = 0; i < value.length; ++i)
                s += String.fromCharCode(value[i]);
              src = btoa(s);
            } else {
              throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
            }
            if (!type)
              type = resolveSeq.binaryOptions.defaultType;
            if (type === PlainValue.Type.QUOTE_DOUBLE) {
              value = src;
            } else {
              const {
                lineWidth
              } = resolveSeq.binaryOptions;
              const n = Math.ceil(src.length / lineWidth);
              const lines = new Array(n);
              for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = src.substr(o, lineWidth);
              }
              value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? "\n" : " ");
            }
            return resolveSeq.stringifyString({
              comment,
              type,
              value
            }, ctx, onComment, onChompKeep);
          }
        };
        function parsePairs(doc, cst) {
          const seq = resolveSeq.resolveSeq(doc, cst);
          for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (item instanceof resolveSeq.Pair)
              continue;
            else if (item instanceof resolveSeq.YAMLMap) {
              if (item.items.length > 1) {
                const msg = "Each pair must have its own sequence indicator";
                throw new PlainValue.YAMLSemanticError(cst, msg);
              }
              const pair = item.items[0] || new resolveSeq.Pair();
              if (item.commentBefore)
                pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
              if (item.comment)
                pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
              item = pair;
            }
            seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
          }
          return seq;
        }
        function createPairs(schema, iterable, ctx) {
          const pairs2 = new resolveSeq.YAMLSeq(schema);
          pairs2.tag = "tag:yaml.org,2002:pairs";
          for (const it of iterable) {
            let key, value;
            if (Array.isArray(it)) {
              if (it.length === 2) {
                key = it[0];
                value = it[1];
              } else
                throw new TypeError(`Expected [key, value] tuple: ${it}`);
            } else if (it && it instanceof Object) {
              const keys = Object.keys(it);
              if (keys.length === 1) {
                key = keys[0];
                value = it[key];
              } else
                throw new TypeError(`Expected { key: value } tuple: ${it}`);
            } else {
              key = it;
            }
            const pair = schema.createPair(key, value, ctx);
            pairs2.items.push(pair);
          }
          return pairs2;
        }
        var pairs = {
          default: false,
          tag: "tag:yaml.org,2002:pairs",
          resolve: parsePairs,
          createNode: createPairs
        };
        var YAMLOMap = class extends resolveSeq.YAMLSeq {
          constructor() {
            super();
            PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));
            PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));
            PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));
            PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));
            PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));
            this.tag = YAMLOMap.tag;
          }
          toJSON(_, ctx) {
            const map = new Map();
            if (ctx && ctx.onCreate)
              ctx.onCreate(map);
            for (const pair of this.items) {
              let key, value;
              if (pair instanceof resolveSeq.Pair) {
                key = resolveSeq.toJSON(pair.key, "", ctx);
                value = resolveSeq.toJSON(pair.value, key, ctx);
              } else {
                key = resolveSeq.toJSON(pair, "", ctx);
              }
              if (map.has(key))
                throw new Error("Ordered maps must not include duplicate keys");
              map.set(key, value);
            }
            return map;
          }
        };
        PlainValue._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
        function parseOMap(doc, cst) {
          const pairs2 = parsePairs(doc, cst);
          const seenKeys = [];
          for (const {
            key
          } of pairs2.items) {
            if (key instanceof resolveSeq.Scalar) {
              if (seenKeys.includes(key.value)) {
                const msg = "Ordered maps must not include duplicate keys";
                throw new PlainValue.YAMLSemanticError(cst, msg);
              } else {
                seenKeys.push(key.value);
              }
            }
          }
          return Object.assign(new YAMLOMap(), pairs2);
        }
        function createOMap(schema, iterable, ctx) {
          const pairs2 = createPairs(schema, iterable, ctx);
          const omap2 = new YAMLOMap();
          omap2.items = pairs2.items;
          return omap2;
        }
        var omap = {
          identify: (value) => value instanceof Map,
          nodeClass: YAMLOMap,
          default: false,
          tag: "tag:yaml.org,2002:omap",
          resolve: parseOMap,
          createNode: createOMap
        };
        var YAMLSet = class extends resolveSeq.YAMLMap {
          constructor() {
            super();
            this.tag = YAMLSet.tag;
          }
          add(key) {
            const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
            const prev = resolveSeq.findPair(this.items, pair.key);
            if (!prev)
              this.items.push(pair);
          }
          get(key, keepPair) {
            const pair = resolveSeq.findPair(this.items, key);
            return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
          }
          set(key, value) {
            if (typeof value !== "boolean")
              throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
            const prev = resolveSeq.findPair(this.items, key);
            if (prev && !value) {
              this.items.splice(this.items.indexOf(prev), 1);
            } else if (!prev && value) {
              this.items.push(new resolveSeq.Pair(key));
            }
          }
          toJSON(_, ctx) {
            return super.toJSON(_, ctx, Set);
          }
          toString(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            if (this.hasAllNullValues())
              return super.toString(ctx, onComment, onChompKeep);
            else
              throw new Error("Set items must all have null values");
          }
        };
        PlainValue._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
        function parseSet(doc, cst) {
          const map = resolveSeq.resolveMap(doc, cst);
          if (!map.hasAllNullValues())
            throw new PlainValue.YAMLSemanticError(cst, "Set items must all have null values");
          return Object.assign(new YAMLSet(), map);
        }
        function createSet(schema, iterable, ctx) {
          const set2 = new YAMLSet();
          for (const value of iterable)
            set2.items.push(schema.createPair(value, null, ctx));
          return set2;
        }
        var set = {
          identify: (value) => value instanceof Set,
          nodeClass: YAMLSet,
          default: false,
          tag: "tag:yaml.org,2002:set",
          resolve: parseSet,
          createNode: createSet
        };
        var parseSexagesimal = (sign, parts) => {
          const n = parts.split(":").reduce((n2, p) => n2 * 60 + Number(p), 0);
          return sign === "-" ? -n : n;
        };
        var stringifySexagesimal = ({
          value
        }) => {
          if (isNaN(value) || !isFinite(value))
            return resolveSeq.stringifyNumber(value);
          let sign = "";
          if (value < 0) {
            sign = "-";
            value = Math.abs(value);
          }
          const parts = [value % 60];
          if (value < 60) {
            parts.unshift(0);
          } else {
            value = Math.round((value - parts[0]) / 60);
            parts.unshift(value % 60);
            if (value >= 60) {
              value = Math.round((value - parts[0]) / 60);
              parts.unshift(value);
            }
          }
          return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
        };
        var intTime = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "TIME",
          test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
          resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
          stringify: stringifySexagesimal
        };
        var floatTime = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          format: "TIME",
          test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
          resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
          stringify: stringifySexagesimal
        };
        var timestamp = {
          identify: (value) => value instanceof Date,
          default: true,
          tag: "tag:yaml.org,2002:timestamp",
          test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
          resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
            if (millisec)
              millisec = (millisec + "00").substr(1, 3);
            let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
            if (tz && tz !== "Z") {
              let d = parseSexagesimal(tz[0], tz.slice(1));
              if (Math.abs(d) < 30)
                d *= 60;
              date -= 6e4 * d;
            }
            return new Date(date);
          },
          stringify: ({
            value
          }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
        };
        function shouldWarn(deprecation) {
          const env = typeof process !== "undefined" && process.env || {};
          if (deprecation) {
            if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
              return !YAML_SILENCE_DEPRECATION_WARNINGS;
            return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
          }
          if (typeof YAML_SILENCE_WARNINGS !== "undefined")
            return !YAML_SILENCE_WARNINGS;
          return !env.YAML_SILENCE_WARNINGS;
        }
        function warn(warning, type) {
          if (shouldWarn(false)) {
            const emit = typeof process !== "undefined" && process.emitWarning;
            if (emit)
              emit(warning, type);
            else {
              console.warn(type ? `${type}: ${warning}` : warning);
            }
          }
        }
        function warnFileDeprecation(filename) {
          if (shouldWarn(true)) {
            const path = filename.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
            warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, "DeprecationWarning");
          }
        }
        var warned = {};
        function warnOptionDeprecation(name, alternative) {
          if (!warned[name] && shouldWarn(true)) {
            warned[name] = true;
            let msg = `The option '${name}' will be removed in a future release`;
            msg += alternative ? `, use '${alternative}' instead.` : ".";
            warn(msg, "DeprecationWarning");
          }
        }
        exports2.binary = binary;
        exports2.floatTime = floatTime;
        exports2.intTime = intTime;
        exports2.omap = omap;
        exports2.pairs = pairs;
        exports2.set = set;
        exports2.timestamp = timestamp;
        exports2.warn = warn;
        exports2.warnFileDeprecation = warnFileDeprecation;
        exports2.warnOptionDeprecation = warnOptionDeprecation;
      }
    });
    var require_Schema_88e323a7 = __commonJS2({
      "node_modules/yaml/dist/Schema-88e323a7.js"(exports2) {
        "use strict";
        var PlainValue = require_PlainValue_ec8e588e();
        var resolveSeq = require_resolveSeq_d03cb037();
        var warnings = require_warnings_1000a372();
        function createMap(schema, obj, ctx) {
          const map2 = new resolveSeq.YAMLMap(schema);
          if (obj instanceof Map) {
            for (const [key, value] of obj)
              map2.items.push(schema.createPair(key, value, ctx));
          } else if (obj && typeof obj === "object") {
            for (const key of Object.keys(obj))
              map2.items.push(schema.createPair(key, obj[key], ctx));
          }
          if (typeof schema.sortMapEntries === "function") {
            map2.items.sort(schema.sortMapEntries);
          }
          return map2;
        }
        var map = {
          createNode: createMap,
          default: true,
          nodeClass: resolveSeq.YAMLMap,
          tag: "tag:yaml.org,2002:map",
          resolve: resolveSeq.resolveMap
        };
        function createSeq(schema, obj, ctx) {
          const seq2 = new resolveSeq.YAMLSeq(schema);
          if (obj && obj[Symbol.iterator]) {
            for (const it of obj) {
              const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
              seq2.items.push(v);
            }
          }
          return seq2;
        }
        var seq = {
          createNode: createSeq,
          default: true,
          nodeClass: resolveSeq.YAMLSeq,
          tag: "tag:yaml.org,2002:seq",
          resolve: resolveSeq.resolveSeq
        };
        var string = {
          identify: (value) => typeof value === "string",
          default: true,
          tag: "tag:yaml.org,2002:str",
          resolve: resolveSeq.resolveString,
          stringify(item, ctx, onComment, onChompKeep) {
            ctx = Object.assign({
              actualString: true
            }, ctx);
            return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
          },
          options: resolveSeq.strOptions
        };
        var failsafe = [map, seq, string];
        var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
        var intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
        function intStringify$1(node, radix, prefix) {
          const {
            value
          } = node;
          if (intIdentify$2(value) && value >= 0)
            return prefix + value.toString(radix);
          return resolveSeq.stringifyNumber(node);
        }
        var nullObj = {
          identify: (value) => value == null,
          createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
          default: true,
          tag: "tag:yaml.org,2002:null",
          test: /^(?:~|[Nn]ull|NULL)?$/,
          resolve: () => null,
          options: resolveSeq.nullOptions,
          stringify: () => resolveSeq.nullOptions.nullStr
        };
        var boolObj = {
          identify: (value) => typeof value === "boolean",
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
          resolve: (str) => str[0] === "t" || str[0] === "T",
          options: resolveSeq.boolOptions,
          stringify: ({
            value
          }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
        };
        var octObj = {
          identify: (value) => intIdentify$2(value) && value >= 0,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "OCT",
          test: /^0o([0-7]+)$/,
          resolve: (str, oct) => intResolve$1(str, oct, 8),
          options: resolveSeq.intOptions,
          stringify: (node) => intStringify$1(node, 8, "0o")
        };
        var intObj = {
          identify: intIdentify$2,
          default: true,
          tag: "tag:yaml.org,2002:int",
          test: /^[-+]?[0-9]+$/,
          resolve: (str) => intResolve$1(str, str, 10),
          options: resolveSeq.intOptions,
          stringify: resolveSeq.stringifyNumber
        };
        var hexObj = {
          identify: (value) => intIdentify$2(value) && value >= 0,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "HEX",
          test: /^0x([0-9a-fA-F]+)$/,
          resolve: (str, hex) => intResolve$1(str, hex, 16),
          options: resolveSeq.intOptions,
          stringify: (node) => intStringify$1(node, 16, "0x")
        };
        var nanObj = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^(?:[-+]?\.inf|(\.nan))$/i,
          resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
          stringify: resolveSeq.stringifyNumber
        };
        var expObj = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          format: "EXP",
          test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
          resolve: (str) => parseFloat(str),
          stringify: ({
            value
          }) => Number(value).toExponential()
        };
        var floatObj = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
          resolve(str, frac1, frac2) {
            const frac = frac1 || frac2;
            const node = new resolveSeq.Scalar(parseFloat(str));
            if (frac && frac[frac.length - 1] === "0")
              node.minFractionDigits = frac.length;
            return node;
          },
          stringify: resolveSeq.stringifyNumber
        };
        var core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
        var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
        var stringifyJSON = ({
          value
        }) => JSON.stringify(value);
        var json = [map, seq, {
          identify: (value) => typeof value === "string",
          default: true,
          tag: "tag:yaml.org,2002:str",
          resolve: resolveSeq.resolveString,
          stringify: stringifyJSON
        }, {
          identify: (value) => value == null,
          createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
          default: true,
          tag: "tag:yaml.org,2002:null",
          test: /^null$/,
          resolve: () => null,
          stringify: stringifyJSON
        }, {
          identify: (value) => typeof value === "boolean",
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^true|false$/,
          resolve: (str) => str === "true",
          stringify: stringifyJSON
        }, {
          identify: intIdentify$1,
          default: true,
          tag: "tag:yaml.org,2002:int",
          test: /^-?(?:0|[1-9][0-9]*)$/,
          resolve: (str) => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
          stringify: ({
            value
          }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
        }, {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
          resolve: (str) => parseFloat(str),
          stringify: stringifyJSON
        }];
        json.scalarFallback = (str) => {
          throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        };
        var boolStringify = ({
          value
        }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;
        var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
        function intResolve(sign, src, radix) {
          let str = src.replace(/_/g, "");
          if (resolveSeq.intOptions.asBigInt) {
            switch (radix) {
              case 2:
                str = `0b${str}`;
                break;
              case 8:
                str = `0o${str}`;
                break;
              case 16:
                str = `0x${str}`;
                break;
            }
            const n2 = BigInt(str);
            return sign === "-" ? BigInt(-1) * n2 : n2;
          }
          const n = parseInt(str, radix);
          return sign === "-" ? -1 * n : n;
        }
        function intStringify(node, radix, prefix) {
          const {
            value
          } = node;
          if (intIdentify(value)) {
            const str = value.toString(radix);
            return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
          }
          return resolveSeq.stringifyNumber(node);
        }
        var yaml11 = failsafe.concat([{
          identify: (value) => value == null,
          createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
          default: true,
          tag: "tag:yaml.org,2002:null",
          test: /^(?:~|[Nn]ull|NULL)?$/,
          resolve: () => null,
          options: resolveSeq.nullOptions,
          stringify: () => resolveSeq.nullOptions.nullStr
        }, {
          identify: (value) => typeof value === "boolean",
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
          resolve: () => true,
          options: resolveSeq.boolOptions,
          stringify: boolStringify
        }, {
          identify: (value) => typeof value === "boolean",
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
          resolve: () => false,
          options: resolveSeq.boolOptions,
          stringify: boolStringify
        }, {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "BIN",
          test: /^([-+]?)0b([0-1_]+)$/,
          resolve: (str, sign, bin) => intResolve(sign, bin, 2),
          stringify: (node) => intStringify(node, 2, "0b")
        }, {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "OCT",
          test: /^([-+]?)0([0-7_]+)$/,
          resolve: (str, sign, oct) => intResolve(sign, oct, 8),
          stringify: (node) => intStringify(node, 8, "0")
        }, {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          test: /^([-+]?)([0-9][0-9_]*)$/,
          resolve: (str, sign, abs) => intResolve(sign, abs, 10),
          stringify: resolveSeq.stringifyNumber
        }, {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "HEX",
          test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
          resolve: (str, sign, hex) => intResolve(sign, hex, 16),
          stringify: (node) => intStringify(node, 16, "0x")
        }, {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^(?:[-+]?\.inf|(\.nan))$/i,
          resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
          stringify: resolveSeq.stringifyNumber
        }, {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          format: "EXP",
          test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
          resolve: (str) => parseFloat(str.replace(/_/g, "")),
          stringify: ({
            value
          }) => Number(value).toExponential()
        }, {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
          resolve(str, frac) {
            const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, "")));
            if (frac) {
              const f = frac.replace(/_/g, "");
              if (f[f.length - 1] === "0")
                node.minFractionDigits = f.length;
            }
            return node;
          },
          stringify: resolveSeq.stringifyNumber
        }], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);
        var schemas = {
          core,
          failsafe,
          json,
          yaml11
        };
        var tags = {
          binary: warnings.binary,
          bool: boolObj,
          float: floatObj,
          floatExp: expObj,
          floatNaN: nanObj,
          floatTime: warnings.floatTime,
          int: intObj,
          intHex: hexObj,
          intOct: octObj,
          intTime: warnings.intTime,
          map,
          null: nullObj,
          omap: warnings.omap,
          pairs: warnings.pairs,
          seq,
          set: warnings.set,
          timestamp: warnings.timestamp
        };
        function findTagObject(value, tagName, tags2) {
          if (tagName) {
            const match = tags2.filter((t) => t.tag === tagName);
            const tagObj = match.find((t) => !t.format) || match[0];
            if (!tagObj)
              throw new Error(`Tag ${tagName} not found`);
            return tagObj;
          }
          return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
        }
        function createNode(value, tagName, ctx) {
          if (value instanceof resolveSeq.Node)
            return value;
          const {
            defaultPrefix,
            onTagObj,
            prevObjects,
            schema,
            wrapScalars
          } = ctx;
          if (tagName && tagName.startsWith("!!"))
            tagName = defaultPrefix + tagName.slice(2);
          let tagObj = findTagObject(value, tagName, schema.tags);
          if (!tagObj) {
            if (typeof value.toJSON === "function")
              value = value.toJSON();
            if (!value || typeof value !== "object")
              return wrapScalars ? new resolveSeq.Scalar(value) : value;
            tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
          }
          if (onTagObj) {
            onTagObj(tagObj);
            delete ctx.onTagObj;
          }
          const obj = {
            value: void 0,
            node: void 0
          };
          if (value && typeof value === "object" && prevObjects) {
            const prev = prevObjects.get(value);
            if (prev) {
              const alias = new resolveSeq.Alias(prev);
              ctx.aliasNodes.push(alias);
              return alias;
            }
            obj.value = value;
            prevObjects.set(value, obj);
          }
          obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
          if (tagName && obj.node instanceof resolveSeq.Node)
            obj.node.tag = tagName;
          return obj.node;
        }
        function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
          let tags2 = schemas2[schemaId.replace(/\W/g, "")];
          if (!tags2) {
            const keys = Object.keys(schemas2).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
          }
          if (Array.isArray(customTags)) {
            for (const tag of customTags)
              tags2 = tags2.concat(tag);
          } else if (typeof customTags === "function") {
            tags2 = customTags(tags2.slice());
          }
          for (let i = 0; i < tags2.length; ++i) {
            const tag = tags2[i];
            if (typeof tag === "string") {
              const tagObj = knownTags[tag];
              if (!tagObj) {
                const keys = Object.keys(knownTags).map((key) => JSON.stringify(key)).join(", ");
                throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
              }
              tags2[i] = tagObj;
            }
          }
          return tags2;
        }
        var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
        var Schema = class {
          constructor({
            customTags,
            merge,
            schema,
            sortMapEntries,
            tags: deprecatedCustomTags
          }) {
            this.merge = !!merge;
            this.name = schema;
            this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
            if (!customTags && deprecatedCustomTags)
              warnings.warnOptionDeprecation("tags", "customTags");
            this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
          }
          createNode(value, wrapScalars, tagName, ctx) {
            const baseCtx = {
              defaultPrefix: Schema.defaultPrefix,
              schema: this,
              wrapScalars
            };
            const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
            return createNode(value, tagName, createCtx);
          }
          createPair(key, value, ctx) {
            if (!ctx)
              ctx = {
                wrapScalars: true
              };
            const k = this.createNode(key, ctx.wrapScalars, null, ctx);
            const v = this.createNode(value, ctx.wrapScalars, null, ctx);
            return new resolveSeq.Pair(k, v);
          }
        };
        PlainValue._defineProperty(Schema, "defaultPrefix", PlainValue.defaultTagPrefix);
        PlainValue._defineProperty(Schema, "defaultTags", PlainValue.defaultTags);
        exports2.Schema = Schema;
      }
    });
    var require_types3 = __commonJS2({
      "node_modules/yaml/dist/types.js"(exports2) {
        "use strict";
        var resolveSeq = require_resolveSeq_d03cb037();
        var Schema = require_Schema_88e323a7();
        require_PlainValue_ec8e588e();
        require_warnings_1000a372();
        exports2.Alias = resolveSeq.Alias;
        exports2.Collection = resolveSeq.Collection;
        exports2.Merge = resolveSeq.Merge;
        exports2.Node = resolveSeq.Node;
        exports2.Pair = resolveSeq.Pair;
        exports2.Scalar = resolveSeq.Scalar;
        exports2.YAMLMap = resolveSeq.YAMLMap;
        exports2.YAMLSeq = resolveSeq.YAMLSeq;
        exports2.binaryOptions = resolveSeq.binaryOptions;
        exports2.boolOptions = resolveSeq.boolOptions;
        exports2.intOptions = resolveSeq.intOptions;
        exports2.nullOptions = resolveSeq.nullOptions;
        exports2.strOptions = resolveSeq.strOptions;
        exports2.Schema = Schema.Schema;
      }
    });
    var require_types4 = __commonJS2({
      "node_modules/yaml/types.js"(exports2) {
        var types = require_types3();
        exports2.binaryOptions = types.binaryOptions;
        exports2.boolOptions = types.boolOptions;
        exports2.intOptions = types.intOptions;
        exports2.nullOptions = types.nullOptions;
        exports2.strOptions = types.strOptions;
        exports2.Schema = types.Schema;
        exports2.Alias = types.Alias;
        exports2.Collection = types.Collection;
        exports2.Merge = types.Merge;
        exports2.Node = types.Node;
        exports2.Pair = types.Pair;
        exports2.Scalar = types.Scalar;
        exports2.YAMLMap = types.YAMLMap;
        exports2.YAMLSeq = types.YAMLSeq;
      }
    });
    var require_yaml = __commonJS2({
      "src/lib/renderers/yaml.js"(exports2, module2) {
        var yaml = require_yaml();
        var { YAMLMap, YAMLSeq } = require_types4();
        var optionAPI = require_option();
        function getIn(obj, path) {
          return path.reduce((v, k) => k in v ? v[k] : {}, obj);
        }
        function addComments(context, path, commentNode, iterNode = commentNode) {
          const { title, description, comment } = getIn(context, path);
          const lines = [];
          if (optionAPI("renderTitle") && title) {
            lines.push(` ${title}`, "");
          }
          if (optionAPI("renderDescription") && description) {
            lines.push(` ${description}`);
          }
          if (optionAPI("renderComment") && comment) {
            lines.push(` ${comment}`);
          }
          commentNode.commentBefore = lines.join("\n");
          if (iterNode instanceof YAMLMap) {
            iterNode.items.forEach((n) => {
              addComments(context, [...path, "items", n.key.value], n.key, n.value);
            });
          } else if (iterNode instanceof YAMLSeq) {
            iterNode.items.forEach((n, i) => {
              addComments(context, [...path, "items", i], n);
            });
          }
        }
        function renderYAML({ value, context }) {
          const nodes = yaml.createNode(value);
          addComments(context, [], nodes);
          const doc = new yaml.Document();
          doc.contents = nodes;
          return doc.toString();
        }
        var yaml_default = renderYAML;
        module2.exports = yaml_default;
      }
    });
    var require_renderers = __commonJS2({
      "src/lib/renderers/index.js"(exports2, module2) {
        var renderJS = require_js();
        var renderYAML = require_yaml();
        Object.assign(module2.exports, { renderJS, renderYAML });
      }
    });
    var require_lib3 = __commonJS2({
      "src/lib/index.js"(exports2, module2) {
        var { getDependencies } = require_vendor();
        var Container = require_Container();
        var format = require_format();
        var option = require_option();
        var env = require_constants();
        var random = require_random();
        var utils = require_utils();
        var run = require_run();
        var { renderJS, renderYAML } = require_renderers();
        var container = new Container();
        function setupKeywords() {
          container.define("autoIncrement", function autoIncrement(value, schema) {
            if (!this.offset) {
              const min = schema.minimum || 1;
              const max = min + env.MAX_NUMBER;
              const offset = value.initialOffset || schema.initialOffset;
              this.offset = offset || random.number(min, max);
            }
            if (value === true) {
              return this.offset++;
            }
            return schema;
          });
          container.define("sequentialDate", function sequentialDate(value, schema) {
            if (!this.now) {
              this.now = random.date();
            }
            if (value) {
              schema = this.now.toISOString();
              value = value === true ? "days" : value;
              if (["seconds", "minutes", "hours", "days", "weeks", "months", "years"].indexOf(value) === -1) {
                throw new Error(`Unsupported increment by ${utils.short(value)}`);
              }
              this.now.setTime(this.now.getTime() + random.date(value));
            }
            return schema;
          });
        }
        function getRefs(refs, schema) {
          let $refs = {};
          if (Array.isArray(refs)) {
            refs.forEach((_schema) => {
              $refs[_schema.$id || _schema.id] = _schema;
            });
          } else {
            $refs = refs || {};
          }
          function walk(obj) {
            if (!obj || typeof obj !== "object")
              return;
            if (Array.isArray(obj))
              return obj.forEach(walk);
            const _id = obj.$id || obj.id;
            if (typeof _id === "string" && !$refs[_id]) {
              $refs[_id] = obj;
            }
            Object.keys(obj).forEach((key) => {
              walk(obj[key]);
            });
          }
          walk(refs);
          walk(schema);
          return $refs;
        }
        var jsf = (schema, refs, cwd) => {
          console.log("[json-schema-faker] calling JsonSchemaFaker() is deprecated, call either .generate() or .resolve()");
          if (cwd) {
            console.log("[json-schema-faker] references are only supported by calling .resolve()");
          }
          return jsf.generate(schema, refs);
        };
        jsf.generateWithContext = (schema, refs) => {
          const $refs = getRefs(refs, schema);
          return run($refs, schema, container, true);
        };
        jsf.generate = (schema, refs) => renderJS(jsf.generateWithContext(schema, refs));
        jsf.generateYAML = (schema, refs) => renderYAML(jsf.generateWithContext(schema, refs));
        jsf.resolveWithContext = (schema, refs, cwd) => {
          if (typeof refs === "string") {
            cwd = refs;
            refs = {};
          }
          cwd = cwd || (typeof process !== "undefined" ? process.cwd() : "");
          cwd = `${cwd.replace(/\/+$/, "")}/`;
          const $refs = getRefs(refs, schema);
          const fixedRefs = {
            order: 1,
            canRead(file) {
              const key = file.url.replace("/:", ":");
              return $refs[key] || $refs[key.split("/").pop()];
            },
            read(file, callback) {
              try {
                callback(null, this.canRead(file));
              } catch (e) {
                callback(e);
              }
            }
          };
          const { $RefParser: $RefParser2 } = getDependencies();
          return $RefParser2.bundle(cwd, schema, {
            resolve: {
              file: { order: 100 },
              http: { order: 200 },
              fixedRefs
            },
            dereference: {
              circular: "ignore"
            }
          }).then((sub) => run($refs, sub, container)).catch((e) => {
            throw new Error(`Error while resolving schema (${e.message})`);
          });
        };
        jsf.resolve = (schema, refs, cwd) => jsf.resolveWithContext(schema, refs, cwd).then(renderJS);
        jsf.resolveYAML = (schema, refs, cwd) => jsf.resolveWithContext(schema, refs, cwd).then(renderYAML);
        setupKeywords();
        jsf.format = format;
        jsf.option = option;
        jsf.random = random;
        jsf.extend = (name, cb) => {
          container.extend(name, cb);
          return jsf;
        };
        jsf.define = (name, cb) => {
          container.define(name, cb);
          return jsf;
        };
        jsf.reset = (name) => {
          container.reset(name);
          setupKeywords();
          return jsf;
        };
        jsf.locate = (name) => {
          return container.get(name);
        };
        if (typeof VERSION !== "undefined") {
          jsf.version = VERSION;
        }
        var lib_default = jsf;
        module2.exports = lib_default;
      }
    });
    __export(exports, {
      default: () => import_lib.default
    });
    var import_json_schema_ref_parser = __toModule2(__require("json-schema-ref-parser"));
    var import_jsonpath_plus = __toModule2(__require("jsonpath-plus"));
    var import_vendor = __toModule2(require_vendor());
    var import_lib = __toModule2(require_lib3());
    (0, import_vendor.setDependencies)({ $RefParser: import_json_schema_ref_parser.default, JSONPath: import_jsonpath_plus.JSONPath });
  }
});

// src/main.esm.js
var import_main_cjs = __toModule(require_main_cjs());
var export_default = import_main_cjs.default;
export {
  export_default as default
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3ZlbmRvci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY2xhc3MvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NsYXNzL1JlZ2lzdHJ5LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9hcGkvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2FwaS9kZWZhdWx0cy5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY2xhc3MvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NsYXNzL09wdGlvblJlZ2lzdHJ5LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9hcGkvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2FwaS9vcHRpb24uanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvY29uc3RhbnRzLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3JldC9saWIvdHlwZXMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMvcmV0L2xpYi9zZXRzLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3JldC9saWIvdXRpbC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL25vZGVfbW9kdWxlcy9yZXQvbGliL3Bvc2l0aW9ucy5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL25vZGVfbW9kdWxlcy9yZXQvbGliL2luZGV4LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL2RyYW5nZS9saWIvaW5kZXguanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMvcmFuZGV4cC9saWIvcmFuZGV4cC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9yYW5kb20uanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvdXRpbHMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NsYXNzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9jbGFzcy9Db250YWluZXIuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2FwaS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvYXBpL2Zvcm1hdC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9lcnJvci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9pbmZlci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9ib29sZWFuLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvYm9vbGVhbi5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9udWxsLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvbnVsbC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3R5cGVzL2FycmF5LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvbnVtYmVyLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvaW50ZWdlci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy93b3Jkcy5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3R5cGVzL29iamVjdC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy90aHVuay5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9pcHY0LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL2RhdGVUaW1lLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL2RhdGUuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2dlbmVyYXRvcnMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2dlbmVyYXRvcnMvdGltZS5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9jb3JlRm9ybWF0LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvc3RyaW5nLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvaW5kZXguanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvdHJhdmVyc2UuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvYnVpbGRSZXNvbHZlU2NoZW1hLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9jb3JlL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9jb3JlL3J1bi5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvcmVuZGVyZXJzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9yZW5kZXJlcnMvanMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L1BsYWluVmFsdWUtZWM4ZTU4OGUuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3Jlc29sdmVTZXEtZDAzY2IwMzcuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3dhcm5pbmdzLTEwMDBhMzcyLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9TY2hlbWEtODhlMzIzYTcuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3R5cGVzLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3lhbWwvdHlwZXMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3JlbmRlcmVycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvcmVuZGVyZXJzL3lhbWwuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3JlbmRlcmVycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvcmVuZGVyZXJzL2luZGV4LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvaW5kZXguanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbWFpbi5janMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbWFpbi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVQRU5ERU5DSUVTID0ge307XG5cbmV4cG9ydCBjb25zdCBnZXREZXBlbmRlbmNpZXMgPSAoKSA9PiB7XG4gIHJldHVybiBERVBFTkRFTkNJRVM7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0RGVwZW5kZW5jaWVzID0gdmFsdWUgPT4ge1xuICBPYmplY3QuYXNzaWduKERFUEVOREVOQ0lFUywgdmFsdWUpO1xufTtcbiIsIi8qKlxuICogVGhpcyBjbGFzcyBkZWZpbmVzIGEgcmVnaXN0cnkgZm9yIGN1c3RvbSBmb3JtYXRzIHVzZWQgd2l0aGluIEpTRi5cbiAqL1xuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBlbXB0eSBieSBkZWZhdWx0XG4gICAgdGhpcy5kYXRhID0ge307XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgY3VzdG9tIGZvcm1hdChzKVxuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgdW5yZWdpc3RlcihuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YVtuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGN1c3RvbSBmb3JtYXRcbiAgICovXG4gIHJlZ2lzdGVyKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5kYXRhW25hbWVdID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgbWFueSBmb3JtYXRzIGF0IG9uZSBzaG90XG4gICAqL1xuICByZWdpc3Rlck1hbnkoZm9ybWF0cykge1xuICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0aGlzLmRhdGFbbmFtZV0gPSBmb3JtYXRzW25hbWVdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZWxlbWVudCBieSByZWdpc3RyeSBrZXlcbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5kYXRhW25hbWVdO1xuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aG9sZSByZWdpc3RyeSBjb250ZW50XG4gICAqL1xuICBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVnaXN0cnk7XG4iLCJjb25zdCBkZWZhdWx0cyA9IHt9O1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0cztcblxuZGVmYXVsdHMuZGVmYXVsdEludmFsaWRUeXBlUHJvZHVjdCA9IHVuZGVmaW5lZDtcbmRlZmF1bHRzLmRlZmF1bHRSYW5kRXhwTWF4ID0gMTA7XG5cbmRlZmF1bHRzLmlnbm9yZVByb3BlcnRpZXMgPSBbXTtcbmRlZmF1bHRzLmlnbm9yZU1pc3NpbmdSZWZzID0gZmFsc2U7XG5kZWZhdWx0cy5mYWlsT25JbnZhbGlkVHlwZXMgPSB0cnVlO1xuZGVmYXVsdHMuZmFpbE9uSW52YWxpZEZvcm1hdCA9IHRydWU7XG5cbmRlZmF1bHRzLmFsd2F5c0Zha2VPcHRpb25hbHMgPSBmYWxzZTtcbmRlZmF1bHRzLm9wdGlvbmFsc1Byb2JhYmlsaXR5ID0gbnVsbDtcbmRlZmF1bHRzLmZpeGVkUHJvYmFiaWxpdGllcyA9IGZhbHNlO1xuZGVmYXVsdHMudXNlRXhhbXBsZXNWYWx1ZSA9IGZhbHNlO1xuZGVmYXVsdHMudXNlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5kZWZhdWx0cy5yZXF1aXJlZE9ubHkgPSBmYWxzZTtcblxuZGVmYXVsdHMubWluSXRlbXMgPSAwO1xuZGVmYXVsdHMubWF4SXRlbXMgPSBudWxsO1xuZGVmYXVsdHMubWluTGVuZ3RoID0gMDtcbmRlZmF1bHRzLm1heExlbmd0aCA9IG51bGw7XG5cbmRlZmF1bHRzLnJlc29sdmVKc29uUGF0aCA9IGZhbHNlO1xuZGVmYXVsdHMucmV1c2VQcm9wZXJ0aWVzID0gZmFsc2U7XG5kZWZhdWx0cy5maWxsUHJvcGVydGllcyA9IHRydWU7XG5kZWZhdWx0cy5yZXBsYWNlRW1wdHlCeVJhbmRvbVZhbHVlID0gZmFsc2U7XG5cbmRlZmF1bHRzLnJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG5kZWZhdWx0cy5yZW5kZXJUaXRsZSA9IHRydWU7XG5kZWZhdWx0cy5yZW5kZXJEZXNjcmlwdGlvbiA9IHRydWU7XG5kZWZhdWx0cy5yZW5kZXJDb21tZW50ID0gZmFsc2U7XG4iLCJpbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi9SZWdpc3RyeSc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vYXBpL2RlZmF1bHRzJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGRlZmluZXMgYSByZWdpc3RyeSBmb3IgY3VzdG9tIHNldHRpbmdzIHVzZWQgd2l0aGluIEpTRi5cbiAqL1xuY2xhc3MgT3B0aW9uUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kYXRhID0geyAuLi5kZWZhdWx0cyB9O1xuICAgIHRoaXMuX2RlZmF1bHRzID0gZGVmYXVsdHM7XG4gIH1cblxuICBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5fZGVmYXVsdHMgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPcHRpb25SZWdpc3RyeTtcbiIsImltcG9ydCBPcHRpb25SZWdpc3RyeSBmcm9tICcuLi9jbGFzcy9PcHRpb25SZWdpc3RyeSc7XG5cbi8vIGluc3RhbnRpYXRlXG5jb25zdCByZWdpc3RyeSA9IG5ldyBPcHRpb25SZWdpc3RyeSgpO1xuXG4vKipcbiAqIEN1c3RvbSBvcHRpb24gQVBJXG4gKlxuICogQHBhcmFtIG5hbWVPck9wdGlvbk1hcFxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gb3B0aW9uQVBJKG5hbWVPck9wdGlvbk1hcCwgb3B0aW9uYWxWYWx1ZSkge1xuICBpZiAodHlwZW9mIG5hbWVPck9wdGlvbk1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbmFsVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gcmVnaXN0cnkucmVnaXN0ZXIobmFtZU9yT3B0aW9uTWFwLCBvcHRpb25hbFZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaXN0cnkuZ2V0KG5hbWVPck9wdGlvbk1hcCk7XG4gIH1cblxuICByZXR1cm4gcmVnaXN0cnkucmVnaXN0ZXJNYW55KG5hbWVPck9wdGlvbk1hcCk7XG59XG5cbm9wdGlvbkFQSS5nZXREZWZhdWx0cyA9ICgpID0+IHJlZ2lzdHJ5LmRlZmF1bHRzO1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25BUEk7XG4iLCJjb25zdCBBTExPV0VEX1RZUEVTID0gWydpbnRlZ2VyJywgJ251bWJlcicsICdzdHJpbmcnLCAnYm9vbGVhbiddO1xuY29uc3QgU0NBTEFSX1RZUEVTID0gQUxMT1dFRF9UWVBFUy5jb25jYXQoWydudWxsJ10pO1xuY29uc3QgQUxMX1RZUEVTID0gWydhcnJheScsICdvYmplY3QnXS5jb25jYXQoU0NBTEFSX1RZUEVTKTtcblxuY29uc3QgTU9TVF9ORUFSX0RBVEVUSU1FID0gMjUyNDYwODAwMDAwMDtcblxuY29uc3QgTUlOX0lOVEVHRVIgPSAtMTAwMDAwMDAwO1xuY29uc3QgTUFYX0lOVEVHRVIgPSAxMDAwMDAwMDA7XG5cbmNvbnN0IE1JTl9OVU1CRVIgPSAtMTAwO1xuY29uc3QgTUFYX05VTUJFUiA9IDEwMDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBBTExPV0VEX1RZUEVTLFxuICBTQ0FMQVJfVFlQRVMsXG4gIEFMTF9UWVBFUyxcbiAgTUlOX05VTUJFUixcbiAgTUFYX05VTUJFUixcbiAgTUlOX0lOVEVHRVIsXG4gIE1BWF9JTlRFR0VSLFxuICBNT1NUX05FQVJfREFURVRJTUUsXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJPT1QgICAgICAgOiAwLFxuICBHUk9VUCAgICAgIDogMSxcbiAgUE9TSVRJT04gICA6IDIsXG4gIFNFVCAgICAgICAgOiAzLFxuICBSQU5HRSAgICAgIDogNCxcbiAgUkVQRVRJVElPTiA6IDUsXG4gIFJFRkVSRU5DRSAgOiA2LFxuICBDSEFSICAgICAgIDogNyxcbn07XG4iLCJjb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3QgSU5UUyA9ICgpID0+IFt7IHR5cGU6IHR5cGVzLlJBTkdFICwgZnJvbTogNDgsIHRvOiA1NyB9XTtcblxuY29uc3QgV09SRFMgPSAoKSA9PiB7XG4gIHJldHVybiBbXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogOTUgfSxcbiAgICB7IHR5cGU6IHR5cGVzLlJBTkdFLCBmcm9tOiA5NywgdG86IDEyMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuUkFOR0UsIGZyb206IDY1LCB0bzogOTAgfVxuICBdLmNvbmNhdChJTlRTKCkpO1xufTtcblxuY29uc3QgV0hJVEVTUEFDRSA9ICgpID0+IHtcbiAgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA5IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTMgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAzMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDE2MCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDU3NjAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLlJBTkdFLCBmcm9tOiA4MTkyLCB0bzogODIwMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjMzIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzOSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyODcgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMjI4OCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDY1Mjc5IH1cbiAgXTtcbn07XG5cbmNvbnN0IE5PVEFOWUNIQVIgPSAoKSA9PiB7XG4gIHJldHVybiBbXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjMzIH0sXG4gIF07XG59O1xuXG4vLyBQcmVkZWZpbmVkIGNsYXNzIG9iamVjdHMuXG5leHBvcnRzLndvcmRzID0gKCkgPT4gKHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IFdPUkRTKCksIG5vdDogZmFsc2UgfSk7XG5leHBvcnRzLm5vdFdvcmRzID0gKCkgPT4gKHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IFdPUkRTKCksIG5vdDogdHJ1ZSB9KTtcbmV4cG9ydHMuaW50cyA9ICgpID0+ICh7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBJTlRTKCksIG5vdDogZmFsc2UgfSk7XG5leHBvcnRzLm5vdEludHMgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5TRVQsIHNldDogSU5UUygpLCBub3Q6IHRydWUgfSk7XG5leHBvcnRzLndoaXRlc3BhY2UgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV0hJVEVTUEFDRSgpLCBub3Q6IGZhbHNlIH0pO1xuZXhwb3J0cy5ub3RXaGl0ZXNwYWNlID0gKCkgPT4gKHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IFdISVRFU1BBQ0UoKSwgbm90OiB0cnVlIH0pO1xuZXhwb3J0cy5hbnlDaGFyID0gKCkgPT4gKHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IE5PVEFOWUNIQVIoKSwgbm90OiB0cnVlIH0pO1xuIiwiY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCBzZXRzICA9IHJlcXVpcmUoJy4vc2V0cycpO1xuXG5cbmNvbnN0IENUUkwgPSAnQEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXiA/JztcbmNvbnN0IFNMU0ggPSB7ICcwJzogMCwgJ3QnOiA5LCAnbic6IDEwLCAndic6IDExLCAnZic6IDEyLCAncic6IDEzIH07XG5cbi8qKlxuICogRmluZHMgY2hhcmFjdGVyIHJlcHJlc2VudGF0aW9ucyBpbiBzdHIgYW5kIGNvbnZlcnQgYWxsIHRvXG4gKiB0aGVpciByZXNwZWN0aXZlIGNoYXJhY3RlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuc3RyVG9DaGFycyA9IGZ1bmN0aW9uKHN0cikge1xuICAvKiBqc2hpbnQgbWF4bGVuOiBmYWxzZSAqL1xuICB2YXIgY2hhcnNfcmVnZXggPSAvKFxcW1xcXFxiXFxdKXwoXFxcXCk/XFxcXCg/OnUoW0EtRjAtOV17NH0pfHgoW0EtRjAtOV17Mn0pfCgwP1swLTddezJ9KXxjKFtAQS1aW1xcXFxcXF1eP10pfChbMHRudmZyXSkpL2c7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKGNoYXJzX3JlZ2V4LCBmdW5jdGlvbihzLCBiLCBsYnMsIGExNiwgYjE2LCBjOCwgZGN0cmwsIGVzbHNoKSB7XG4gICAgaWYgKGxicykge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgdmFyIGNvZGUgPSBiID8gOCA6XG4gICAgICBhMTYgICA/IHBhcnNlSW50KGExNiwgMTYpIDpcbiAgICAgIGIxNiAgID8gcGFyc2VJbnQoYjE2LCAxNikgOlxuICAgICAgYzggICAgPyBwYXJzZUludChjOCwgICA4KSA6XG4gICAgICBkY3RybCA/IENUUkwuaW5kZXhPZihkY3RybCkgOlxuICAgICAgU0xTSFtlc2xzaF07XG5cbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyYWN0ZXJzLlxuICAgIGlmICgvW1tcXF17fV4kLnw/KisoKV0vLnRlc3QoYykpIHtcbiAgICAgIGMgPSAnXFxcXCcgKyBjO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9KTtcblxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIHR1cm5zIGNsYXNzIGludG8gdG9rZW5zXG4gKiByZWFkcyBzdHIgdW50aWwgaXQgZW5jb3VudGVycyBhIF0gbm90IHByZWNlZWRlZCBieSBhIFxcXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHJlZ2V4cFN0clxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxPYmplY3Q+LCBOdW1iZXI+fVxuICovXG5leHBvcnRzLnRva2VuaXplQ2xhc3MgPSAoc3RyLCByZWdleHBTdHIpID0+IHtcbiAgLyoganNoaW50IG1heGxlbjogZmFsc2UgKi9cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmVnZXhwID0gL1xcXFwoPzoodyl8KGQpfChzKXwoVyl8KEQpfChTKSl8KCg/Oig/OlxcXFwpKC4pfChbXlxcXVxcXFxdKSktKD86XFxcXCk/KFteXFxdXSkpfChcXF0pfCg/OlxcXFwpPyhbXl0pL2c7XG4gIHZhciBycywgYztcblxuXG4gIHdoaWxlICgocnMgPSByZWdleHAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgaWYgKHJzWzFdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLndvcmRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1syXSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5pbnRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1szXSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy53aGl0ZXNwYWNlKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s0XSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5ub3RXb3JkcygpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbNV0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMubm90SW50cygpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbNl0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMubm90V2hpdGVzcGFjZSgpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbN10pIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZXMuUkFOR0UsXG4gICAgICAgIGZyb206IChyc1s4XSB8fCByc1s5XSkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgdG86IHJzWzEwXS5jaGFyQ29kZUF0KDApLFxuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKChjID0gcnNbMTJdKSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlcy5DSEFSLFxuICAgICAgICB2YWx1ZTogYy5jaGFyQ29kZUF0KDApLFxuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt0b2tlbnMsIHJlZ2V4cC5sYXN0SW5kZXhdO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMuZXJyb3IocmVnZXhwU3RyLCAnVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzcycpO1xufTtcblxuXG4vKipcbiAqIFNob3J0Y3V0IHRvIHRocm93IGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVnZXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnXG4gKi9cbmV4cG9ydHMuZXJyb3IgPSAocmVnZXhwLCBtc2cpID0+IHtcbiAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogLycgKyByZWdleHAgKyAnLzogJyArIG1zZyk7XG59O1xuIiwiY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5leHBvcnRzLndvcmRCb3VuZGFyeSA9ICgpID0+ICh7IHR5cGU6IHR5cGVzLlBPU0lUSU9OLCB2YWx1ZTogJ2InIH0pO1xuZXhwb3J0cy5ub25Xb3JkQm91bmRhcnkgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5QT1NJVElPTiwgdmFsdWU6ICdCJyB9KTtcbmV4cG9ydHMuYmVnaW4gPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5QT1NJVElPTiwgdmFsdWU6ICdeJyB9KTtcbmV4cG9ydHMuZW5kID0gKCkgPT4gKHsgdHlwZTogdHlwZXMuUE9TSVRJT04sIHZhbHVlOiAnJCcgfSk7XG4iLCJjb25zdCB1dGlsICAgICAgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IHR5cGVzICAgICA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHNldHMgICAgICA9IHJlcXVpcmUoJy4vc2V0cycpO1xuY29uc3QgcG9zaXRpb25zID0gcmVxdWlyZSgnLi9wb3NpdGlvbnMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChyZWdleHBTdHIpID0+IHtcbiAgdmFyIGkgPSAwLCBsLCBjLFxuICAgIHN0YXJ0ID0geyB0eXBlOiB0eXBlcy5ST09ULCBzdGFjazogW119LFxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiBsYXN0IGNsYXVzZS9ncm91cCBhbmQgc3RhY2suXG4gICAgbGFzdEdyb3VwID0gc3RhcnQsXG4gICAgbGFzdCA9IHN0YXJ0LnN0YWNrLFxuICAgIGdyb3VwU3RhY2sgPSBbXTtcblxuXG4gIHZhciByZXBlYXRFcnIgPSAoaSkgPT4ge1xuICAgIHV0aWwuZXJyb3IocmVnZXhwU3RyLCBgTm90aGluZyB0byByZXBlYXQgYXQgY29sdW1uICR7aSAtIDF9YCk7XG4gIH07XG5cbiAgLy8gRGVjb2RlIGEgZmV3IGVzY2FwZWQgY2hhcmFjdGVycy5cbiAgdmFyIHN0ciA9IHV0aWwuc3RyVG9DaGFycyhyZWdleHBTdHIpO1xuICBsID0gc3RyLmxlbmd0aDtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgaW4gc3RyaW5nLlxuICB3aGlsZSAoaSA8IGwpIHtcbiAgICBjID0gc3RyW2krK107XG5cbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIC8vIEhhbmRsZSBlc2NhcGVkIGNoYXJhY3RlcnMsIGluY2x1ZXMgYSBmZXcgc2V0cy5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjID0gc3RyW2krK107XG5cbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBsYXN0LnB1c2gocG9zaXRpb25zLndvcmRCb3VuZGFyeSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICBsYXN0LnB1c2gocG9zaXRpb25zLm5vbldvcmRCb3VuZGFyeSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy53b3JkcygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy5ub3RXb3JkcygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy5pbnRzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLm5vdEludHMoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMud2hpdGVzcGFjZSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy5ub3RXaGl0ZXNwYWNlKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYyBpcyBpbnRlZ2VyLlxuICAgICAgICAgICAgLy8gSW4gd2hpY2ggY2FzZSBpdCdzIGEgcmVmZXJlbmNlLlxuICAgICAgICAgICAgaWYgKC9cXGQvLnRlc3QoYykpIHtcbiAgICAgICAgICAgICAgbGFzdC5wdXNoKHsgdHlwZTogdHlwZXMuUkVGRVJFTkNFLCB2YWx1ZTogcGFyc2VJbnQoYywgMTApIH0pO1xuXG4gICAgICAgICAgICAvLyBFc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3QucHVzaCh7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiBjLmNoYXJDb2RlQXQoMCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBQb3NpdGlvbmFscy5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICBsYXN0LnB1c2gocG9zaXRpb25zLmJlZ2luKCkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJCc6XG4gICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMuZW5kKCkpO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBIYW5kbGUgY3VzdG9tIHNldHMuXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjbGFzcyBpcyAnYW50aScgaS5lLiBbXmFiY10uXG4gICAgICAgIHZhciBub3Q7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdeJykge1xuICAgICAgICAgIG5vdCA9IHRydWU7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgY2hhcmFjdGVycyBpbiBjbGFzcy5cbiAgICAgICAgdmFyIGNsYXNzVG9rZW5zID0gdXRpbC50b2tlbml6ZUNsYXNzKHN0ci5zbGljZShpKSwgcmVnZXhwU3RyKTtcblxuICAgICAgICAvLyBJbmNyZWFzZSBpbmRleCBieSBsZW5ndGggb2YgY2xhc3MuXG4gICAgICAgIGkgKz0gY2xhc3NUb2tlbnNbMV07XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuU0VULFxuICAgICAgICAgIHNldDogY2xhc3NUb2tlbnNbMF0sXG4gICAgICAgICAgbm90LFxuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBDbGFzcyBvZiBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBcXG4uXG4gICAgICBjYXNlICcuJzpcbiAgICAgICAgbGFzdC5wdXNoKHNldHMuYW55Q2hhcigpKTtcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gUHVzaCBncm91cCBvbnRvIHN0YWNrLlxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIC8vIENyZWF0ZSBncm91cC5cbiAgICAgICAgdmFyIGdyb3VwID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGVzLkdST1VQLFxuICAgICAgICAgIHN0YWNrOiBbXSxcbiAgICAgICAgICByZW1lbWJlcjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBjID0gc3RyW2ldO1xuXG4gICAgICAgIC8vIElmIGlmIHRoaXMgaXMgYSBzcGVjaWFsIGtpbmQgb2YgZ3JvdXAuXG4gICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICBjID0gc3RyW2kgKyAxXTtcbiAgICAgICAgICBpICs9IDI7XG5cbiAgICAgICAgICAvLyBNYXRjaCBpZiBmb2xsb3dlZCBieS5cbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBncm91cC5mb2xsb3dlZEJ5ID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIE1hdGNoIGlmIG5vdCBmb2xsb3dlZCBieS5cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgZ3JvdXAubm90Rm9sbG93ZWRCeSA9IHRydWU7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgIT09ICc6Jykge1xuICAgICAgICAgICAgdXRpbC5lcnJvcihyZWdleHBTdHIsXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGdyb3VwLCBjaGFyYWN0ZXIgJyR7Y30nYCArXG4gICAgICAgICAgICAgIGAgYWZ0ZXIgJz8nIGF0IGNvbHVtbiAke2kgLSAxfWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdyb3VwLnJlbWVtYmVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgc3ViZ3JvdXAgaW50byBjdXJyZW50IGdyb3VwIHN0YWNrLlxuICAgICAgICBsYXN0LnB1c2goZ3JvdXApO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjdXJyZW50IGdyb3VwIGZvciB3aGVuIHRoZSBncm91cCBjbG9zZXMuXG4gICAgICAgIGdyb3VwU3RhY2sucHVzaChsYXN0R3JvdXApO1xuXG4gICAgICAgIC8vIE1ha2UgdGhpcyBuZXcgZ3JvdXAgdGhlIGN1cnJlbnQgZ3JvdXAuXG4gICAgICAgIGxhc3RHcm91cCA9IGdyb3VwO1xuICAgICAgICBsYXN0ID0gZ3JvdXAuc3RhY2s7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFBvcCBncm91cCBvdXQgb2Ygc3RhY2suXG4gICAgICBjYXNlICcpJzpcbiAgICAgICAgaWYgKGdyb3VwU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdXRpbC5lcnJvcihyZWdleHBTdHIsIGBVbm1hdGNoZWQgKSBhdCBjb2x1bW4gJHtpIC0gMX1gKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0R3JvdXAgPSBncm91cFN0YWNrLnBvcCgpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZ3JvdXAgaGFzIGEgUElQRS5cbiAgICAgICAgLy8gVG8gZ2V0IGJhY2sgdGhlIGNvcnJlY3QgbGFzdCBzdGFjay5cbiAgICAgICAgbGFzdCA9IGxhc3RHcm91cC5vcHRpb25zID9cbiAgICAgICAgICBsYXN0R3JvdXAub3B0aW9uc1tsYXN0R3JvdXAub3B0aW9ucy5sZW5ndGggLSAxXSA6IGxhc3RHcm91cC5zdGFjaztcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gVXNlIHBpcGUgY2hhcmFjdGVyIHRvIGdpdmUgbW9yZSBjaG9pY2VzLlxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIC8vIENyZWF0ZSBhcnJheSB3aGVyZSBvcHRpb25zIGFyZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBQSVBFXG4gICAgICAgIC8vIGluIHRoaXMgY2xhdXNlLlxuICAgICAgICBpZiAoIWxhc3RHcm91cC5vcHRpb25zKSB7XG4gICAgICAgICAgbGFzdEdyb3VwLm9wdGlvbnMgPSBbbGFzdEdyb3VwLnN0YWNrXTtcbiAgICAgICAgICBkZWxldGUgbGFzdEdyb3VwLnN0YWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN0YWNrIGFuZCBhZGQgdG8gb3B0aW9ucyBmb3IgcmVzdCBvZiBjbGF1c2UuXG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICBsYXN0R3JvdXAub3B0aW9ucy5wdXNoKHN0YWNrKTtcbiAgICAgICAgbGFzdCA9IHN0YWNrO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBSZXBldGl0aW9uLlxuICAgICAgLy8gRm9yIGV2ZXJ5IHJlcGV0aXRpb24sIHJlbW92ZSBsYXN0IGVsZW1lbnQgZnJvbSBsYXN0IHN0YWNrXG4gICAgICAvLyB0aGVuIGluc2VydCBiYWNrIGEgUkFOR0Ugb2JqZWN0LlxuICAgICAgLy8gVGhpcyBkZXNpZ24gaXMgY2hvc2VuIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbW9yZSB0aGFuXG4gICAgICAvLyBvbmUgcmVwZXRpdGlvbiBzeW1ib2xzIGluIGEgcmVnZXggaS5lLiBgYT8rezIsM31gLlxuICAgICAgY2FzZSAneyc6XG4gICAgICAgIHZhciBycyA9IC9eKFxcZCspKCwoXFxkKyk/KT9cXH0vLmV4ZWMoc3RyLnNsaWNlKGkpKSwgbWluLCBtYXg7XG4gICAgICAgIGlmIChycyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChsYXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaW4gPSBwYXJzZUludChyc1sxXSwgMTApO1xuICAgICAgICAgIG1heCA9IHJzWzJdID8gcnNbM10gPyBwYXJzZUludChyc1szXSwgMTApIDogSW5maW5pdHkgOiBtaW47XG4gICAgICAgICAgaSArPSByc1swXS5sZW5ndGg7XG5cbiAgICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlcy5DSEFSLFxuICAgICAgICAgICAgdmFsdWU6IDEyMyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPyc6XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlcGVhdEVycihpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGVzLlJFUEVUSVRJT04sXG4gICAgICAgICAgbWluOiAwLFxuICAgICAgICAgIG1heDogMSxcbiAgICAgICAgICB2YWx1ZTogbGFzdC5wb3AoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICBtaW46IDEsXG4gICAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgICAgICB2YWx1ZTogbGFzdC5wb3AoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgICAgICB2YWx1ZTogbGFzdC5wb3AoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIERlZmF1bHQgaXMgYSBjaGFyYWN0ZXIgdGhhdCBpcyBub3QgYFxcW10oKXt9PysqXiRgLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5DSEFSLFxuICAgICAgICAgIHZhbHVlOiBjLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW55IGdyb3VwcyBoYXZlIG5vdCBiZWVuIGNsb3NlZC5cbiAgaWYgKGdyb3VwU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgdXRpbC5lcnJvcihyZWdleHBTdHIsICdVbnRlcm1pbmF0ZWQgZ3JvdXAnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFydDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnR5cGVzID0gdHlwZXM7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQgaW5kZW50OiA0ICovXG5cblxuLy8gUHJpdmF0ZSBoZWxwZXIgY2xhc3NcbmNsYXNzIFN1YlJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb3csIGhpZ2gpIHtcbiAgICAgICAgdGhpcy5sb3cgPSBsb3c7XG4gICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMSArIGhpZ2ggLSBsb3c7XG4gICAgfVxuXG4gICAgb3ZlcmxhcHMocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5oaWdoIDwgcmFuZ2UubG93IHx8IHRoaXMubG93ID4gcmFuZ2UuaGlnaCk7XG4gICAgfVxuXG4gICAgdG91Y2hlcyhyYW5nZSkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmhpZ2ggKyAxIDwgcmFuZ2UubG93IHx8IHRoaXMubG93IC0gMSA+IHJhbmdlLmhpZ2gpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgaW5jbHVzaXZlIGNvbWJpbmF0aW9uIG9mIFN1YlJhbmdlcyBhcyBhIFN1YlJhbmdlLlxuICAgIGFkZChyYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YlJhbmdlKFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy5sb3csIHJhbmdlLmxvdyksXG4gICAgICAgICAgICBNYXRoLm1heCh0aGlzLmhpZ2gsIHJhbmdlLmhpZ2gpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBzdWJ0cmFjdGlvbiBvZiBTdWJSYW5nZXMgYXMgYW4gYXJyYXkgb2YgU3ViUmFuZ2VzLlxuICAgIC8vIChUaGVyZSdzIGEgY2FzZSB3aGVyZSBzdWJ0cmFjdGlvbiBkaXZpZGVzIGl0IGluIDIpXG4gICAgc3VidHJhY3QocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLmxvdyA8PSB0aGlzLmxvdyAmJiByYW5nZS5oaWdoID49IHRoaXMuaGlnaCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmxvdyA+IHRoaXMubG93ICYmIHJhbmdlLmhpZ2ggPCB0aGlzLmhpZ2gpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV3IFN1YlJhbmdlKHRoaXMubG93LCByYW5nZS5sb3cgLSAxKSxcbiAgICAgICAgICAgICAgICBuZXcgU3ViUmFuZ2UocmFuZ2UuaGlnaCArIDEsIHRoaXMuaGlnaClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UubG93IDw9IHRoaXMubG93KSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBTdWJSYW5nZShyYW5nZS5oaWdoICsgMSwgdGhpcy5oaWdoKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBTdWJSYW5nZSh0aGlzLmxvdywgcmFuZ2UubG93IC0gMSldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA9PSB0aGlzLmhpZ2ggP1xuICAgICAgICAgICAgdGhpcy5sb3cudG9TdHJpbmcoKSA6IHRoaXMubG93ICsgJy0nICsgdGhpcy5oaWdoO1xuICAgIH1cbn1cblxuXG5jbGFzcyBEUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGEsIGIpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB0aGlzLmFkZChhLCBiKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlX2xlbmd0aCgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLnJhbmdlcy5yZWR1Y2UoKHByZXZpb3VzLCByYW5nZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgcmFuZ2UubGVuZ3RoO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBhZGQoYSwgYikge1xuICAgICAgICB2YXIgX2FkZCA9IChzdWJyYW5nZSkgPT4ge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJhbmdlcy5sZW5ndGggJiYgIXN1YnJhbmdlLnRvdWNoZXModGhpcy5yYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJhbmdlcy5sZW5ndGggJiYgc3VicmFuZ2UudG91Y2hlcyh0aGlzLnJhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBzdWJyYW5nZSA9IHN1YnJhbmdlLmFkZCh0aGlzLnJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2goc3VicmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBuZXdSYW5nZXMuY29uY2F0KHRoaXMucmFuZ2VzLnNsaWNlKGkpKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZV9sZW5ndGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgRFJhbmdlKSB7XG4gICAgICAgICAgICBhLnJhbmdlcy5mb3JFYWNoKF9hZGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGIgPT0gbnVsbCkgYiA9IGE7XG4gICAgICAgICAgICBfYWRkKG5ldyBTdWJSYW5nZShhLCBiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VidHJhY3QoYSwgYikge1xuICAgICAgICB2YXIgX3N1YnRyYWN0ID0gKHN1YnJhbmdlKSA9PiB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAmJiAhc3VicmFuZ2Uub3ZlcmxhcHModGhpcy5yYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJhbmdlcy5sZW5ndGggJiYgc3VicmFuZ2Uub3ZlcmxhcHModGhpcy5yYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2VzID0gbmV3UmFuZ2VzLmNvbmNhdCh0aGlzLnJhbmdlc1tpXS5zdWJ0cmFjdChzdWJyYW5nZSkpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFuZ2VzID0gbmV3UmFuZ2VzLmNvbmNhdCh0aGlzLnJhbmdlcy5zbGljZShpKSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVfbGVuZ3RoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBEUmFuZ2UpIHtcbiAgICAgICAgICAgIGEucmFuZ2VzLmZvckVhY2goX3N1YnRyYWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiID09IG51bGwpIGIgPSBhO1xuICAgICAgICAgICAgX3N1YnRyYWN0KG5ldyBTdWJSYW5nZShhLCBiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0KGEsIGIpIHtcbiAgICAgICAgdmFyIG5ld1JhbmdlcyA9IFtdO1xuICAgICAgICB2YXIgX2ludGVyc2VjdCA9IChzdWJyYW5nZSkgPT4ge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJhbmdlcy5sZW5ndGggJiYgIXN1YnJhbmdlLm92ZXJsYXBzKHRoaXMucmFuZ2VzW2ldKSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5yYW5nZXMubGVuZ3RoICYmIHN1YnJhbmdlLm92ZXJsYXBzKHRoaXMucmFuZ2VzW2ldKSkge1xuICAgICAgICAgICAgICAgIHZhciBsb3cgPSBNYXRoLm1heCh0aGlzLnJhbmdlc1tpXS5sb3csIHN1YnJhbmdlLmxvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBNYXRoLm1pbih0aGlzLnJhbmdlc1tpXS5oaWdoLCBzdWJyYW5nZS5oaWdoKTtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChuZXcgU3ViUmFuZ2UobG93LCBoaWdoKSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgRFJhbmdlKSB7XG4gICAgICAgICAgICBhLnJhbmdlcy5mb3JFYWNoKF9pbnRlcnNlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGIgPT0gbnVsbCkgYiA9IGE7XG4gICAgICAgICAgICBfaW50ZXJzZWN0KG5ldyBTdWJSYW5nZShhLCBiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgICAgIHRoaXMuX3VwZGF0ZV9sZW5ndGgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5kZXgoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAmJiB0aGlzLnJhbmdlc1tpXS5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICAgIGluZGV4IC09IHRoaXMucmFuZ2VzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaV0ubG93ICsgaW5kZXg7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnWyAnICsgdGhpcy5yYW5nZXMuam9pbignLCAnKSArICcgXSc7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRFJhbmdlKHRoaXMpO1xuICAgIH1cblxuICAgIG51bWJlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5yZWR1Y2UoKHJlc3VsdCwgc3VicmFuZ2UpID0+IHtcbiAgICAgICAgICAgIHZhciBpID0gc3VicmFuZ2UubG93O1xuICAgICAgICAgICAgd2hpbGUgKGkgPD0gc3VicmFuZ2UuaGlnaCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG5cbiAgICBzdWJyYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5tYXAoKHN1YnJhbmdlKSA9PiAoe1xuICAgICAgICAgICAgbG93OiBzdWJyYW5nZS5sb3csXG4gICAgICAgICAgICBoaWdoOiBzdWJyYW5nZS5oaWdoLFxuICAgICAgICAgICAgbGVuZ3RoOiAxICsgc3VicmFuZ2UuaGlnaCAtIHN1YnJhbmdlLmxvd1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERSYW5nZTtcbiIsImNvbnN0IHJldCAgICA9IHJlcXVpcmUoJ3JldCcpO1xuY29uc3QgRFJhbmdlID0gcmVxdWlyZSgnZHJhbmdlJyk7XG5jb25zdCB0eXBlcyAgPSByZXQudHlwZXM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSYW5kRXhwIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVnZXhwLCBtKSB7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVnZXhwKTtcbiAgICBpZiAocmVnZXhwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICB0aGlzLmlnbm9yZUNhc2UgPSByZWdleHAuaWdub3JlQ2FzZTtcbiAgICAgIHRoaXMubXVsdGlsaW5lID0gcmVnZXhwLm11bHRpbGluZTtcbiAgICAgIHJlZ2V4cCA9IHJlZ2V4cC5zb3VyY2U7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWdleHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmlnbm9yZUNhc2UgPSBtICYmIG0uaW5kZXhPZignaScpICE9PSAtMTtcbiAgICAgIHRoaXMubXVsdGlsaW5lID0gbSAmJiBtLmluZGV4T2YoJ20nKSAhPT0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSByZWdleHAgb3Igc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgdGhpcy50b2tlbnMgPSByZXQocmVnZXhwKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzb21lIGN1c3RvbSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQgZm9yIHRoaXMgcmVnZXhwLlxuICAgKlxuICAgKiBAcGFyYW0ge1JhbmRFeHB9IHJhbmRleHBcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKi9cbiAgX3NldERlZmF1bHRzKHJlZ2V4cCkge1xuICAgIC8vIFdoZW4gYSByZXBldGl0aW9uYWwgdG9rZW4gaGFzIGl0cyBtYXggc2V0IHRvIEluZmluaXRlLFxuICAgIC8vIHJhbmRleHAgd29uJ3QgYWN0dWFsbHkgZ2VuZXJhdGUgYSByYW5kb20gYW1vdW50IGJldHdlZW4gbWluIGFuZCBJbmZpbml0ZVxuICAgIC8vIGluc3RlYWQgaXQgd2lsbCBzZWUgSW5maW5pdGUgYXMgbWluICsgMTAwLlxuICAgIHRoaXMubWF4ID0gcmVnZXhwLm1heCAhPSBudWxsID8gcmVnZXhwLm1heCA6XG4gICAgICBSYW5kRXhwLnByb3RvdHlwZS5tYXggIT0gbnVsbCA/IFJhbmRFeHAucHJvdG90eXBlLm1heCA6IDEwMDtcblxuICAgIC8vIFRoaXMgYWxsb3dzIGV4cGFuZGluZyB0byBpbmNsdWRlIGFkZGl0aW9uYWwgY2hhcmFjdGVyc1xuICAgIC8vIGZvciBpbnN0YW5jZTogUmFuZEV4cC5kZWZhdWx0UmFuZ2UuYWRkKDAsIDY1NTM1KTtcbiAgICB0aGlzLmRlZmF1bHRSYW5nZSA9IHJlZ2V4cC5kZWZhdWx0UmFuZ2UgP1xuICAgICAgcmVnZXhwLmRlZmF1bHRSYW5nZSA6IHRoaXMuZGVmYXVsdFJhbmdlLmNsb25lKCk7XG5cbiAgICBpZiAocmVnZXhwLnJhbmRJbnQpIHtcbiAgICAgIHRoaXMucmFuZEludCA9IHJlZ2V4cC5yYW5kSW50O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgcmFuZG9tIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2VuKCkge1xuICAgIHJldHVybiB0aGlzLl9nZW4odGhpcy50b2tlbnMsIFtdKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHJhbmRvbSBzdHJpbmcgbW9kZWxlZCBhZnRlciBnaXZlbiB0b2tlbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBncm91cHNcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX2dlbih0b2tlbiwgZ3JvdXBzKSB7XG4gICAgdmFyIHN0YWNrLCBzdHIsIG4sIGksIGw7XG5cbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgdHlwZXMuUk9PVDpcbiAgICAgIGNhc2UgdHlwZXMuR1JPVVA6XG4gICAgICAgIC8vIElnbm9yZSBsb29rYWhlYWRzIGZvciBub3cuXG4gICAgICAgIGlmICh0b2tlbi5mb2xsb3dlZEJ5IHx8IHRva2VuLm5vdEZvbGxvd2VkQnkpIHsgcmV0dXJuICcnOyB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHBsYWNlaG9sZGVyIHVudGlsIGdyb3VwIHN0cmluZyBpcyBnZW5lcmF0ZWQuXG4gICAgICAgIGlmICh0b2tlbi5yZW1lbWJlciAmJiB0b2tlbi5ncm91cE51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdG9rZW4uZ3JvdXBOdW1iZXIgPSBncm91cHMucHVzaChudWxsKSAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFjayA9IHRva2VuLm9wdGlvbnMgP1xuICAgICAgICAgIHRoaXMuX3JhbmRTZWxlY3QodG9rZW4ub3B0aW9ucykgOiB0b2tlbi5zdGFjaztcblxuICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHN0ciArPSB0aGlzLl9nZW4oc3RhY2tbaV0sIGdyb3Vwcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4ucmVtZW1iZXIpIHtcbiAgICAgICAgICBncm91cHNbdG9rZW4uZ3JvdXBOdW1iZXJdID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG5cbiAgICAgIGNhc2UgdHlwZXMuUE9TSVRJT046XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIG5vdy5cbiAgICAgICAgcmV0dXJuICcnO1xuXG4gICAgICBjYXNlIHR5cGVzLlNFVDpcbiAgICAgICAgdmFyIGV4cGFuZGVkU2V0ID0gdGhpcy5fZXhwYW5kKHRva2VuKTtcbiAgICAgICAgaWYgKCFleHBhbmRlZFNldC5sZW5ndGgpIHsgcmV0dXJuICcnOyB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuX3JhbmRTZWxlY3QoZXhwYW5kZWRTZXQpKTtcblxuICAgICAgY2FzZSB0eXBlcy5SRVBFVElUSU9OOlxuICAgICAgICAvLyBSYW5kb21seSBnZW5lcmF0ZSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cbiAgICAgICAgbiA9IHRoaXMucmFuZEludCh0b2tlbi5taW4sXG4gICAgICAgICAgdG9rZW4ubWF4ID09PSBJbmZpbml0eSA/IHRva2VuLm1pbiArIHRoaXMubWF4IDogdG9rZW4ubWF4KTtcblxuICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHN0ciArPSB0aGlzLl9nZW4odG9rZW4udmFsdWUsIGdyb3Vwcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuXG4gICAgICBjYXNlIHR5cGVzLlJFRkVSRU5DRTpcbiAgICAgICAgcmV0dXJuIGdyb3Vwc1t0b2tlbi52YWx1ZSAtIDFdIHx8ICcnO1xuXG4gICAgICBjYXNlIHR5cGVzLkNIQVI6XG4gICAgICAgIHZhciBjb2RlID0gdGhpcy5pZ25vcmVDYXNlICYmIHRoaXMuX3JhbmRCb29sKCkgP1xuICAgICAgICAgIHRoaXMuX3RvT3RoZXJDYXNlKHRva2VuLnZhbHVlKSA6IHRva2VuLnZhbHVlO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBJZiBjb2RlIGlzIGFscGhhYmV0aWMsIGNvbnZlcnRzIHRvIG90aGVyIGNhc2UuXG4gICAqIElmIG5vdCBhbHBoYWJldGljLCByZXR1cm5zIGJhY2sgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX3RvT3RoZXJDYXNlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSArICg5NyA8PSBjb2RlICYmIGNvZGUgPD0gMTIyID8gLTMyIDpcbiAgICAgIDY1IDw9IGNvZGUgJiYgY29kZSA8PSA5MCAgPyAgMzIgOiAwKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJhbmRvbWx5IHJldHVybnMgYSB0cnVlIG9yIGZhbHNlIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX3JhbmRCb29sKCkge1xuICAgIHJldHVybiAhdGhpcy5yYW5kSW50KDAsIDEpO1xuICB9XG5cblxuICAvKipcbiAgICogUmFuZG9tbHkgc2VsZWN0cyBhbmQgcmV0dXJucyBhIHZhbHVlIGZyb20gdGhlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBhcnJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX3JhbmRTZWxlY3QoYXJyKSB7XG4gICAgaWYgKGFyciBpbnN0YW5jZW9mIERSYW5nZSkge1xuICAgICAgcmV0dXJuIGFyci5pbmRleCh0aGlzLnJhbmRJbnQoMCwgYXJyLmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyclt0aGlzLnJhbmRJbnQoMCwgYXJyLmxlbmd0aCAtIDEpXTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGV4cGFuZHMgYSB0b2tlbiB0byBhIERpc2NvbnRpbnVvdXNSYW5nZSBvZiBjaGFyYWN0ZXJzIHdoaWNoIGhhcyBhXG4gICAqIGxlbmd0aCBhbmQgYW4gaW5kZXggZnVuY3Rpb24gKGZvciByYW5kb20gc2VsZWN0aW5nKVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAgICogQHJldHVybiB7RGlzY29udGludW91c1JhbmdlfVxuICAgKi9cbiAgX2V4cGFuZCh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlID09PSByZXQudHlwZXMuQ0hBUikge1xuICAgICAgcmV0dXJuIG5ldyBEUmFuZ2UodG9rZW4udmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gcmV0LnR5cGVzLlJBTkdFKSB7XG4gICAgICByZXR1cm4gbmV3IERSYW5nZSh0b2tlbi5mcm9tLCB0b2tlbi50byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkcmFuZ2UgPSBuZXcgRFJhbmdlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3VicmFuZ2UgPSB0aGlzLl9leHBhbmQodG9rZW4uc2V0W2ldKTtcbiAgICAgICAgZHJhbmdlLmFkZChzdWJyYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN1YnJhbmdlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgY29kZSA9IHN1YnJhbmdlLmluZGV4KGopO1xuICAgICAgICAgICAgbGV0IG90aGVyQ2FzZUNvZGUgPSB0aGlzLl90b090aGVyQ2FzZShjb2RlKTtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBvdGhlckNhc2VDb2RlKSB7XG4gICAgICAgICAgICAgIGRyYW5nZS5hZGQob3RoZXJDYXNlQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4ubm90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSYW5nZS5jbG9uZSgpLnN1YnRyYWN0KGRyYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmFuZ2UuY2xvbmUoKS5pbnRlcnNlY3QoZHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSYW5kb21seSBnZW5lcmF0ZXMgYW5kIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiBhIGFuZCBiIChpbmNsdXNpdmUpLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICByYW5kSW50KGEsIGIpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgxICsgYiAtIGEpKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcmFuZ2Ugb2YgY2hhcmFjdGVycyB0byBnZW5lcmF0ZSBmcm9tLlxuICAgKi9cbiAgZ2V0IGRlZmF1bHRSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCBuZXcgRFJhbmdlKDMyLCAxMjYpO1xuICB9XG5cbiAgc2V0IGRlZmF1bHRSYW5nZShyYW5nZSkge1xuICAgIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKlxuICAgKiBFbmFibGVzIHVzZSBvZiByYW5kZXhwIHdpdGggYSBzaG9ydGVyIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ3wgcmVnZXhwfVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcmFuZGV4cChyZWdleHAsIG0pIHtcbiAgICB2YXIgcmFuZGV4cDtcbiAgICBpZih0eXBlb2YgcmVnZXhwID09PSAnc3RyaW5nJykge1xuICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cChyZWdleHAsIG0pO1xuICAgIH1cblxuICAgIGlmIChyZWdleHAuX3JhbmRleHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmFuZGV4cCA9IG5ldyBSYW5kRXhwKHJlZ2V4cCwgbSk7XG4gICAgICByZWdleHAuX3JhbmRleHAgPSByYW5kZXhwO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5kZXhwID0gcmVnZXhwLl9yYW5kZXhwO1xuICAgICAgcmFuZGV4cC5fc2V0RGVmYXVsdHMocmVnZXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmRleHAuZ2VuKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHN1Z2FyeSAvcmVnZXhwLy5nZW4gc3ludGF4LlxuICAgKi9cbiAgc3RhdGljIHN1Z2FyKCkge1xuICAgIC8qIGVzaGludCBmcmVlemU6ZmFsc2UgKi9cbiAgICBSZWdFeHAucHJvdG90eXBlLmdlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFJhbmRFeHAucmFuZGV4cCh0aGlzKTtcbiAgICB9O1xuICB9XG59O1xuIiwiaW1wb3J0IFJhbmRFeHAgZnJvbSAncmFuZGV4cCc7XG5cbmltcG9ydCBvcHRpb25BUEkgZnJvbSAnLi4vYXBpL29wdGlvbic7XG5pbXBvcnQgZW52IGZyb20gJy4vY29uc3RhbnRzJztcblxuZnVuY3Rpb24gZ2V0UmFuZG9tSW50ZWdlcihtaW4sIG1heCkge1xuICBtaW4gPSB0eXBlb2YgbWluID09PSAndW5kZWZpbmVkJyA/IGVudi5NSU5fSU5URUdFUiA6IG1pbjtcbiAgbWF4ID0gdHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgPyBlbnYuTUFYX0lOVEVHRVIgOiBtYXg7XG5cbiAgcmV0dXJuIE1hdGguZmxvb3Iob3B0aW9uQVBJKCdyYW5kb20nKSgpICogKChtYXggLSBtaW4pICsgMSkpICsgbWluO1xufVxuXG5mdW5jdGlvbiBfcmFuZGV4cCh2YWx1ZSkge1xuICAvLyBzZXQgbWF4aW11bSBkZWZhdWx0LCBzZWUgIzE5M1xuICBSYW5kRXhwLnByb3RvdHlwZS5tYXggPSBvcHRpb25BUEkoJ2RlZmF1bHRSYW5kRXhwTWF4Jyk7XG5cbiAgLy8gc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyB0aGUgb3JpZ2luYWwgZXhjZXB0IHVzaW5nIG91ciByYW5kb21cbiAgUmFuZEV4cC5wcm90b3R5cGUucmFuZEludCA9IChhLCBiKSA9PiBhICsgTWF0aC5mbG9vcihvcHRpb25BUEkoJ3JhbmRvbScpKCkgKiAoMSArIChiIC0gYSkpKTtcblxuICBjb25zdCByZSA9IG5ldyBSYW5kRXhwKHZhbHVlKTtcblxuICByZXR1cm4gcmUuZ2VuKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyByYW5kb20gZWxlbWVudCBvZiBhIGNvbGxlY3Rpb25cbiAqXG4gKiBAcGFyYW0gY29sbGVjdGlvblxuICogQHJldHVybnMge1R9XG4gKi9cbmZ1bmN0aW9uIHBpY2soY29sbGVjdGlvbikge1xuICByZXR1cm4gY29sbGVjdGlvbltNYXRoLmZsb29yKG9wdGlvbkFQSSgncmFuZG9tJykoKSAqIGNvbGxlY3Rpb24ubGVuZ3RoKV07XG59XG5cbi8qKlxuICogUmV0dXJucyBzaHVmZmxlZCBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtIGNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtUW119XG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICBsZXQgdG1wO1xuICBsZXQga2V5O1xuICBsZXQgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgY29uc3QgY29weSA9IGNvbGxlY3Rpb24uc2xpY2UoKTtcblxuICBmb3IgKDsgbGVuZ3RoID4gMDspIHtcbiAgICBrZXkgPSBNYXRoLmZsb29yKG9wdGlvbkFQSSgncmFuZG9tJykoKSAqIGxlbmd0aCk7XG4gICAgLy8gc3dhcFxuICAgIGxlbmd0aCAtPSAxO1xuICAgIHRtcCA9IGNvcHlbbGVuZ3RoXTtcbiAgICBjb3B5W2xlbmd0aF0gPSBjb3B5W2tleV07XG4gICAgY29weVtrZXldID0gdG1wO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gKGluY2x1c2l2ZSkgYW5kIG1heCAoaW5jbHVzaXZlKVxuICogVXNpbmcgTWF0aC5yb3VuZCgpIHdpbGwgZ2l2ZSB5b3UgYSBub24tdW5pZm9ybSBkaXN0cmlidXRpb24hXG4gKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1Mjc4MjAvNzY5Mzg0XG4gKi9cbmZ1bmN0aW9uIGdldFJhbmRvbShtaW4sIG1heCkge1xuICByZXR1cm4gKG9wdGlvbkFQSSgncmFuZG9tJykoKSAqIChtYXggLSBtaW4pKSArIG1pbjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9tIG51bWJlciBhY2NvcmRpbmcgdG8gcGFyYW1ldGVycyBwYXNzZWRcbiAqXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKiBAcGFyYW0gZGVmTWluXG4gKiBAcGFyYW0gZGVmTWF4XG4gKiBAcGFyYW0gaGFzUHJlY2lzaW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBudW1iZXIobWluLCBtYXgsIGRlZk1pbiwgZGVmTWF4LCBoYXNQcmVjaXNpb24gPSBmYWxzZSkge1xuICBkZWZNaW4gPSB0eXBlb2YgZGVmTWluID09PSAndW5kZWZpbmVkJyA/IGVudi5NSU5fTlVNQkVSIDogZGVmTWluO1xuICBkZWZNYXggPSB0eXBlb2YgZGVmTWF4ID09PSAndW5kZWZpbmVkJyA/IGVudi5NQVhfTlVNQkVSIDogZGVmTWF4O1xuXG4gIG1pbiA9IHR5cGVvZiBtaW4gPT09ICd1bmRlZmluZWQnID8gZGVmTWluIDogbWluO1xuICBtYXggPSB0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJyA/IGRlZk1heCA6IG1heDtcblxuICBpZiAobWF4IDwgbWluKSB7XG4gICAgbWF4ICs9IG1pbjtcbiAgfVxuXG4gIGlmIChoYXNQcmVjaXNpb24pIHtcbiAgICByZXR1cm4gZ2V0UmFuZG9tKG1pbiwgbWF4KTtcbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21JbnRlZ2VyKG1pbiwgbWF4KTtcbn1cblxuZnVuY3Rpb24gYnkodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICAgIHJldHVybiBudW1iZXIoMCwgNjApICogNjA7XG5cbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgIHJldHVybiBudW1iZXIoMTUsIDUwKSAqIDYxMjtcblxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgIHJldHVybiBudW1iZXIoMTIsIDcyKSAqIDM2MTIzO1xuXG4gICAgY2FzZSAnZGF5cyc6XG4gICAgICByZXR1cm4gbnVtYmVyKDcsIDMwKSAqIDg2NDEyMzQ1O1xuXG4gICAgY2FzZSAnd2Vla3MnOlxuICAgICAgcmV0dXJuIG51bWJlcig0LCA1MikgKiA2MDQ4MTIzNDU7XG5cbiAgICBjYXNlICdtb250aHMnOlxuICAgICAgcmV0dXJuIG51bWJlcigyLCAxMykgKiAyNTkyMDEyMzQ1O1xuXG4gICAgY2FzZSAneWVhcnMnOlxuICAgICAgcmV0dXJuIG51bWJlcigxLCAyMCkgKiAzMTEwNDAxMjM0NTtcblxuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGUoc3RlcCkge1xuICBpZiAoc3RlcCkge1xuICAgIHJldHVybiBieShzdGVwKTtcbiAgfVxuXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGRheXMgPSBudW1iZXIoLTEwMDAsIGVudi5NT1NUX05FQVJfREFURVRJTUUpO1xuXG4gIG5vdy5zZXRUaW1lKG5vdy5nZXRUaW1lKCkgLSBkYXlzKTtcblxuICByZXR1cm4gbm93O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHBpY2ssXG4gIGRhdGUsXG4gIHNodWZmbGUsXG4gIG51bWJlcixcbiAgcmFuZGV4cDogX3JhbmRleHAsXG59O1xuIiwiaW1wb3J0IG9wdGlvbkFQSSBmcm9tICcuLi9hcGkvb3B0aW9uJztcbmltcG9ydCBlbnYgZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHJhbmRvbSBmcm9tICcuL3JhbmRvbSc7XG5cbmZ1bmN0aW9uIGdldExvY2FsUmVmKG9iaiwgcGF0aCwgcmVmcykge1xuICBjb25zdCBrZXlFbGVtZW50cyA9IHBhdGgucmVwbGFjZSgnIy8nLCAnLycpLnNwbGl0KCcvJyk7XG5cbiAgbGV0IHNjaGVtYSA9IG9iai4kcmVmICYmIHJlZnMgPyByZWZzW29iai4kcmVmXSA6IG9iajtcbiAgaWYgKHJlZnMgJiYgcGF0aC5pbmNsdWRlcygnIy8nKSAmJiByZWZzW2tleUVsZW1lbnRzWzBdXSkge1xuICAgIHNjaGVtYSA9IHJlZnNba2V5RWxlbWVudHMuc2hpZnQoKV07XG4gIH1cblxuICBpZiAoIWtleUVsZW1lbnRzWzBdKSBrZXlFbGVtZW50cy5zaGlmdCgpO1xuXG4gIHdoaWxlIChzY2hlbWEgJiYga2V5RWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHByb3AgPSBrZXlFbGVtZW50cy5zaGlmdCgpO1xuXG4gICAgaWYgKCFzY2hlbWFbcHJvcF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcCBub3QgZm91bmQ6ICR7cHJvcH0gKCR7cGF0aH0pYCk7XG4gICAgfVxuXG4gICAgc2NoZW1hID0gc2NoZW1hW3Byb3BdO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlL2ZhbHNlIHdoZXRoZXIgdGhlIG9iamVjdCBwYXJhbWV0ZXIgaGFzIGl0cyBvd24gcHJvcGVydGllcyBkZWZpbmVkXG4gKlxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJ0aWVzKG9iaiwgLi4ucHJvcGVydGllcykge1xuICByZXR1cm4gcHJvcGVydGllcy5maWx0ZXIoa2V5ID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIG9ialtrZXldICE9PSAndW5kZWZpbmVkJztcbiAgfSkubGVuZ3RoID4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgZ2VuZXJhdGVkIGRhdGUgWVlZWS1NTS1ERCB0byBub3QgaGF2ZVxuICogb3V0IG9mIHJhbmdlIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2xhbXBEYXRlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZS5pbmNsdWRlcygnICcpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpLnN1YnN0cigwLCAxMCk7XG4gIH1cblxuICBsZXQgW3llYXIsIG1vbnRoLCBkYXldID0gdmFsdWUuc3BsaXQoJ1QnKVswXS5zcGxpdCgnLScpO1xuXG4gIG1vbnRoID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oMTIsIG1vbnRoKSk7XG4gIGRheSA9IE1hdGgubWF4KDEsIE1hdGgubWluKDMxLCBkYXkpKTtcblxuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHR5cGVjYXN0ZWQgdmFsdWUuXG4gKiBFeHRlcm5hbCBnZW5lcmF0b3JzIChmYWtlciwgY2hhbmNlLCBjYXN1YWwpIG1heSByZXR1cm4gZGF0YSBpbiBub24tZXhwZWN0ZWQgZm9ybWF0cywgc3VjaCBhcyBzdHJpbmcsIHdoZW4geW91IG1pZ2h0IGV4cGVjdCBhblxuICogaW50ZWdlci4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGZvcmNlIHRoZSB0eXBlY2FzdC4gVGhpcyBpcyB0aGUgYmFzZSBmb3JtYXR0ZXIgZm9yIGFsbCByZXN1bHQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIHR5cGVjYXN0KHR5cGUsIHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgLy8gbm9ybWFsaXplIGNvbnN0cmFpbnRzXG4gIHN3aXRjaCAodHlwZSB8fCBzY2hlbWEudHlwZSkge1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5pbXVtICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMubWluaW11bSA9IHNjaGVtYS5taW5pbXVtO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXhpbXVtICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMubWF4aW11bSA9IHNjaGVtYS5tYXhpbXVtO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hLmVudW0pIHtcbiAgICAgICAgbGV0IG1pbiA9IE1hdGgubWF4KHBhcmFtcy5taW5pbXVtIHx8IDAsIDApO1xuICAgICAgICBsZXQgbWF4ID0gTWF0aC5taW4ocGFyYW1zLm1heGltdW0gfHwgSW5maW5pdHksIEluZmluaXR5KTtcblxuICAgICAgICBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gJiYgbWluID09PSBzY2hlbWEubWluaW11bSkge1xuICAgICAgICAgIG1pbiArPSBzY2hlbWEubXVsdGlwbGVPZiB8fCAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtICYmIG1heCA9PT0gc2NoZW1hLm1heGltdW0pIHtcbiAgICAgICAgICBtYXggLT0gc2NoZW1hLm11bHRpcGxlT2YgfHwgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpc2NhcmQgb3V0LW9mLWJvdW5kcyBlbnVtZXJhdGlvbnNcbiAgICAgICAgaWYgKG1pbiB8fCBtYXggIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgc2NoZW1hLmVudW0gPSBzY2hlbWEuZW51bS5maWx0ZXIoeCA9PiB7XG4gICAgICAgICAgICBpZiAoeCA+PSBtaW4gJiYgeCA8PSBtYXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgIHBhcmFtcy5taW5MZW5ndGggPSBvcHRpb25BUEkoJ21pbkxlbmd0aCcpIHx8IDA7XG4gICAgICBwYXJhbXMubWF4TGVuZ3RoID0gb3B0aW9uQVBJKCdtYXhMZW5ndGgnKSB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWluTGVuZ3RoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMubWluTGVuZ3RoID0gTWF0aC5tYXgocGFyYW1zLm1pbkxlbmd0aCwgc2NoZW1hLm1pbkxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heExlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyYW1zLm1heExlbmd0aCA9IE1hdGgubWluKHBhcmFtcy5tYXhMZW5ndGgsIHNjaGVtYS5tYXhMZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiBicmVhaztcbiAgfVxuXG4gIC8vIGV4ZWN1dGUgZ2VuZXJhdG9yXG4gIGxldCB2YWx1ZSA9IGNhbGxiYWNrKHBhcmFtcyk7XG5cbiAgLy8gYWxsb3cgbnVsbCB2YWx1ZXMgdG8gYmUgcmV0dXJuZWRcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBvdXRwdXQgdmFsdWVcbiAgc3dpdGNoICh0eXBlIHx8IHNjaGVtYS50eXBlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1heChwYXJhbXMubWluTGVuZ3RoIHx8IDAsIDApO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4ocGFyYW1zLm1heExlbmd0aCB8fCBJbmZpbml0eSwgSW5maW5pdHkpO1xuXG4gICAgICBsZXQgcHJldjtcbiAgICAgIGxldCBub0NoYW5nZUNvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IG1pbikge1xuICAgICAgICBwcmV2ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKCFzY2hlbWEucGF0dGVybikge1xuICAgICAgICAgIHZhbHVlICs9IGAke3JhbmRvbS5waWNrKFsnICcsICcvJywgJ18nLCAnLScsICcrJywgJz0nLCAnQCcsICdeJ10pfSR7dmFsdWV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSArPSByYW5kb20ucmFuZGV4cChzY2hlbWEucGF0dGVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdm9pZCBpbmZpbml0ZS1sb29wcyB3aGlsZSBmaWxsaW5nIHN0cmluZ3MsIGlmIG5vIGNoYW5nZXNcbiAgICAgICAgLy8gYXJlIG1hZGUgd2UganVzdCBicmVhayB0aGUgbG9vcC4uLiBzZWUgIzU0MFxuICAgICAgICBpZiAodmFsdWUgPT09IHByZXYpIHtcbiAgICAgICAgICBub0NoYW5nZUNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKG5vQ2hhbmdlQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub0NoYW5nZUNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gbWF4KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIG1heCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICBjYXNlICdkYXRlLXRpbWUnOlxuICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShjbGFtcERhdGUodmFsdWUpKS50b0lTT1N0cmluZygpLnJlcGxhY2UoLyhbMC05XSkwK1okLywgJyQxWicpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Z1bGwtZGF0ZSc6XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoY2xhbXBEYXRlKHZhbHVlKSkudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwgMTApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoYDE5NjktMDEtMDEgJHt2YWx1ZX1gKS50b0lTT1N0cmluZygpLnN1YnN0cigxMSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gIE9iamVjdC5rZXlzKGIpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAodHlwZW9mIGJba2V5XSAhPT0gJ29iamVjdCcgfHwgYltrZXldID09PSBudWxsKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJba2V5XSkpIHtcbiAgICAgIGFba2V5XSA9IGFba2V5XSB8fCBbXTtcbiAgICAgIC8vIGZpeCAjMjkyIC0gc2tpcCBkdXBsaWNhdGVkIHZhbHVlcyBmcm9tIG1lcmdlIG9iamVjdCAoYilcbiAgICAgIGJba2V5XS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYVtrZXldKSAmJiBhW2tleV0uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgYVtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhW2tleV0gIT09ICdvYmplY3QnIHx8IGFba2V5XSA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGFba2V5XSkpIHtcbiAgICAgIGFba2V5XSA9IG1lcmdlKHt9LCBiW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSBtZXJnZShhW2tleV0sIGJba2V5XSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY2xvbmUob2JqLCBjYWNoZSA9IG5ldyBNYXAoKSkge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgY2FjaGUuc2V0KG9iaiwgYXJyKTtcblxuICAgIGFyci5wdXNoKC4uLm9iai5tYXAoeCA9PiBjbG9uZSh4LCBjYWNoZSkpKTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgY29uc3QgY2xvbmVkT2JqID0ge307XG4gIGNhY2hlLnNldChvYmosIGNsb25lZE9iaik7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChwcmV2LCBjdXIpID0+IHtcbiAgICBwcmV2W2N1cl0gPSBjbG9uZShvYmpbY3VyXSwgY2FjaGUpO1xuICAgIHJldHVybiBwcmV2O1xuICB9LCBjbG9uZWRPYmopO1xufVxuXG5mdW5jdGlvbiBzaG9ydChzY2hlbWEpIHtcbiAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KHNjaGVtYSk7XG4gIGNvbnN0IGwgPSBKU09OLnN0cmluZ2lmeShzY2hlbWEsIG51bGwsIDIpO1xuXG4gIHJldHVybiBzLmxlbmd0aCA+IDQwMCA/IGAke2wuc3Vic3RyKDAsIDQwMCl9Li4uYCA6IGw7XG59XG5cbmZ1bmN0aW9uIGFueVZhbHVlKCkge1xuICByZXR1cm4gcmFuZG9tLnBpY2soW1xuICAgIGZhbHNlLFxuICAgIHRydWUsXG4gICAgbnVsbCxcbiAgICAtMSxcbiAgICBOYU4sXG4gICAgTWF0aC5QSSxcbiAgICBJbmZpbml0eSxcbiAgICB1bmRlZmluZWQsXG4gICAgW10sXG4gICAge30sXG4gICAgLy8gRklYTUU6IHVzZSBidWlsdC1pbiByYW5kb20/XG4gICAgTWF0aC5yYW5kb20oKSxcbiAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiksXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBub3RWYWx1ZShzY2hlbWEsIHBhcmVudCkge1xuICBjb25zdCBjb3B5ID0gbWVyZ2Uoe30sIHBhcmVudCk7XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEubWluaW11bSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb3B5Lm1heGltdW0gPSBzY2hlbWEubWluaW11bTtcbiAgICBjb3B5LmV4Y2x1c2l2ZU1heGltdW0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEubWF4aW11bSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb3B5Lm1pbmltdW0gPSBzY2hlbWEubWF4aW11bSA+IGNvcHkubWF4aW11bSA/IDAgOiBzY2hlbWEubWF4aW11bTtcbiAgICBjb3B5LmV4Y2x1c2l2ZU1pbmltdW0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEubWluTGVuZ3RoICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvcHkubWF4TGVuZ3RoID0gc2NoZW1hLm1pbkxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hLm1heExlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb3B5Lm1pbkxlbmd0aCA9IHNjaGVtYS5tYXhMZW5ndGggPiBjb3B5Lm1heExlbmd0aCA/IDAgOiBzY2hlbWEubWF4TGVuZ3RoO1xuICB9XG5cbiAgaWYgKHNjaGVtYS50eXBlKSB7XG4gICAgY29weS50eXBlID0gcmFuZG9tLnBpY2soZW52LlNDQUxBUl9UWVBFUy5maWx0ZXIoeCA9PiB7XG4gICAgICBjb25zdCB0eXBlcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpID8gc2NoZW1hLnR5cGUgOiBbc2NoZW1hLnR5cGVdO1xuXG4gICAgICByZXR1cm4gdHlwZXMuZXZlcnkodHlwZSA9PiB7XG4gICAgICAgIC8vIHRyZWF0IGJvdGggdHlwZXMgYXMgX3NpbWlsYXIgZW5vdWdoXyB0byBiZSBza2lwcGVkIGVxdWFsXG4gICAgICAgIGlmICh4ID09PSAnbnVtYmVyJyB8fCB4ID09PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2ludGVnZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHggIT09IHR5cGU7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLmVudW0pIHtcbiAgICBsZXQgdmFsdWU7XG5cbiAgICBkbyB7XG4gICAgICB2YWx1ZSA9IGFueVZhbHVlKCk7XG4gICAgfSB3aGlsZSAoc2NoZW1hLmVudW0uaW5kZXhPZih2YWx1ZSkgIT09IC0xKTtcblxuICAgIGNvcHkuZW51bSA9IFt2YWx1ZV07XG4gIH1cblxuICBpZiAoc2NoZW1hLnJlcXVpcmVkICYmIGNvcHkucHJvcGVydGllcykge1xuICAgIHNjaGVtYS5yZXF1aXJlZC5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgZGVsZXRlIGNvcHkucHJvcGVydGllc1twcm9wXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IGV4cGxvcmUgbW9yZSBzY2VuYXJpb3NcblxuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZUZvclNjaGVtYSh2YWx1ZSwgc2NoZW1hKSB7XG4gIGNvbnN0IHNjaGVtYUhhc01pbiA9IHNjaGVtYS5taW5pbXVtICE9PSB1bmRlZmluZWQ7XG4gIGNvbnN0IHNjaGVtYUhhc01heCA9IHNjaGVtYS5tYXhpbXVtICE9PSB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIChcbiAgICAoc2NoZW1hSGFzTWluIHx8IHNjaGVtYUhhc01heClcbiAgICAmJiAoIXNjaGVtYUhhc01pbiB8fCB2YWx1ZSA+PSBzY2hlbWEubWluaW11bSlcbiAgICAmJiAoIXNjaGVtYUhhc01heCB8fCB2YWx1ZSA8PSBzY2hlbWEubWF4aW11bSlcbiAgKTtcbn1cblxuLy8gRklYTUU6IGV2YWx1YXRlIG1vcmUgY29uc3RyYWludHM/XG5mdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgc2NoZW1hcykge1xuICByZXR1cm4gIXNjaGVtYXMuZXZlcnkoc2NoZW1hID0+IHZhbGlkYXRlVmFsdWVGb3JTY2hlbWEodmFsdWUsIHNjaGVtYSkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlRm9yT25lT2YodmFsdWUsIG9uZU9mKSB7XG4gIGNvbnN0IHZhbGlkQ291bnQgPSBvbmVPZi5yZWR1Y2UoKGNvdW50LCBzY2hlbWEpID0+IChjb3VudCArICgodmFsaWRhdGVWYWx1ZUZvclNjaGVtYSh2YWx1ZSwgc2NoZW1hKSkgPyAxIDogMCkpLCAwKTtcbiAgcmV0dXJuIHZhbGlkQ291bnQgPT09IDE7XG59XG5cbmZ1bmN0aW9uIGlzS2V5KHByb3ApIHtcbiAgcmV0dXJuIFsnZW51bScsICdjb25zdCcsICdkZWZhdWx0JywgJ2V4YW1wbGVzJywgJ3JlcXVpcmVkJywgJ2RlZmluaXRpb25zJywgJ2l0ZW1zJywgJ3Byb3BlcnRpZXMnXS5pbmNsdWRlcyhwcm9wKTtcbn1cblxuZnVuY3Rpb24gb21pdFByb3BzKG9iaiwgcHJvcHMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAuZmlsdGVyKGtleSA9PiAhcHJvcHMuaW5jbHVkZXMoa2V5KSlcbiAgICAucmVkdWNlKChjb3B5LCBrKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIGNvcHlba10gPSBvYmpba10uc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlba10gPSBvYmpba10gaW5zdGFuY2VvZiBPYmplY3RcbiAgICAgICAgICA/IG1lcmdlKHt9LCBvYmpba10pXG4gICAgICAgICAgOiBvYmpba107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGUodmFsdWUsIHNjaGVtYSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKHggPT4gdGVtcGxhdGUoeCwgc2NoZW1hKSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvI1xceyhbXFx3Li1dKylcXH0vZywgKF8sICQxKSA9PiBzY2hlbWFbJDFdKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5IChoYXMgbm8gcHJvcGVydGllcylcbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgZ2l2ZW4ga2V5IGlzIHJlcXVpcmVkIG9yIGlmIHNvdXJjZSBvYmplY3Qgd2FzIGNyZWF0ZWQgYnkgYSBzdWJyb3V0aW5lIChhbHJlYWR5IGNsZWFuZWQpXG4gKlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNob3VsZENsZWFuKGtleSwgc2NoZW1hKSB7XG4gIGNvbnN0IGlzUmVxdWlyZWQgPSBBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkgJiYgc2NoZW1hLnJlcXVpcmVkLmluY2x1ZGVzKGtleSk7XG4gIGNvbnN0IHdhc0NsZWFuZWQgPSB0eXBlb2Ygc2NoZW1hLnRodW5rID09PSAnZnVuY3Rpb24nIHx8IChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgdHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcy50aHVuayA9PT0gJ2Z1bmN0aW9uJyk7XG5cbiAgcmV0dXJuICFpc1JlcXVpcmVkICYmICF3YXNDbGVhbmVkO1xufVxuXG4vKipcbiAqIENsZWFucyB1cCB0aGUgc291cmNlIG9iamVjdCByZW1vdmluZyBlbXB0eSBvYmplY3RzIGFuZCB1bmRlZmluZWQgdmFsdWVzXG4gKiBXaWxsIG5vdCByZW1vdmUgdmFsdWVzIHdoaWNoIGFyZSBzcGVjaWZpZWQgYXMgYHJlcXVpcmVkYFxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBpc0FycmF5XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBjbGVhbihvYmosIHNjaGVtYSwgaXNBcnJheSA9IGZhbHNlKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqXG4gICAgICAubWFwKHZhbHVlID0+IGNsZWFuKHZhbHVlLCBzY2hlbWEsIHRydWUpKVxuICAgICAgLmZpbHRlcih2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrID0+IHtcbiAgICBpZiAoaXNFbXB0eShvYmpba10pKSB7XG4gICAgICBpZiAoc2hvdWxkQ2xlYW4oaywgc2NoZW1hKSkge1xuICAgICAgICBkZWxldGUgb2JqW2tdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNsZWFuKG9ialtrXSwgc2NoZW1hKTtcblxuICAgICAgaWYgKCFpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICBvYmpba10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmpba10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWxldGUgb2JqW2tdO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAmJiBpc0FycmF5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaGFzUHJvcGVydGllcyxcbiAgZ2V0TG9jYWxSZWYsXG4gIG9taXRQcm9wcyxcbiAgdHlwZWNhc3QsXG4gIG1lcmdlLFxuICBjbG9uZSxcbiAgc2hvcnQsXG4gIG5vdFZhbHVlLFxuICBhbnlWYWx1ZSxcbiAgdmFsaWRhdGUsXG4gIHZhbGlkYXRlVmFsdWVGb3JTY2hlbWEsXG4gIHZhbGlkYXRlVmFsdWVGb3JPbmVPZixcbiAgaXNLZXksXG4gIHRlbXBsYXRlLFxuICBzaG91bGRDbGVhbixcbiAgY2xlYW4sXG4gIGlzRW1wdHksXG4gIGNsYW1wRGF0ZSxcbn07XG4iLCJpbXBvcnQgdXRpbCBmcm9tICcuLi9jb3JlL3V0aWxzJztcblxuLy8gZHluYW1pYyBwcm94eSBmb3IgY3VzdG9tIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIHByb3h5KGdlbikge1xuICByZXR1cm4gKHZhbHVlLCBzY2hlbWEsIHByb3BlcnR5LCByb290U2NoZW1hKSA9PiB7XG4gICAgbGV0IGZuID0gdmFsdWU7XG4gICAgbGV0IGFyZ3MgPSBbXTtcblxuICAgIC8vIHN1cHBvcnQgZm9yIG5lc3RlZCBvYmplY3QsIGZpcnN0LWtleSBpcyB0aGUgZ2VuZXJhdG9yXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZuID0gT2JqZWN0LmtleXModmFsdWUpWzBdO1xuXG4gICAgICAvLyB0cmVhdCB0aGUgZ2l2ZW4gYXJyYXkgYXMgYXJndW1lbnRzLFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbZm5dKSkge1xuICAgICAgICAvLyBpZiB0aGUgZ2VuZXJhdG9yIGlzIGV4cGVjdGluZyBhcnJheXMgdGhleSBzaG91bGQgYmUgbmVzdGVkLCBlLmcuIGBbWzEsIDIsIDNdLCB0cnVlLCAuLi5dYFxuICAgICAgICBhcmdzID0gdmFsdWVbZm5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoKHZhbHVlW2ZuXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydCBmb3Iga2V5cGF0aHMsIGUuZy4gXCJpbnRlcm5ldC5lbWFpbFwiXG4gICAgY29uc3QgcHJvcHMgPSBmbi5zcGxpdCgnLicpO1xuXG4gICAgLy8gcmV0cmlldmUgYSBmcmVzaCBkZXBlbmRlbmN5XG4gICAgbGV0IGN0eCA9IGdlbigpO1xuXG4gICAgd2hpbGUgKHByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGN0eCA9IGN0eFtwcm9wcy5zaGlmdCgpXTtcbiAgICB9XG5cbiAgICAvLyByZXRyaWV2ZSBsYXN0IHZhbHVlIGZyb20gY29udGV4dCBvYmplY3RcbiAgICB2YWx1ZSA9IHR5cGVvZiBjdHggPT09ICdvYmplY3QnID8gY3R4W3Byb3BzWzBdXSA6IGN0eDtcblxuICAgIC8vIGludm9rZSBkeW5hbWljIGdlbmVyYXRvcnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KGN0eCwgYXJncy5tYXAoeCA9PiB1dGlsLnRlbXBsYXRlKHgsIHJvb3RTY2hlbWEpKSk7XG4gICAgfVxuXG4gICAgLy8gdGVzdCBmb3IgcGVuZGluZyBjYWxsYmFja3NcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgdmFsdWUgZm9yICcke3Byb3BlcnR5fTogJHtmbn0nLCBnaXZlbjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnRhaW5lciBpcyB1c2VkIHRvIHdyYXAgZXh0ZXJuYWwgZ2VuZXJhdG9ycyAoZmFrZXIsIGNoYW5jZSwgY2FzdWFsLCBldGMuKSBhbmQgaXRzIGRlcGVuZGVuY2llcy5cbiAqXG4gKiAtIGBqc2YuZXh0ZW5kKCdmYWtlcicpYCB3aWxsIGVuaGFuY2Ugb3IgZGVmaW5lIHRoZSBnaXZlbiBkZXBlbmRlbmN5LlxuICogLSBganNmLmRlZmluZSgnZmFrZXInKWAgd2lsbCBwcm92aWRlIHRoZSBcImZha2VyXCIga2V5d29yZCBzdXBwb3J0LlxuICpcbiAqIFJhbmRFeHAgaXMgbm90IGxvbmdlciBjb25zaWRlcmVkIGFuIFwiZXh0ZW5zaW9uXCIuXG4gKi9cbmNsYXNzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIGR5bmFtaWMgcmVxdWlyZXMgLSBoYW5kbGUgYWxsIGRlcGVuZGVuY2llc1xuICAgIC8vIHRoZXkgd2lsbCBOT1QgYmUgaW5jbHVkZWQgb24gdGhlIGJ1bmRsZVxuICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLnN1cHBvcnQgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIG5hbWVcbiAgICovXG4gIHJlc2V0KG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICAgIHRoaXMuc3VwcG9ydCA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5yZWdpc3RyeVtuYW1lXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnN1cHBvcnRbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGRlcGVuZGVuY3kgZ2l2ZW4gYnkgbmFtZVxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGV4dGVuZChuYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMucmVnaXN0cnlbbmFtZV0gPSBjYWxsYmFjayh0aGlzLnJlZ2lzdHJ5W25hbWVdKTtcblxuICAgIC8vIGJ1aWx0LWluIHByb3h5IChjYW4gYmUgb3ZlcnJpZGRlbilcbiAgICBpZiAoIXRoaXMuc3VwcG9ydFtuYW1lXSkge1xuICAgICAgdGhpcy5zdXBwb3J0W25hbWVdID0gcHJveHkoKCkgPT4gdGhpcy5yZWdpc3RyeVtuYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBrZXl3b3JkIHN1cHBvcnQgYnkgbmFtZVxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGRlZmluZShuYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMuc3VwcG9ydFtuYW1lXSA9IGNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVwZW5kZW5jeSBnaXZlbiBieSBuYW1lXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEByZXR1cm5zIHtEZXBlbmRlbmN5fVxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucmVnaXN0cnlbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoYCcke25hbWV9JyBkZXBlbmRlbmN5IGRvZXNuJ3QgZXhpc3QuYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgY3VzdG9tIGtleXdvcmRcbiAgICogQHBhcmFtIHNjaGVtYVxuICAgKi9cbiAgd3JhcChzY2hlbWEpIHtcbiAgICBpZiAoISgnZ2VuZXJhdGUnIGluIHNjaGVtYSkpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHt9O1xuXG4gICAgICBsZXQgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGNvbnN0IGZuID0ga2V5c1tsZW5ndGhdLnJlcGxhY2UoL154LS8sICcnKTtcbiAgICAgICAgY29uc3QgZ2VuID0gdGhpcy5zdXBwb3J0W2ZuXTtcblxuICAgICAgICBpZiAodHlwZW9mIGdlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWEsICdnZW5lcmF0ZScsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiAocm9vdFNjaGVtYSwga2V5KSA9PiBnZW4uY2FsbChjb250ZXh0LCBzY2hlbWFba2V5c1tsZW5ndGhdXSwgc2NoZW1hLCBrZXlzW2xlbmd0aF0sIHJvb3RTY2hlbWEsIGtleS5zbGljZSgpKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyO1xuIiwiaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL2NsYXNzL1JlZ2lzdHJ5JztcblxuLy8gaW5zdGFudGlhdGVcbmNvbnN0IHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KCk7XG5cbi8qKlxuICogQ3VzdG9tIGZvcm1hdCBBUElcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qc29uLXNjaGVtYS1mYWtlci9qc29uLXNjaGVtYS1mYWtlciNjdXN0b20tZm9ybWF0c1xuICogQHBhcmFtIG5hbWVPckZvcm1hdE1hcFxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBmb3JtYXRBUEkobmFtZU9yRm9ybWF0TWFwLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG5hbWVPckZvcm1hdE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcmVnaXN0cnkubGlzdCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBuYW1lT3JGb3JtYXRNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVnaXN0cnkucmVnaXN0ZXIobmFtZU9yRm9ybWF0TWFwLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gZmFsc2UpIHtcbiAgICAgIHJlZ2lzdHJ5LnVucmVnaXN0ZXIobmFtZU9yRm9ybWF0TWFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlZ2lzdHJ5LmdldChuYW1lT3JGb3JtYXRNYXApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWdpc3RyeS5yZWdpc3Rlck1hbnkobmFtZU9yRm9ybWF0TWFwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXRBUEk7XG4iLCJjbGFzcyBQYXJzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSAnUGFyc2VFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhcnNlRXJyb3I7XG4iLCJjb25zdCBpbmZlcnJlZFByb3BlcnRpZXMgPSB7XG4gIGFycmF5OiBbXG4gICAgJ2FkZGl0aW9uYWxJdGVtcycsXG4gICAgJ2l0ZW1zJyxcbiAgICAnbWF4SXRlbXMnLFxuICAgICdtaW5JdGVtcycsXG4gICAgJ3VuaXF1ZUl0ZW1zJyxcbiAgXSxcbiAgaW50ZWdlcjogW1xuICAgICdleGNsdXNpdmVNYXhpbXVtJyxcbiAgICAnZXhjbHVzaXZlTWluaW11bScsXG4gICAgJ21heGltdW0nLFxuICAgICdtaW5pbXVtJyxcbiAgICAnbXVsdGlwbGVPZicsXG4gIF0sXG4gIG9iamVjdDogW1xuICAgICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICAgJ2RlcGVuZGVuY2llcycsXG4gICAgJ21heFByb3BlcnRpZXMnLFxuICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICAncGF0dGVyblByb3BlcnRpZXMnLFxuICAgICdwcm9wZXJ0aWVzJyxcbiAgICAncmVxdWlyZWQnLFxuICBdLFxuICBzdHJpbmc6IFtcbiAgICAnbWF4TGVuZ3RoJyxcbiAgICAnbWluTGVuZ3RoJyxcbiAgICAncGF0dGVybicsXG4gICAgJ2Zvcm1hdCcsXG4gIF0sXG59O1xuXG5pbmZlcnJlZFByb3BlcnRpZXMubnVtYmVyID0gaW5mZXJyZWRQcm9wZXJ0aWVzLmludGVnZXI7XG5cbmNvbnN0IHN1YnNjaGVtYVByb3BlcnRpZXMgPSBbXG4gICdhZGRpdGlvbmFsSXRlbXMnLFxuICAnaXRlbXMnLFxuICAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAnZGVwZW5kZW5jaWVzJyxcbiAgJ3BhdHRlcm5Qcm9wZXJ0aWVzJyxcbiAgJ3Byb3BlcnRpZXMnLFxuXTtcblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBrZXlzIG9mIGBvYmpgIGFuZDpcbiAqIC0gY2hlY2tzIHdoZXRoZXIgdGhvc2Uga2V5cyBtYXRjaCBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gaW5mZXJyZWQgdHlwZVxuICogLSBtYWtlcyBzdXJlIHRoYXQgYG9iamAgaXMgbm90IGEgc3Vic2NoZW1hOyBfRG8gbm90IGF0dGVtcHQgdG8gaW5mZXIgcHJvcGVydGllcyBuYW1lZCBhcyBzdWJzY2hlbWEgY29udGFpbmVycy4gVGhlXG4gKiByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBhbnkgcHJvcGVydHkgbmFtZSB3aXRoaW4gdGhvc2UgY29udGFpbmVycyB0aGF0IG1hdGNoZXMgb25lIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgZm9yXG4gKiBpbmZlcnJpbmcgbWlzc2luZyB0eXBlIHZhbHVlcyBjYXVzZXMgdGhlIGNvbnRhaW5lciBpdHNlbGYgdG8gZ2V0IHByb2Nlc3NlZCB3aGljaCBsZWFkcyB0byBpbnZhbGlkIG91dHB1dC4gKElzc3VlIDYyKV9cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1R5cGUob2JqLCBsYXN0RWxlbWVudEluUGF0aCwgaW5mZXJyZWRUeXBlUHJvcGVydGllcykge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIocHJvcCA9PiB7XG4gICAgY29uc3QgaXNTdWJzY2hlbWEgPSBzdWJzY2hlbWFQcm9wZXJ0aWVzLmluZGV4T2YobGFzdEVsZW1lbnRJblBhdGgpID4gLTE7XG4gICAgY29uc3QgaW5mZXJyZWRQcm9wZXJ0eUZvdW5kID0gaW5mZXJyZWRUeXBlUHJvcGVydGllcy5pbmRleE9mKHByb3ApID4gLTE7XG5cbiAgICBpZiAoaW5mZXJyZWRQcm9wZXJ0eUZvdW5kICYmICFpc1N1YnNjaGVtYSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KS5sZW5ndGggPiAwO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIGBvYmpgIHR5cGUgbWlnaHQgYmUgaW5mZXJyZWQuIFRoZSBtZWNoYW5pc20gaXRlcmF0ZXMgdGhyb3VnaCBhbGwgaW5mZXJyZWQgdHlwZXMgZGVmaW5pdGlvbnMsXG4gKiB0cmllcyB0byBtYXRjaCBhbGxvd2VkIHByb3BlcnRpZXMgd2l0aCBwcm9wZXJ0aWVzIG9mIGdpdmVuIGBvYmpgLiBSZXR1cm5zIHR5cGUgbmFtZSwgaWYgaW5mZXJyZWQsIG9yIG51bGwuXG4gKlxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBpbmZlclR5cGUob2JqLCBzY2hlbWFQYXRoKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbmZlcnJlZFByb3BlcnRpZXMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHR5cGVOYW1lID0ga2V5c1tpXTtcbiAgICBjb25zdCBsYXN0RWxlbWVudEluUGF0aCA9IHNjaGVtYVBhdGhbc2NoZW1hUGF0aC5sZW5ndGggLSAxXTtcblxuICAgIGlmIChtYXRjaGVzVHlwZShvYmosIGxhc3RFbGVtZW50SW5QYXRoLCBpbmZlcnJlZFByb3BlcnRpZXNbdHlwZU5hbWVdKSkge1xuICAgICAgcmV0dXJuIHR5cGVOYW1lO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBpbmZlclR5cGU7XG4iLCJpbXBvcnQgb3B0aW9uQVBJIGZyb20gJy4uL2FwaS9vcHRpb24nO1xuXG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb21pemVkIGJvb2xlYW4gdmFsdWUuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW5HZW5lcmF0b3IoKSB7XG4gIHJldHVybiBvcHRpb25BUEkoJ3JhbmRvbScpKCkgPiAwLjU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJvb2xlYW5HZW5lcmF0b3I7XG4iLCJpbXBvcnQgYm9vbGVhbkdlbmVyYXRvciBmcm9tICcuLi9nZW5lcmF0b3JzL2Jvb2xlYW4nO1xuXG5jb25zdCBib29sZWFuVHlwZSA9IGJvb2xlYW5HZW5lcmF0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IGJvb2xlYW5UeXBlO1xuIiwiLyoqXG4gKiBHZW5lcmF0ZXMgbnVsbCB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJucyB7bnVsbH1cbiAqL1xuZnVuY3Rpb24gbnVsbEdlbmVyYXRvcigpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG51bGxHZW5lcmF0b3I7XG4iLCJpbXBvcnQgbnVsbEdlbmVyYXRvciBmcm9tICcuLi9nZW5lcmF0b3JzL251bGwnO1xuXG5jb25zdCBudWxsVHlwZSA9IG51bGxHZW5lcmF0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IG51bGxUeXBlO1xuIiwiaW1wb3J0IHJhbmRvbSBmcm9tICcuLi9jb3JlL3JhbmRvbSc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgUGFyc2VFcnJvciBmcm9tICcuLi9jb3JlL2Vycm9yJztcbmltcG9ydCBvcHRpb25BUEkgZnJvbSAnLi4vYXBpL29wdGlvbic7XG5cbi8vIFRPRE8gcHJvdmlkZSB0eXBlc1xuZnVuY3Rpb24gdW5pcXVlKHBhdGgsIGl0ZW1zLCB2YWx1ZSwgc2FtcGxlLCByZXNvbHZlLCB0cmF2ZXJzZUNhbGxiYWNrKSB7XG4gIGNvbnN0IHRtcCA9IFtdO1xuICBjb25zdCBzZWVuID0gW107XG5cbiAgZnVuY3Rpb24gd2FsayhvYmopIHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcblxuICAgIGlmIChzZWVuLmluZGV4T2YoanNvbikgPT09IC0xKSB7XG4gICAgICBzZWVuLnB1c2goanNvbik7XG4gICAgICB0bXAucHVzaChvYmopO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpdGVtcy5mb3JFYWNoKHdhbGspO1xuXG4gIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24/XG4gIGxldCBsaW1pdCA9IDEwMDtcblxuICB3aGlsZSAodG1wLmxlbmd0aCAhPT0gaXRlbXMubGVuZ3RoKSB7XG4gICAgaWYgKCF3YWxrKHRyYXZlcnNlQ2FsbGJhY2sodmFsdWUuaXRlbXMgfHwgc2FtcGxlLCBwYXRoLCByZXNvbHZlKSkpIHtcbiAgICAgIGxpbWl0IC09IDE7XG4gICAgfVxuXG4gICAgaWYgKCFsaW1pdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRtcDtcbn1cblxuLy8gVE9ETyBwcm92aWRlIHR5cGVzXG5mdW5jdGlvbiBhcnJheVR5cGUodmFsdWUsIHBhdGgsIHJlc29sdmUsIHRyYXZlcnNlQ2FsbGJhY2spIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBpZiAoISh2YWx1ZS5pdGVtcyB8fCB2YWx1ZS5hZGRpdGlvbmFsSXRlbXMpKSB7XG4gICAgaWYgKHV0aWxzLmhhc1Byb3BlcnRpZXModmFsdWUsICdtaW5JdGVtcycsICdtYXhJdGVtcycsICd1bmlxdWVJdGVtcycpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgbWlzc2luZyBpdGVtcyBmb3IgJHt1dGlscy5zaG9ydCh2YWx1ZSl9YCwgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLml0ZW1zKSkge1xuICAgIHJldHVybiB2YWx1ZS5pdGVtcy5tYXAoKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVN1YnBhdGggPSBwYXRoLmNvbmNhdChbJ2l0ZW1zJywga2V5XSk7XG5cbiAgICAgIHJldHVybiB0cmF2ZXJzZUNhbGxiYWNrKGl0ZW0sIGl0ZW1TdWJwYXRoLCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBtaW5JdGVtcyA9IHZhbHVlLm1pbkl0ZW1zO1xuICBsZXQgbWF4SXRlbXMgPSB2YWx1ZS5tYXhJdGVtcztcblxuICBjb25zdCBkZWZhdWx0TWluSXRlbXMgPSBvcHRpb25BUEkoJ21pbkl0ZW1zJyk7XG4gIGNvbnN0IGRlZmF1bHRNYXhJdGVtcyA9IG9wdGlvbkFQSSgnbWF4SXRlbXMnKTtcblxuICBpZiAoZGVmYXVsdE1pbkl0ZW1zKSB7XG4gICAgLy8gZml4IGJvdW5kYXJpZXNcbiAgICBtaW5JdGVtcyA9IHR5cGVvZiBtaW5JdGVtcyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gZGVmYXVsdE1pbkl0ZW1zXG4gICAgICA6IE1hdGgubWluKGRlZmF1bHRNaW5JdGVtcywgbWluSXRlbXMpO1xuICB9XG5cbiAgaWYgKGRlZmF1bHRNYXhJdGVtcykge1xuICAgIG1heEl0ZW1zID0gdHlwZW9mIG1heEl0ZW1zID09PSAndW5kZWZpbmVkJ1xuICAgICAgPyBkZWZhdWx0TWF4SXRlbXNcbiAgICAgIDogTWF0aC5taW4oZGVmYXVsdE1heEl0ZW1zLCBtYXhJdGVtcyk7XG5cbiAgICAvLyBEb24ndCBhbGxvdyB1c2VyIHRvIHNldCBtYXggaXRlbXMgYWJvdmUgb3VyIG1heGltdW1cbiAgICBpZiAobWF4SXRlbXMgJiYgbWF4SXRlbXMgPiBkZWZhdWx0TWF4SXRlbXMpIHtcbiAgICAgIG1heEl0ZW1zID0gZGVmYXVsdE1heEl0ZW1zO1xuICAgIH1cblxuICAgIC8vIERvbid0IGFsbG93IHVzZXIgdG8gc2V0IG1pbiBpdGVtcyBhYm92ZSBvdXIgbWF4aW11bVxuICAgIGlmIChtaW5JdGVtcyAmJiBtaW5JdGVtcyA+IGRlZmF1bHRNYXhJdGVtcykge1xuICAgICAgbWluSXRlbXMgPSBtYXhJdGVtcztcbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRpb25hbHNQcm9iYWJpbGl0eSA9IG9wdGlvbkFQSSgnYWx3YXlzRmFrZU9wdGlvbmFscycpID09PSB0cnVlID8gMS4wIDogb3B0aW9uQVBJKCdvcHRpb25hbHNQcm9iYWJpbGl0eScpO1xuICBjb25zdCBmaXhlZFByb2JhYmlsaXRpZXMgPSBvcHRpb25BUEkoJ2Fsd2F5c0Zha2VPcHRpb25hbHMnKSB8fCBvcHRpb25BUEkoJ2ZpeGVkUHJvYmFiaWxpdGllcycpIHx8IGZhbHNlO1xuXG4gIGxldCBsZW5ndGggPSByYW5kb20ubnVtYmVyKG1pbkl0ZW1zLCBtYXhJdGVtcywgMSwgNSk7XG5cbiAgaWYgKG9wdGlvbmFsc1Byb2JhYmlsaXR5ICE9PSBudWxsKSB7XG4gICAgbGVuZ3RoID0gTWF0aC5tYXgoZml4ZWRQcm9iYWJpbGl0aWVzXG4gICAgICA/IE1hdGgucm91bmQoKG1heEl0ZW1zIHx8IGxlbmd0aCkgKiBvcHRpb25hbHNQcm9iYWJpbGl0eSlcbiAgICAgIDogTWF0aC5hYnMocmFuZG9tLm51bWJlcihtaW5JdGVtcywgbWF4SXRlbXMpICogb3B0aW9uYWxzUHJvYmFiaWxpdHkpLCBtaW5JdGVtcyB8fCAwKTtcbiAgfVxuXG4gIC8vIFRPRE8gYmVsb3cgbG9va3MgYmFkLiBTaG91bGQgYWRkaXRpb25hbEl0ZW1zIGJlIGNvcGllZCBhcy1pcz9cbiAgY29uc3Qgc2FtcGxlID0gdHlwZW9mIHZhbHVlLmFkZGl0aW9uYWxJdGVtcyA9PT0gJ29iamVjdCcgPyB2YWx1ZS5hZGRpdGlvbmFsSXRlbXMgOiB7fTtcblxuICBmb3IgKGxldCBjdXJyZW50ID0gaXRlbXMubGVuZ3RoOyBjdXJyZW50IDwgbGVuZ3RoOyBjdXJyZW50ICs9IDEpIHtcbiAgICBjb25zdCBpdGVtU3VicGF0aCA9IHBhdGguY29uY2F0KFsnaXRlbXMnLCBjdXJyZW50XSk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRyYXZlcnNlQ2FsbGJhY2sodmFsdWUuaXRlbXMgfHwgc2FtcGxlLCBpdGVtU3VicGF0aCwgcmVzb2x2ZSk7XG5cbiAgICBpdGVtcy5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmNvbnRhaW5zICYmIGxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBpZHggPSByYW5kb20ubnVtYmVyKDAsIGxlbmd0aCAtIDEpO1xuXG4gICAgaXRlbXNbaWR4XSA9IHRyYXZlcnNlQ2FsbGJhY2sodmFsdWUuY29udGFpbnMsIHBhdGguY29uY2F0KFsnaXRlbXMnLCBpZHhdKSwgcmVzb2x2ZSk7XG4gIH1cblxuICBpZiAodmFsdWUudW5pcXVlSXRlbXMpIHtcbiAgICByZXR1cm4gdW5pcXVlKHBhdGguY29uY2F0KFsnaXRlbXMnXSksIGl0ZW1zLCB2YWx1ZSwgc2FtcGxlLCByZXNvbHZlLCB0cmF2ZXJzZUNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlUeXBlO1xuIiwiaW1wb3J0IHJhbmRvbSBmcm9tICcuLi9jb3JlL3JhbmRvbSc7XG5pbXBvcnQgZW52IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzJztcblxuZnVuY3Rpb24gbnVtYmVyVHlwZSh2YWx1ZSkge1xuICBsZXQgbWluID0gdHlwZW9mIHZhbHVlLm1pbmltdW0gPT09ICd1bmRlZmluZWQnID8gZW52Lk1JTl9JTlRFR0VSIDogdmFsdWUubWluaW11bTtcbiAgbGV0IG1heCA9IHR5cGVvZiB2YWx1ZS5tYXhpbXVtID09PSAndW5kZWZpbmVkJyA/IGVudi5NQVhfSU5URUdFUiA6IHZhbHVlLm1heGltdW07XG5cbiAgY29uc3QgbXVsdGlwbGVPZiA9IHZhbHVlLm11bHRpcGxlT2Y7XG5cbiAgaWYgKG11bHRpcGxlT2YpIHtcbiAgICBtYXggPSBNYXRoLmZsb29yKG1heCAvIG11bHRpcGxlT2YpICogbXVsdGlwbGVPZjtcbiAgICBtaW4gPSBNYXRoLmNlaWwobWluIC8gbXVsdGlwbGVPZikgKiBtdWx0aXBsZU9mO1xuICB9XG5cbiAgaWYgKHZhbHVlLmV4Y2x1c2l2ZU1pbmltdW0gJiYgbWluID09PSB2YWx1ZS5taW5pbXVtKSB7XG4gICAgbWluICs9IG11bHRpcGxlT2YgfHwgMTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5leGNsdXNpdmVNYXhpbXVtICYmIG1heCA9PT0gdmFsdWUubWF4aW11bSkge1xuICAgIG1heCAtPSBtdWx0aXBsZU9mIHx8IDE7XG4gIH1cblxuICBpZiAobWluID4gbWF4KSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIGlmIChtdWx0aXBsZU9mKSB7XG4gICAgaWYgKFN0cmluZyhtdWx0aXBsZU9mKS5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICBsZXQgYmFzZSA9IHJhbmRvbS5udW1iZXIoTWF0aC5mbG9vcihtaW4gLyBtdWx0aXBsZU9mKSwgTWF0aC5mbG9vcihtYXggLyBtdWx0aXBsZU9mKSkgKiBtdWx0aXBsZU9mO1xuXG4gICAgICB3aGlsZSAoYmFzZSA8IG1pbikge1xuICAgICAgICBiYXNlICs9IHZhbHVlLm11bHRpcGxlT2Y7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJvdW5kYXJ5ID0gKG1heCAtIG1pbikgLyBtdWx0aXBsZU9mO1xuXG4gICAgbGV0IG51bTtcbiAgICBsZXQgZml4O1xuXG4gICAgZG8ge1xuICAgICAgbnVtID0gcmFuZG9tLm51bWJlcigwLCBib3VuZGFyeSkgKiBtdWx0aXBsZU9mO1xuICAgICAgZml4ID0gKG51bSAvIG11bHRpcGxlT2YpICUgMTtcbiAgICB9IHdoaWxlIChmaXggIT09IDApO1xuXG4gICAgLy8gRklYTUU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc29uLXNjaGVtYS1mYWtlci9qc29uLXNjaGVtYS1mYWtlci9pc3N1ZXMvMzc5XG5cbiAgICByZXR1cm4gbWluICsgbnVtO1xuICB9XG5cbiAgcmV0dXJuIHJhbmRvbS5udW1iZXIobWluLCBtYXgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbnVtYmVyVHlwZTtcbiIsImltcG9ydCBudW1iZXIgZnJvbSAnLi9udW1iZXInO1xuXG4vLyBUaGUgYGludGVnZXJgIHR5cGUgaXMganVzdCBhIHdyYXBwZXIgZm9yIHRoZSBgbnVtYmVyYCB0eXBlLiBUaGUgYG51bWJlcmAgdHlwZVxuLy8gcmV0dXJucyBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBhbmQgYGludGVnZXJgIHR5cGUgdHJ1bmNhdGVzIHRoZSBmcmFjdGlvblxuLy8gcGFydCwgbGVhdmluZyB0aGUgcmVzdWx0IGFzIGFuIGludGVnZXIuXG5cbmZ1bmN0aW9uIGludGVnZXJUeXBlKHZhbHVlKSB7XG4gIHJldHVybiBudW1iZXIoeyBtdWx0aXBsZU9mOiAxLCAuLi52YWx1ZSB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW50ZWdlclR5cGU7XG4iLCJpbXBvcnQgcmFuZG9tIGZyb20gJy4uL2NvcmUvcmFuZG9tJztcblxuY29uc3QgTElQU1VNX1dPUkRTID0gYExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlXG5ldCBkb2xvcmUgbWFnbmEgYWxpcXVhIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYVxuY29tbW9kbyBjb25zZXF1YXQgRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGFcbnBhcmlhdHVyIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3RcbmxhYm9ydW1gLnNwbGl0KC9cXFcvKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9taXplZCBhcnJheSBvZiBzaW5nbGUgbG9yZW0gaXBzdW0gd29yZHMuXG4gKlxuICogQHBhcmFtIGxlbmd0aFxuICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiB3b3Jkc0dlbmVyYXRvcihsZW5ndGgpIHtcbiAgY29uc3Qgd29yZHMgPSByYW5kb20uc2h1ZmZsZShMSVBTVU1fV09SRFMpO1xuXG4gIHJldHVybiB3b3Jkcy5zbGljZSgwLCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB3b3Jkc0dlbmVyYXRvcjtcbiIsImltcG9ydCBjb25zdGFudHMgZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xuaW1wb3J0IHJhbmRvbSBmcm9tICcuLi9jb3JlL3JhbmRvbSc7XG5pbXBvcnQgd29yZHMgZnJvbSAnLi4vZ2VuZXJhdG9ycy93b3Jkcyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgb3B0aW9uQVBJIGZyb20gJy4uL2FwaS9vcHRpb24nO1xuXG4vLyBmYWxsYmFjayBnZW5lcmF0b3JcbmNvbnN0IGFueVR5cGUgPSB7IHR5cGU6IGNvbnN0YW50cy5BTExPV0VEX1RZUEVTIH07XG5cbi8vIFRPRE8gcHJvdmlkZSB0eXBlc1xuZnVuY3Rpb24gb2JqZWN0VHlwZSh2YWx1ZSwgcGF0aCwgcmVzb2x2ZSwgdHJhdmVyc2VDYWxsYmFjaykge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuXG4gIGNvbnN0IHByb3BlcnRpZXMgPSB2YWx1ZS5wcm9wZXJ0aWVzIHx8IHt9O1xuICBjb25zdCBwYXR0ZXJuUHJvcGVydGllcyA9IHZhbHVlLnBhdHRlcm5Qcm9wZXJ0aWVzIHx8IHt9O1xuICBjb25zdCByZXF1aXJlZFByb3BlcnRpZXMgPSB0eXBlb2YgdmFsdWUucmVxdWlyZWQgPT09ICdib29sZWFuJyA/IFtdIDogKHZhbHVlLnJlcXVpcmVkIHx8IFtdKS5zbGljZSgpO1xuICBjb25zdCBhbGxvd3NBZGRpdGlvbmFsID0gdmFsdWUuYWRkaXRpb25hbFByb3BlcnRpZXMgIT09IGZhbHNlO1xuXG4gIGNvbnN0IHByb3BlcnR5S2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBjb25zdCBwYXR0ZXJuUHJvcGVydHlLZXlzID0gT2JqZWN0LmtleXMocGF0dGVyblByb3BlcnRpZXMpO1xuICBjb25zdCBvcHRpb25hbFByb3BlcnRpZXMgPSBwcm9wZXJ0eUtleXMuY29uY2F0KHBhdHRlcm5Qcm9wZXJ0eUtleXMpLnJlZHVjZSgoX3Jlc3BvbnNlLCBfa2V5KSA9PiB7XG4gICAgaWYgKHJlcXVpcmVkUHJvcGVydGllcy5pbmRleE9mKF9rZXkpID09PSAtMSkgX3Jlc3BvbnNlLnB1c2goX2tleSk7XG4gICAgcmV0dXJuIF9yZXNwb25zZTtcbiAgfSwgW10pO1xuICBjb25zdCBhbGxQcm9wZXJ0aWVzID0gcmVxdWlyZWRQcm9wZXJ0aWVzLmNvbmNhdChvcHRpb25hbFByb3BlcnRpZXMpO1xuXG4gIGNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gYWxsb3dzQWRkaXRpb25hbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgPyAodmFsdWUuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHRydWUgPyBhbnlUeXBlIDogdmFsdWUuYWRkaXRpb25hbFByb3BlcnRpZXMpXG4gICAgOiB2YWx1ZS5hZGRpdGlvbmFsUHJvcGVydGllcztcblxuICBpZiAoIWFsbG93c0FkZGl0aW9uYWxcbiAgICAmJiBwcm9wZXJ0eUtleXMubGVuZ3RoID09PSAwXG4gICAgJiYgcGF0dGVyblByb3BlcnR5S2V5cy5sZW5ndGggPT09IDBcbiAgICAmJiB1dGlscy5oYXNQcm9wZXJ0aWVzKHZhbHVlLCAnbWluUHJvcGVydGllcycsICdtYXhQcm9wZXJ0aWVzJywgJ2RlcGVuZGVuY2llcycsICdyZXF1aXJlZCcpXG4gICkge1xuICAgIC8vIGp1c3Qgbm90aGluZ1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG9wdGlvbkFQSSgncmVxdWlyZWRPbmx5JykgPT09IHRydWUpIHtcbiAgICByZXF1aXJlZFByb3BlcnRpZXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHByb3BlcnRpZXNba2V5XSkge1xuICAgICAgICBwcm9wc1trZXldID0gcHJvcGVydGllc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyYXZlcnNlQ2FsbGJhY2socHJvcHMsIHBhdGguY29uY2F0KFsncHJvcGVydGllcyddKSwgcmVzb2x2ZSwgdmFsdWUpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uYWxzUHJvYmFiaWxpdHkgPSBvcHRpb25BUEkoJ2Fsd2F5c0Zha2VPcHRpb25hbHMnKSA9PT0gdHJ1ZSA/IDEuMCA6IG9wdGlvbkFQSSgnb3B0aW9uYWxzUHJvYmFiaWxpdHknKTtcbiAgY29uc3QgZml4ZWRQcm9iYWJpbGl0aWVzID0gb3B0aW9uQVBJKCdhbHdheXNGYWtlT3B0aW9uYWxzJykgfHwgb3B0aW9uQVBJKCdmaXhlZFByb2JhYmlsaXRpZXMnKSB8fCBmYWxzZTtcbiAgY29uc3QgaWdub3JlUHJvcGVydGllcyA9IG9wdGlvbkFQSSgnaWdub3JlUHJvcGVydGllcycpIHx8IFtdO1xuICBjb25zdCByZXVzZVByb3BzID0gb3B0aW9uQVBJKCdyZXVzZVByb3BlcnRpZXMnKTtcbiAgY29uc3QgZmlsbFByb3BzID0gb3B0aW9uQVBJKCdmaWxsUHJvcGVydGllcycpO1xuXG4gIGNvbnN0IG1heCA9IHZhbHVlLm1heFByb3BlcnRpZXMgfHwgKGFsbFByb3BlcnRpZXMubGVuZ3RoICsgKGFsbG93c0FkZGl0aW9uYWwgPyByYW5kb20ubnVtYmVyKDEsIDUpIDogMCkpO1xuXG4gIGxldCBtaW4gPSBNYXRoLm1heCh2YWx1ZS5taW5Qcm9wZXJ0aWVzIHx8IDAsIHJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGgpO1xuICBsZXQgbmVlZGVkRXh0cmFzID0gTWF0aC5tYXgoMCwgYWxsUHJvcGVydGllcy5sZW5ndGggLSBtaW4pO1xuXG4gIGlmIChhbGxQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSAmJiAhcmVxdWlyZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgIG1pbiA9IE1hdGgubWF4KHJhbmRvbS5udW1iZXIoZmlsbFByb3BzID8gMSA6IDAsIG1heCksIG1pbik7XG4gIH1cblxuICBpZiAob3B0aW9uYWxzUHJvYmFiaWxpdHkgIT09IG51bGwpIHtcbiAgICBpZiAoZml4ZWRQcm9iYWJpbGl0aWVzID09PSB0cnVlKSB7XG4gICAgICBuZWVkZWRFeHRyYXMgPSBNYXRoLnJvdW5kKChtaW4gLSByZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoKSArIChvcHRpb25hbHNQcm9iYWJpbGl0eSAqIChhbGxQcm9wZXJ0aWVzLmxlbmd0aCAtIG1pbikpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmVlZGVkRXh0cmFzID0gcmFuZG9tLm51bWJlcihtaW4gLSByZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoLCBvcHRpb25hbHNQcm9iYWJpbGl0eSAqIChhbGxQcm9wZXJ0aWVzLmxlbmd0aCAtIG1pbikpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGV4dHJhUHJvcGVydGllc1JhbmRvbU9yZGVyID0gcmFuZG9tLnNodWZmbGUob3B0aW9uYWxQcm9wZXJ0aWVzKS5zbGljZSgwLCBuZWVkZWRFeHRyYXMpO1xuICBjb25zdCBleHRyYVByb3BlcnRpZXMgPSBvcHRpb25hbFByb3BlcnRpZXMuZmlsdGVyKF9pdGVtID0+IHtcbiAgICByZXR1cm4gZXh0cmFQcm9wZXJ0aWVzUmFuZG9tT3JkZXIuaW5kZXhPZihfaXRlbSkgIT09IC0xO1xuICB9KTtcblxuICAvLyBwcm9wZXJ0aWVzIGFyZSByZWFkIGZyb20gcmlnaHQtdG8tbGVmdFxuICBjb25zdCBfbGltaXQgPSBvcHRpb25hbHNQcm9iYWJpbGl0eSAhPT0gbnVsbCB8fCByZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoID09PSBtYXggPyBtYXggOiByYW5kb20ubnVtYmVyKDAsIG1heCk7XG4gIGNvbnN0IF9wcm9wcyA9IHJlcXVpcmVkUHJvcGVydGllcy5jb25jYXQocmFuZG9tLnNodWZmbGUoZXh0cmFQcm9wZXJ0aWVzKS5zbGljZSgwLCBfbGltaXQpKS5zbGljZSgwLCBtYXgpO1xuICBjb25zdCBfZGVmbnMgPSBbXTtcblxuICBpZiAodmFsdWUuZGVwZW5kZW5jaWVzKSB7XG4gICAgT2JqZWN0LmtleXModmFsdWUuZGVwZW5kZW5jaWVzKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgY29uc3QgX3JlcXVpcmVkID0gdmFsdWUuZGVwZW5kZW5jaWVzW3Byb3BdO1xuXG4gICAgICBpZiAoX3Byb3BzLmluZGV4T2YocHJvcCkgIT09IC0xKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9yZXF1aXJlZCkpIHtcbiAgICAgICAgICAvLyBwcm9wZXJ0eS1kZXBlbmRlbmNpZXNcbiAgICAgICAgICBfcmVxdWlyZWQuZm9yRWFjaChzdWIgPT4ge1xuICAgICAgICAgICAgaWYgKF9wcm9wcy5pbmRleE9mKHN1YikgPT09IC0xKSB7XG4gICAgICAgICAgICAgIF9wcm9wcy5wdXNoKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2RlZm5zLnB1c2goX3JlcXVpcmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gc2NoZW1hLWRlcGVuZGVuY2llc1xuICAgIGlmIChfZGVmbnMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdmFsdWUuZGVwZW5kZW5jaWVzO1xuXG4gICAgICByZXR1cm4gdHJhdmVyc2VDYWxsYmFjayh7XG4gICAgICAgIGFsbE9mOiBfZGVmbnMuY29uY2F0KHZhbHVlKSxcbiAgICAgIH0sIHBhdGguY29uY2F0KFsncHJvcGVydGllcyddKSwgcmVzb2x2ZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNraXBwZWQgPSBbXTtcbiAgY29uc3QgbWlzc2luZyA9IFtdO1xuXG4gIF9wcm9wcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVQcm9wZXJ0aWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoKGlnbm9yZVByb3BlcnRpZXNbaV0gaW5zdGFuY2VvZiBSZWdFeHAgJiYgaWdub3JlUHJvcGVydGllc1tpXS50ZXN0KGtleSkpXG4gICAgICAgIHx8ICh0eXBlb2YgaWdub3JlUHJvcGVydGllc1tpXSA9PT0gJ3N0cmluZycgJiYgaWdub3JlUHJvcGVydGllc1tpXSA9PT0ga2V5KVxuICAgICAgICB8fCAodHlwZW9mIGlnbm9yZVByb3BlcnRpZXNbaV0gPT09ICdmdW5jdGlvbicgJiYgaWdub3JlUHJvcGVydGllc1tpXShwcm9wZXJ0aWVzW2tleV0sIGtleSkpKSB7XG4gICAgICAgIHNraXBwZWQucHVzaChrZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgaWYgKHJlcXVpcmVkUHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgIHByb3BzW2tleV0gPSBwcm9wZXJ0aWVzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnRpZXNba2V5XSkge1xuICAgICAgcHJvcHNba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICB9XG5cbiAgICBsZXQgZm91bmQ7XG5cbiAgICAvLyB0aGVuIHRyeSBwYXR0ZXJuUHJvcGVydGllc1xuICAgIHBhdHRlcm5Qcm9wZXJ0eUtleXMuZm9yRWFjaChfa2V5ID0+IHtcbiAgICAgIGlmIChrZXkubWF0Y2gobmV3IFJlZ0V4cChfa2V5KSkpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChwcm9wc1trZXldKSB7XG4gICAgICAgICAgdXRpbHMubWVyZ2UocHJvcHNba2V5XSwgcGF0dGVyblByb3BlcnRpZXNbX2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3JhbmRvbS5yYW5kZXhwKGtleSldID0gcGF0dGVyblByb3BlcnRpZXNbX2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIC8vIHRyeSBwYXR0ZXJuUHJvcGVydGllcyBhZ2FpbixcbiAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHBhdHRlcm5Qcm9wZXJ0aWVzW2tleV0gfHwgYWRkaXRpb25hbFByb3BlcnRpZXM7XG5cbiAgICAgIC8vIEZJWE1FOiBhbGxvdyBhbnlUeXBlIGFzIGZhbGxiYWNrIHdoZW4gbm8gc3Vic2NoZW1hIGlzIGdpdmVuP1xuXG4gICAgICBpZiAoc3Vic2NoZW1hICYmIGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgY2FuIHVzZSBhZGRpdGlvbmFsUHJvcGVydGllcz9cbiAgICAgICAgcHJvcHNbcGF0dGVyblByb3BlcnRpZXNba2V5XSA/IHJhbmRvbS5yYW5kZXhwKGtleSkgOiBrZXldID0gcHJvcGVydGllc1trZXldIHx8IHN1YnNjaGVtYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pc3NpbmcucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gZGlzY2FyZCBhbHJlYWR5IGlnbm9yZWQgcHJvcHMgaWYgdGhleSdyZSBub3QgcmVxdWlyZWQgdG8gYmUgZmlsbGVkLi4uXG4gIGxldCBjdXJyZW50ID0gT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCArIChmaWxsUHJvcHMgPyAwIDogc2tpcHBlZC5sZW5ndGgpO1xuXG4gIC8vIGdlbmVyYXRlIGR5bmFtaWMgc3VmZml4IGZvciBhZGRpdGlvbmFsIHByb3BzLi4uXG4gIGNvbnN0IGhhc2ggPSBzdWZmaXggPT4gcmFuZG9tLnJhbmRleHAoYF8/W19hLWZcXFxcZF17MSwzfSR7c3VmZml4ID8gJ1xcXFwkPycgOiAnJ31gKTtcblxuICBmdW5jdGlvbiBnZXQoZnJvbSkge1xuICAgIGxldCBvbmU7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoIWZyb20ubGVuZ3RoKSBicmVhaztcbiAgICAgIG9uZSA9IGZyb20uc2hpZnQoKTtcbiAgICB9IHdoaWxlIChwcm9wc1tvbmVdKTtcblxuICAgIHJldHVybiBvbmU7XG4gIH1cblxuICBsZXQgbWluUHJvcHMgPSBtaW47XG4gIGlmIChhbGxvd3NBZGRpdGlvbmFsICYmICFyZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgbWluUHJvcHMgPSBNYXRoLm1heChvcHRpb25hbHNQcm9iYWJpbGl0eSA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsUHJvcGVydGllcyA/IHJhbmRvbS5udW1iZXIoZmlsbFByb3BzID8gMSA6IDAsIG1heCkgOiAwLCBtaW4pO1xuICB9XG5cbiAgd2hpbGUgKGZpbGxQcm9wcykge1xuICAgIGlmICghKHBhdHRlcm5Qcm9wZXJ0eUtleXMubGVuZ3RoIHx8IGFsbG93c0FkZGl0aW9uYWwpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA+PSBtaW5Qcm9wcykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93c0FkZGl0aW9uYWwpIHtcbiAgICAgIGlmIChyZXVzZVByb3BzICYmICgocHJvcGVydHlLZXlzLmxlbmd0aCAtIGN1cnJlbnQpID4gbWluUHJvcHMpKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBrZXk7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG5cbiAgICAgICAgICAvLyBza2lwIGxhcmdlIG9iamVjdHNcbiAgICAgICAgICBpZiAoY291bnQgPiAxMDAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXkgPSBnZXQocmVxdWlyZWRQcm9wZXJ0aWVzKSB8fCByYW5kb20ucGljayhwcm9wZXJ0eUtleXMpO1xuICAgICAgICB9IHdoaWxlICh0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBwcm9wc1trZXldID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgIGN1cnJlbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuUHJvcGVydHlLZXlzLmxlbmd0aCAmJiAhYWRkaXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHJhbmRvbS5waWNrKHBhdHRlcm5Qcm9wZXJ0eUtleXMpO1xuICAgICAgICBjb25zdCB3b3JkID0gcmFuZG9tLnJhbmRleHAocHJvcCk7XG5cbiAgICAgICAgaWYgKCFwcm9wc1t3b3JkXSkge1xuICAgICAgICAgIHByb3BzW3dvcmRdID0gcGF0dGVyblByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgY3VycmVudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3b3JkID0gZ2V0KHJlcXVpcmVkUHJvcGVydGllcykgfHwgKHdvcmRzKDEpICsgaGFzaCgpKTtcblxuICAgICAgICBpZiAoIXByb3BzW3dvcmRdKSB7XG4gICAgICAgICAgcHJvcHNbd29yZF0gPSBhZGRpdGlvbmFsUHJvcGVydGllcyB8fCBhbnlUeXBlO1xuICAgICAgICAgIGN1cnJlbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBjdXJyZW50IDwgbWluICYmIGkgPCBwYXR0ZXJuUHJvcGVydHlLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBfa2V5ID0gcGF0dGVyblByb3BlcnR5S2V5c1tpXTtcbiAgICAgIGNvbnN0IHdvcmQgPSByYW5kb20ucmFuZGV4cChfa2V5KTtcblxuXG4gICAgICBpZiAoIXByb3BzW3dvcmRdKSB7XG4gICAgICAgIHByb3BzW3dvcmRdID0gcGF0dGVyblByb3BlcnRpZXNbX2tleV07XG4gICAgICAgIGN1cnJlbnQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmaWxsIHVwLXRvIHRoaXMgdmFsdWUgYW5kIG5vIG1vcmUhXG4gIGlmIChyZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoID09PSAwICYmICghYWxsb3dzQWRkaXRpb25hbCB8fCBvcHRpb25hbHNQcm9iYWJpbGl0eSA9PT0gZmFsc2UpKSB7XG4gICAgY29uc3QgbWF4aW11bSA9IHJhbmRvbS5udW1iZXIobWluLCBtYXgpO1xuXG4gICAgZm9yICg7IGN1cnJlbnQgPCBtYXhpbXVtOykge1xuICAgICAgY29uc3Qgd29yZCA9IGdldChwcm9wZXJ0eUtleXMpO1xuXG4gICAgICBpZiAod29yZCkge1xuICAgICAgICBwcm9wc1t3b3JkXSA9IHByb3BlcnRpZXNbd29yZF07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgKz0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VDYWxsYmFjayhwcm9wcywgcGF0aC5jb25jYXQoWydwcm9wZXJ0aWVzJ10pLCByZXNvbHZlLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFR5cGU7XG4iLCJpbXBvcnQgd29yZHMgZnJvbSAnLi93b3Jkcyc7XG5pbXBvcnQgcmFuZG9tIGZyb20gJy4uL2NvcmUvcmFuZG9tJztcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCBieSB0aHVua0dlbmVyYXRvciB0byBwcm9kdWNlIHNvbWUgd29yZHMgZm9yIHRoZSBmaW5hbCByZXN1bHQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcHJvZHVjZSgpIHtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZG9tLm51bWJlcigxLCA1KTtcblxuICByZXR1cm4gd29yZHMobGVuZ3RoKS5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbWl6ZWQgY29uY2F0ZW5hdGVkIHN0cmluZyBiYXNlZCBvbiB3b3JkcyBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdGh1bmtHZW5lcmF0b3IobWluID0gMCwgbWF4ID0gMTQwKSB7XG4gIGNvbnN0IF9taW4gPSBNYXRoLm1heCgwLCBtaW4pO1xuICBjb25zdCBfbWF4ID0gcmFuZG9tLm51bWJlcihfbWluLCBtYXgpO1xuXG4gIGxldCByZXN1bHQgPSBwcm9kdWNlKCk7XG5cbiAgLy8gYXBwZW5kIHVudGlsIGxlbmd0aCBpcyByZWFjaGVkXG4gIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgX21pbikge1xuICAgIHJlc3VsdCArPSBwcm9kdWNlKCk7XG4gIH1cblxuICAvLyBjdXQgaWYgbmVlZGVkXG4gIGlmIChyZXN1bHQubGVuZ3RoID4gX21heCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIoMCwgX21heCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0aHVua0dlbmVyYXRvcjtcbiIsImltcG9ydCByYW5kb20gZnJvbSAnLi4vY29yZS9yYW5kb20nO1xuXG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb21pemVkIGlwdjQgYWRkcmVzcy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBpcHY0R2VuZXJhdG9yKCkge1xuICByZXR1cm4gWzAsIDAsIDAsIDBdLm1hcCgoKSA9PiB7XG4gICAgcmV0dXJuIHJhbmRvbS5udW1iZXIoMCwgMjU1KTtcbiAgfSkuam9pbignLicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpcHY0R2VuZXJhdG9yO1xuIiwiaW1wb3J0IHJhbmRvbSBmcm9tICcuLi9jb3JlL3JhbmRvbSc7XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbWl6ZWQgZGF0ZSB0aW1lIElTTyBmb3JtYXQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRhdGVUaW1lR2VuZXJhdG9yKCkge1xuICByZXR1cm4gcmFuZG9tLmRhdGUoKS50b0lTT1N0cmluZygpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkYXRlVGltZUdlbmVyYXRvcjtcbiIsImltcG9ydCBkYXRlVGltZUdlbmVyYXRvciBmcm9tICcuL2RhdGVUaW1lJztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9taXplZCBkYXRlIGZvcm1hdCBzdHJpbmcuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGF0ZUdlbmVyYXRvcigpIHtcbiAgcmV0dXJuIGRhdGVUaW1lR2VuZXJhdG9yKCkuc2xpY2UoMCwgMTApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkYXRlR2VuZXJhdG9yO1xuIiwiaW1wb3J0IGRhdGVUaW1lR2VuZXJhdG9yIGZyb20gJy4vZGF0ZVRpbWUnO1xuXG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb21pemVkIHRpbWUgZm9ybWF0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0aW1lR2VuZXJhdG9yKCkge1xuICByZXR1cm4gZGF0ZVRpbWVHZW5lcmF0b3IoKS5zbGljZSgxMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRpbWVHZW5lcmF0b3I7XG4iLCJpbXBvcnQgcmFuZG9tIGZyb20gJy4uL2NvcmUvcmFuZG9tJztcblxuY29uc3QgRlJBR01FTlQgPSAnW2EtekEtWl1bYS16QS1aMC05Ky0uXSonO1xuY29uc3QgVVJJX1BBVFRFUk4gPSBgaHR0cHM/Oi8ve2hvc3RuYW1lfSg/OiR7RlJBR01FTlR9KStgO1xuY29uc3QgUEFSQU1fUEFUVEVSTiA9ICcoPzpcXFxcPyhbYS16XXsxLDd9KD1cXFxcd3sxLDV9KT8mKXswLDN9KT8nO1xuXG4vKipcbiAqIFByZWRlZmluZWQgY29yZSBmb3JtYXRzXG4gKiBAdHlwZSB7W2tleTogc3RyaW5nXTogc3RyaW5nfVxuICovXG5jb25zdCByZWdleHBzID0ge1xuICBlbWFpbDogJ1thLXpBLVpcXFxcZF1bYS16QS1aXFxcXGQtXXsxLDEzfVthLXpBLVpcXFxcZF1Ae2hvc3RuYW1lfScsXG4gIGhvc3RuYW1lOiAnW2EtekEtWl17MSwzM31cXFxcLlthLXpdezIsNH0nLFxuICBpcHY2OiAnW2EtZlxcXFxkXXs0fSg6W2EtZlxcXFxkXXs0fSl7N30nLFxuICB1cmk6IFVSSV9QQVRURVJOLFxuICBzbHVnOiAnW2EtekEtWlxcXFxkXy1dKycsXG5cbiAgLy8gdHlwZXMgZnJvbSBkcmFmdC0wWzY3XSAoPylcbiAgJ3VyaS1yZWZlcmVuY2UnOiBgJHtVUklfUEFUVEVSTn0ke1BBUkFNX1BBVFRFUk59YCxcbiAgJ3VyaS10ZW1wbGF0ZSc6IFVSSV9QQVRURVJOLnJlcGxhY2UoJyg/OicsICcoPzovXFxcXHtbYS16XVs6YS16QS1aMC05LV0qXFxcXH18JyksXG4gICdqc29uLXBvaW50ZXInOiBgKC8oPzoke0ZSQUdNRU5ULnJlcGxhY2UoJ10qJywgJy9dKicpfXx+WzAxXSkpK2AsXG5cbiAgLy8gc29tZSB0eXBlcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9PQUkvT3BlbkFQSS1TcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3ZlcnNpb25zLzMuMC4xLm1kI2RhdGEtdHlwZXMgKD8pXG4gIHV1aWQ6ICdeWzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQnLFxufTtcblxucmVnZXhwcy5pcmkgPSByZWdleHBzWyd1cmktcmVmZXJlbmNlJ107XG5yZWdleHBzWydpcmktcmVmZXJlbmNlJ10gPSByZWdleHBzWyd1cmktcmVmZXJlbmNlJ107XG5cbnJlZ2V4cHNbJ2lkbi1lbWFpbCddID0gcmVnZXhwcy5lbWFpbDtcbnJlZ2V4cHNbJ2lkbi1ob3N0bmFtZSddID0gcmVnZXhwcy5ob3N0bmFtZTtcblxuY29uc3QgQUxMT1dFRF9GT1JNQVRTID0gbmV3IFJlZ0V4cChgXFxcXHsoJHtPYmplY3Qua2V5cyhyZWdleHBzKS5qb2luKCd8Jyl9KVxcXFx9YCk7XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbWl6ZWQgc3RyaW5nIGJhc2luZyBvbiBhIGJ1aWx0LWluIHJlZ2V4IGZvcm1hdFxuICpcbiAqIEBwYXJhbSBjb3JlRm9ybWF0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb3JlRm9ybWF0R2VuZXJhdG9yKGNvcmVGb3JtYXQpIHtcbiAgcmV0dXJuIHJhbmRvbS5yYW5kZXhwKHJlZ2V4cHNbY29yZUZvcm1hdF0pLnJlcGxhY2UoQUxMT1dFRF9GT1JNQVRTLCAobWF0Y2gsIGtleSkgPT4ge1xuICAgIHJldHVybiByYW5kb20ucmFuZGV4cChyZWdleHBzW2tleV0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29yZUZvcm1hdEdlbmVyYXRvcjtcbiIsImltcG9ydCB0aHVuayBmcm9tICcuLi9nZW5lcmF0b3JzL3RodW5rJztcbmltcG9ydCBpcHY0IGZyb20gJy4uL2dlbmVyYXRvcnMvaXB2NCc7XG5pbXBvcnQgZGF0ZVRpbWUgZnJvbSAnLi4vZ2VuZXJhdG9ycy9kYXRlVGltZSc7XG5pbXBvcnQgZGF0ZSBmcm9tICcuLi9nZW5lcmF0b3JzL2RhdGUnO1xuaW1wb3J0IHRpbWUgZnJvbSAnLi4vZ2VuZXJhdG9ycy90aW1lJztcbmltcG9ydCBjb3JlRm9ybWF0IGZyb20gJy4uL2dlbmVyYXRvcnMvY29yZUZvcm1hdCc7XG5pbXBvcnQgb3B0aW9uQVBJIGZyb20gJy4uL2FwaS9vcHRpb24nO1xuaW1wb3J0IGZvcm1hdCBmcm9tICcuLi9hcGkvZm9ybWF0JztcbmltcG9ydCByYW5kb20gZnJvbSAnLi4vY29yZS9yYW5kb20nO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUZvcm1hdCh2YWx1ZSwgaW52YWxpZCkge1xuICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdCh2YWx1ZS5mb3JtYXQpO1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUpO1xuICB9XG5cbiAgc3dpdGNoICh2YWx1ZS5mb3JtYXQpIHtcbiAgICBjYXNlICdkYXRlLXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgIHJldHVybiBkYXRlVGltZSgpO1xuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIGRhdGUoKTtcbiAgICBjYXNlICd0aW1lJzpcbiAgICAgIHJldHVybiB0aW1lKCk7XG4gICAgY2FzZSAnaXB2NCc6XG4gICAgICByZXR1cm4gaXB2NCgpO1xuICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgIC8vIFRPRE86IGRpc2N1c3NcbiAgICAgIHJldHVybiAnLis/JztcbiAgICBjYXNlICdlbWFpbCc6XG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgIGNhc2UgJ2lwdjYnOlxuICAgIGNhc2UgJ3VyaSc6XG4gICAgY2FzZSAndXJpLXJlZmVyZW5jZSc6XG4gICAgY2FzZSAnaXJpJzpcbiAgICBjYXNlICdpcmktcmVmZXJlbmNlJzpcbiAgICBjYXNlICdpZG4tZW1haWwnOlxuICAgIGNhc2UgJ2lkbi1ob3N0bmFtZSc6XG4gICAgY2FzZSAnanNvbi1wb2ludGVyJzpcbiAgICBjYXNlICdzbHVnJzpcbiAgICBjYXNlICd1cmktdGVtcGxhdGUnOlxuICAgIGNhc2UgJ3V1aWQnOlxuICAgICAgcmV0dXJuIGNvcmVGb3JtYXQodmFsdWUuZm9ybWF0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbkFQSSgnZmFpbE9uSW52YWxpZEZvcm1hdCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHJlZ2lzdHJ5IGtleSAke3V0aWxzLnNob3J0KHZhbHVlLmZvcm1hdCl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGZvcm1hdCAnJHt2YWx1ZS5mb3JtYXR9J2ApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1R5cGUodmFsdWUpIHtcbiAgLy8gaGVyZSB3ZSBuZWVkIHRvIGZvcmNlIHR5cGUgdG8gZml4ICM0NjdcbiAgY29uc3Qgb3V0cHV0ID0gdXRpbHMudHlwZWNhc3QoJ3N0cmluZycsIHZhbHVlLCBvcHRzID0+IHtcbiAgICBpZiAodmFsdWUuZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVGb3JtYXQodmFsdWUsICgpID0+IHRodW5rKG9wdHMubWluTGVuZ3RoLCBvcHRzLm1heExlbmd0aCkpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5wYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnJhbmRleHAodmFsdWUucGF0dGVybik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRodW5rKG9wdHMubWluTGVuZ3RoLCBvcHRzLm1heExlbmd0aCk7XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ1R5cGU7XG4iLCJpbXBvcnQgX2Jvb2xlYW4gZnJvbSAnLi9ib29sZWFuJztcbmltcG9ydCBfbnVsbCBmcm9tICcuL251bGwnO1xuaW1wb3J0IF9hcnJheSBmcm9tICcuL2FycmF5JztcbmltcG9ydCBfaW50ZWdlciBmcm9tICcuL2ludGVnZXInO1xuaW1wb3J0IF9udW1iZXIgZnJvbSAnLi9udW1iZXInO1xuaW1wb3J0IF9vYmplY3QgZnJvbSAnLi9vYmplY3QnO1xuaW1wb3J0IF9zdHJpbmcgZnJvbSAnLi9zdHJpbmcnO1xuXG5jb25zdCB0eXBlTWFwID0ge1xuICBib29sZWFuOiBfYm9vbGVhbixcbiAgbnVsbDogX251bGwsXG4gIGFycmF5OiBfYXJyYXksXG4gIGludGVnZXI6IF9pbnRlZ2VyLFxuICBudW1iZXI6IF9udW1iZXIsXG4gIG9iamVjdDogX29iamVjdCxcbiAgc3RyaW5nOiBfc3RyaW5nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdHlwZU1hcDtcbiIsImltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCByYW5kb20gZnJvbSAnLi9yYW5kb20nO1xuaW1wb3J0IFBhcnNlRXJyb3IgZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgaW5mZXJUeXBlIGZyb20gJy4vaW5mZXInO1xuaW1wb3J0IHR5cGVzIGZyb20gJy4uL3R5cGVzL2luZGV4JztcbmltcG9ydCBvcHRpb25BUEkgZnJvbSAnLi4vYXBpL29wdGlvbic7XG5cbmZ1bmN0aW9uIGdldE1ldGEoeyAkY29tbWVudDogY29tbWVudCwgdGl0bGUsIGRlc2NyaXB0aW9uIH0pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHsgY29tbWVudCwgdGl0bGUsIGRlc2NyaXB0aW9uIH0pXG4gICAgICAuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlKVxuICAgICAgLnJlZHVjZSgobWVtbywgW2ssIHZdKSA9PiB7XG4gICAgICAgIG1lbW9ba10gPSB2O1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHt9KTtcbn1cblxuLy8gVE9ETyBwcm92aWRlIHR5cGVzXG5mdW5jdGlvbiB0cmF2ZXJzZShzY2hlbWEsIHBhdGgsIHJlc29sdmUsIHJvb3RTY2hlbWEpIHtcbiAgc2NoZW1hID0gcmVzb2x2ZShzY2hlbWEsIG51bGwsIHBhdGgpO1xuXG4gIGlmIChzY2hlbWEgJiYgKHNjaGVtYS5vbmVPZiB8fCBzY2hlbWEuYW55T2YgfHwgc2NoZW1hLmFsbE9mKSkge1xuICAgIHNjaGVtYSA9IHJlc29sdmUoc2NoZW1hLCBudWxsLCBwYXRoKTtcbiAgfVxuXG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29udGV4dCA9IGdldE1ldGEoc2NoZW1hKTtcblxuICAvLyBkZWZhdWx0IHZhbHVlcyBoYXMgaGlnaGVyIHByZWNlZGVuY2VcbiAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gJ3Byb3BlcnRpZXMnKSB7XG4gICAgLy8gZXhhbXBsZSB2YWx1ZXMgaGF2ZSBoaWdoZXN0IHByZWNlZGVuY2VcbiAgICBpZiAob3B0aW9uQVBJKCd1c2VFeGFtcGxlc1ZhbHVlJykgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuZXhhbXBsZXMpKSB7XG4gICAgICAvLyBpbmNsdWRlIGBkZWZhdWx0YCB2YWx1ZSBhcyBleGFtcGxlIHRvb1xuICAgICAgY29uc3QgZml4ZWRFeGFtcGxlcyA9IHNjaGVtYS5leGFtcGxlc1xuICAgICAgICAuY29uY2F0KCdkZWZhdWx0JyBpbiBzY2hlbWEgPyBbc2NoZW1hLmRlZmF1bHRdIDogW10pO1xuXG4gICAgICByZXR1cm4geyB2YWx1ZTogdXRpbHMudHlwZWNhc3QobnVsbCwgc2NoZW1hLCAoKSA9PiByYW5kb20ucGljayhmaXhlZEV4YW1wbGVzKSksIGNvbnRleHQgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uQVBJKCd1c2VEZWZhdWx0VmFsdWUnKSAmJiAnZGVmYXVsdCcgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09ICcnIHx8ICFvcHRpb25BUEkoJ3JlcGxhY2VFbXB0eUJ5UmFuZG9tVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogc2NoZW1hLmRlZmF1bHQsIGNvbnRleHQgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ3RlbXBsYXRlJyBpbiBzY2hlbWEpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB1dGlscy50ZW1wbGF0ZShzY2hlbWEudGVtcGxhdGUsIHJvb3RTY2hlbWEpLCBjb250ZXh0IH07XG4gICAgfVxuXG4gICAgaWYgKCdjb25zdCcgaW4gc2NoZW1hKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogc2NoZW1hLmNvbnN0LCBjb250ZXh0IH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYS5ub3QgJiYgdHlwZW9mIHNjaGVtYS5ub3QgPT09ICdvYmplY3QnKSB7XG4gICAgc2NoZW1hID0gdXRpbHMubm90VmFsdWUoc2NoZW1hLm5vdCwgdXRpbHMub21pdFByb3BzKHNjaGVtYSwgWydub3QnXSkpO1xuXG4gICAgLy8gYnVpbGQgbmV3IG9iamVjdCB2YWx1ZSBmcm9tIG5vdC1zY2hlbWEhXG4gICAgaWYgKHNjaGVtYS50eXBlICYmIHNjaGVtYS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgY29udGV4dDogaW5uZXJDb250ZXh0IH0gPSB0cmF2ZXJzZShzY2hlbWEsIHBhdGguY29uY2F0KFsnbm90J10pLCByZXNvbHZlLCByb290U2NoZW1hKTtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB1dGlscy5jbGVhbih2YWx1ZSwgc2NoZW1hLCBmYWxzZSksIGNvbnRleHQ6IHsgLi4uY29udGV4dCwgaXRlbXM6IGlubmVyQ29udGV4dCB9IH07XG4gICAgfVxuICB9XG5cbiAgLy8gdGh1bmtzIGNhbiByZXR1cm4gc3ViLXNjaGVtYXNcbiAgaWYgKHR5cGVvZiBzY2hlbWEudGh1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyByZXN1bHQgaXMgYWxyZWFkeSBjbGVhbmVkIGluIHRodW5rXG4gICAgY29uc3QgeyB2YWx1ZSwgY29udGV4dDogaW5uZXJDb250ZXh0IH0gPSB0cmF2ZXJzZShzY2hlbWEudGh1bmsocm9vdFNjaGVtYSksIHBhdGgsIHJlc29sdmUpO1xuICAgIHJldHVybiB7IHZhbHVlLCBjb250ZXh0OiB7IC4uLmNvbnRleHQsIGl0ZW1zOiBpbm5lckNvbnRleHQgfSB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEuZ2VuZXJhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCByZXR2YWwgPSB1dGlscy50eXBlY2FzdChudWxsLCBzY2hlbWEsICgpID0+IHNjaGVtYS5nZW5lcmF0ZShyb290U2NoZW1hLCBwYXRoKSk7XG4gICAgY29uc3QgdHlwZSA9IHJldHZhbCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZXR2YWw7XG4gICAgaWYgKHR5cGUgPT09IHNjaGVtYS50eXBlXG4gICAgICB8fCAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkgJiYgc2NoZW1hLnR5cGUuaW5jbHVkZXModHlwZSkpXG4gICAgICB8fCAodHlwZSA9PT0gJ251bWJlcicgJiYgc2NoZW1hLnR5cGUgPT09ICdpbnRlZ2VyJylcbiAgICAgIHx8IChBcnJheS5pc0FycmF5KHJldHZhbCkgJiYgc2NoZW1hLnR5cGUgPT09ICdhcnJheScpKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogcmV0dmFsLCBjb250ZXh0IH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEucGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdXRpbHMudHlwZWNhc3QoJ3N0cmluZycsIHNjaGVtYSwgKCkgPT4gcmFuZG9tLnJhbmRleHAoc2NoZW1hLnBhdHRlcm4pKSwgY29udGV4dCB9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHV0aWxzLnR5cGVjYXN0KG51bGwsIHNjaGVtYSwgKCkgPT4gcmFuZG9tLnBpY2soc2NoZW1hLmVudW0pKSwgY29udGV4dCB9O1xuICB9XG5cbiAgLy8gc2hvcnQtY2lyY3VpdCBhcyB3ZSBkb24ndCBwbGFuIGdlbmVyYXRlIG1vcmUgdmFsdWVzIVxuICBpZiAoc2NoZW1hLmpzb25QYXRoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHNjaGVtYSwgY29udGV4dCB9O1xuICB9XG5cbiAgLy8gVE9ETyByZW1vdmUgdGhlIHVnbHkgb3ZlcmNvbWVcbiAgbGV0IHR5cGUgPSBzY2hlbWEudHlwZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHR5cGUgPSByYW5kb20ucGljayh0eXBlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBBdHRlbXB0IHRvIGluZmVyIHRoZSB0eXBlXG4gICAgdHlwZSA9IGluZmVyVHlwZShzY2hlbWEsIHBhdGgpIHx8IHR5cGU7XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgc2NoZW1hLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXR5cGVzW3R5cGVdKSB7XG4gICAgICBpZiAob3B0aW9uQVBJKCdmYWlsT25JbnZhbGlkVHlwZXMnKSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgdW5rbm93biBwcmltaXRpdmUgJHt1dGlscy5zaG9ydCh0eXBlKX1gLCBwYXRoLmNvbmNhdChbJ3R5cGUnXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25BUEkoJ2RlZmF1bHRJbnZhbGlkVHlwZVByb2R1Y3QnKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlc1t2YWx1ZV0pIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdHlwZXNbdmFsdWVdKHNjaGVtYSwgcGF0aCwgcmVzb2x2ZSwgdHJhdmVyc2UpLCBjb250ZXh0IH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgY29udGV4dCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpbm5lclJlc3VsdCA9IHR5cGVzW3R5cGVdKHNjaGVtYSwgcGF0aCwgcmVzb2x2ZSwgdHJhdmVyc2UpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaW5uZXJSZXN1bHQubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgICAgaXRlbXM6IGlubmVyUmVzdWx0Lm1hcCgoeyBjb250ZXh0OiBjIH0pID0+IGMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpbm5lclJlc3VsdC52YWx1ZSwgY29udGV4dDogeyAuLi5jb250ZXh0LCBpdGVtczogaW5uZXJSZXN1bHQuY29udGV4dCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGlubmVyUmVzdWx0LCBjb250ZXh0IH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZS5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGUuc3RhY2ssIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHZhbHVlQ29weSA9IHt9O1xuICBsZXQgY29udGV4dENvcHkgPSB7IC4uLmNvbnRleHQgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgdmFsdWVDb3B5ID0gW107XG4gIH1cblxuICBPYmplY3Qua2V5cyhzY2hlbWEpLmZvckVhY2gocHJvcCA9PiB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWFbcHJvcF0gPT09ICdvYmplY3QnICYmIHByb3AgIT09ICdkZWZpbml0aW9ucycpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGNvbnRleHQ6IGlubmVyQ29udGV4dCB9ID0gdHJhdmVyc2Uoc2NoZW1hW3Byb3BdLCBwYXRoLmNvbmNhdChbcHJvcF0pLCByZXNvbHZlLCB2YWx1ZUNvcHkpO1xuICAgICAgdmFsdWVDb3B5W3Byb3BdID0gdXRpbHMuY2xlYW4odmFsdWUsIHNjaGVtYVtwcm9wXSwgZmFsc2UpO1xuICAgICAgY29udGV4dENvcHlbcHJvcF0gPSBpbm5lckNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlQ29weVtwcm9wXSA9IHNjaGVtYVtwcm9wXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZUNvcHksIGNvbnRleHQ6IGNvbnRleHRDb3B5IH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRyYXZlcnNlO1xuIiwiaW1wb3J0IG9wdGlvbkFQSSBmcm9tICcuLi9hcGkvb3B0aW9uJztcbmltcG9ydCByYW5kb20gZnJvbSAnLi9yYW5kb20nO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBidWlsZFJlc29sdmVTY2hlbWEgPSAoe1xuICByZWZzLFxuICBzY2hlbWEsXG4gIGNvbnRhaW5lcixcbiAgc3luY2hyb25vdXMsXG4gIHJlZkRlcHRoTWF4LFxuICByZWZEZXB0aE1pbixcbn0pID0+IHtcbiAgY29uc3QgcmVjdXJzaXZlVXRpbCA9IHt9O1xuICBjb25zdCBzZWVuUmVmcyA9IHt9O1xuXG4gIGxldCBkZXB0aCA9IDA7XG4gIGxldCBsYXN0UmVmO1xuICBsZXQgbGFzdFBhdGg7XG5cbiAgcmVjdXJzaXZlVXRpbC5yZXNvbHZlU2NoZW1hID0gKHN1YiwgaW5kZXgsIHJvb3RQYXRoKSA9PiB7XG4gICAgLy8gcHJldmVudCBudWxsIHN1YiBmcm9tIGRlZmF1bHQvZXhhbXBsZSBudWxsIHZhbHVlcyB0byB0aHJvd1xuICAgIGlmIChzdWIgPT09IG51bGwgfHwgc3ViID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3ViLmdlbmVyYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3ViO1xuICAgIH1cblxuICAgIC8vIGNsZWFudXBcbiAgICBjb25zdCBfaWQgPSBzdWIuJGlkIHx8IHN1Yi5pZDtcblxuICAgIGlmICh0eXBlb2YgX2lkID09PSAnc3RyaW5nJykge1xuICAgICAgZGVsZXRlIHN1Yi5pZDtcbiAgICAgIGRlbGV0ZSBzdWIuJGlkO1xuICAgICAgZGVsZXRlIHN1Yi4kc2NoZW1hO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3ViLiRyZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBtYXhEZXB0aCA9IE1hdGgubWF4KHJlZkRlcHRoTWluLCByZWZEZXB0aE1heCkgLSAxO1xuXG4gICAgICAvLyBpbmNyZWFzaW5nIGRlcHRoIG9ubHkgZm9yIHJlcGVhdGVkIHJlZnMgc2VlbXMgdG8gYmUgZml4aW5nICMyNThcbiAgICAgIGlmIChzdWIuJHJlZiA9PT0gJyMnIHx8IHNlZW5SZWZzW3N1Yi4kcmVmXSA8IDAgfHwgKGxhc3RSZWYgPT09IHN1Yi4kcmVmICYmICsrZGVwdGggPiBtYXhEZXB0aCkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAoc3ViLiRyZWYgIT09ICcjJyAmJiBsYXN0UGF0aCAmJiBsYXN0UGF0aC5sZW5ndGggPT09IHJvb3RQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB1dGlscy5nZXRMb2NhbFJlZihzY2hlbWEsIHN1Yi4kcmVmLCBzeW5jaHJvbm91cyAmJiByZWZzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3ViLiRyZWY7XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VlblJlZnNbc3ViLiRyZWZdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWVuUmVmc1tzdWIuJHJlZl0gPSByYW5kb20ubnVtYmVyKHJlZkRlcHRoTWluLCByZWZEZXB0aE1heCkgLSAxO1xuICAgICAgfVxuXG4gICAgICBsYXN0UGF0aCA9IHJvb3RQYXRoO1xuICAgICAgbGFzdFJlZiA9IHN1Yi4kcmVmO1xuXG4gICAgICBsZXQgcmVmO1xuXG4gICAgICBpZiAoc3ViLiRyZWYuaW5kZXhPZignIy8nKSA9PT0gLTEpIHtcbiAgICAgICAgcmVmID0gcmVmc1tzdWIuJHJlZl0gfHwgbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZiA9IHV0aWxzLmdldExvY2FsUmVmKHNjaGVtYSwgc3ViLiRyZWYsIHN5bmNocm9ub3VzICYmIHJlZnMpIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXJlZiAmJiBvcHRpb25BUEkoJ2lnbm9yZU1pc3NpbmdSZWZzJykgIT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZmVyZW5jZSBub3QgZm91bmQ6ICR7c3ViLiRyZWZ9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWVuUmVmc1tzdWIuJHJlZl0gLT0gMTtcbiAgICAgICAgdXRpbHMubWVyZ2Uoc3ViLCByZWYgfHwge30pO1xuICAgICAgfVxuXG4gICAgICAvLyBqdXN0IHJlbW92ZSB0aGUgcmVmZXJlbmNlXG4gICAgICBkZWxldGUgc3ViLiRyZWY7XG4gICAgICByZXR1cm4gc3ViO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yi5hbGxPZikpIHtcbiAgICAgIGNvbnN0IHNjaGVtYXMgPSBzdWIuYWxsT2Y7XG5cbiAgICAgIGRlbGV0ZSBzdWIuYWxsT2Y7XG5cbiAgICAgIC8vIHRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSBhbGwgc3ViLXNjaGVtYXNcbiAgICAgIC8vIG11c3QgYmUgcmVzb2x2ZWQgYmVmb3JlIGFueSBtZXJnZVxuICAgICAgc2NoZW1hcy5mb3JFYWNoKHN1YlNjaGVtYSA9PiB7XG4gICAgICAgIGNvbnN0IF9zdWIgPSByZWN1cnNpdmVVdGlsLnJlc29sdmVTY2hlbWEoc3ViU2NoZW1hLCBudWxsLCByb290UGF0aCk7XG5cbiAgICAgICAgLy8gY2FsbCBnaXZlbiB0aHVua3MgaWYgcHJlc2VudFxuICAgICAgICB1dGlscy5tZXJnZShzdWIsIHR5cGVvZiBfc3ViLnRodW5rID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBfc3ViLnRodW5rKHN1YilcbiAgICAgICAgICA6IF9zdWIpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWIuYWxsT2YpKSB7XG4gICAgICAgICAgcmVjdXJzaXZlVXRpbC5yZXNvbHZlU2NoZW1hKHN1YiwgaW5kZXgsIHJvb3RQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViLm9uZU9mIHx8IHN1Yi5hbnlPZikpIHtcbiAgICAgIGNvbnN0IG1peCA9IHN1Yi5vbmVPZiB8fCBzdWIuYW55T2Y7XG5cbiAgICAgIC8vIHRlc3QgZXZlcnkgdmFsdWUgZnJvbSB0aGUgZW51bSBhZ2FpbnN0IGVhY2gtb25lT2ZcbiAgICAgIC8vIHNjaGVtYSwgb25seSB2YWx1ZXMgdGhhdCB2YWxpZGF0ZSBvbmNlIGFyZSBrZXB0XG4gICAgICBpZiAoc3ViLmVudW0gJiYgc3ViLm9uZU9mKSB7XG4gICAgICAgIHN1Yi5lbnVtID0gc3ViLmVudW0uZmlsdGVyKHggPT4gdXRpbHMudmFsaWRhdGUoeCwgbWl4KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRodW5rKHJvb3RTY2hlbWEpIHtcbiAgICAgICAgICBjb25zdCBjb3B5ID0gdXRpbHMub21pdFByb3BzKHN1YiwgWydhbnlPZicsICdvbmVPZiddKTtcbiAgICAgICAgICBjb25zdCBmaXhlZCA9IHJhbmRvbS5waWNrKG1peCk7XG5cbiAgICAgICAgICB1dGlscy5tZXJnZShjb3B5LCBmaXhlZCk7XG5cbiAgICAgICAgICAvLyByZW1vdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZyb20gbWVyZ2VkIHNjaGVtYXNcbiAgICAgICAgICBtaXguZm9yRWFjaChvbWl0ID0+IHtcbiAgICAgICAgICAgIGlmIChvbWl0LnJlcXVpcmVkICYmIG9taXQgIT09IGZpeGVkKSB7XG4gICAgICAgICAgICAgIG9taXQucmVxdWlyZWQuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVzS2V5ID0gY29weS5yZXF1aXJlZCAmJiBjb3B5LnJlcXVpcmVkLmluY2x1ZGVzKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkucHJvcGVydGllcyAmJiAhaW5jbHVkZXNLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb3B5LnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocm9vdFNjaGVtYSAmJiByb290U2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSByb290U2NoZW1hLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHN1YikuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIGlmICgoQXJyYXkuaXNBcnJheShzdWJbcHJvcF0pIHx8IHR5cGVvZiBzdWJbcHJvcF0gPT09ICdvYmplY3QnKSAmJiAhdXRpbHMuaXNLZXkocHJvcCkpIHtcbiAgICAgICAgc3ViW3Byb3BdID0gcmVjdXJzaXZlVXRpbC5yZXNvbHZlU2NoZW1hKHN1Yltwcm9wXSwgcHJvcCwgcm9vdFBhdGguY29uY2F0KHByb3ApKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGF2b2lkIGV4dHJhIGNhbGxzIG9uIHN1Yi1zY2hlbWFzLCBmaXhlcyAjNDU4XG4gICAgaWYgKHJvb3RQYXRoKSB7XG4gICAgICBjb25zdCBsYXN0UHJvcCA9IHJvb3RQYXRoW3Jvb3RQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAobGFzdFByb3AgPT09ICdwcm9wZXJ0aWVzJyB8fCBsYXN0UHJvcCA9PT0gJ2l0ZW1zJykge1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXIud3JhcChzdWIpO1xuICB9O1xuXG4gIHJldHVybiByZWN1cnNpdmVVdGlsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRSZXNvbHZlU2NoZW1hO1xuIiwiaW1wb3J0IHsgZ2V0RGVwZW5kZW5jaWVzIH0gZnJvbSAnLi4vdmVuZG9yJztcbmltcG9ydCBvcHRpb25BUEkgZnJvbSAnLi4vYXBpL29wdGlvbic7XG5pbXBvcnQgdHJhdmVyc2UgZnJvbSAnLi90cmF2ZXJzZSc7XG5pbXBvcnQgcmFuZG9tIGZyb20gJy4vcmFuZG9tJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBidWlsZFJlc29sdmVTY2hlbWEgZnJvbSAnLi9idWlsZFJlc29sdmVTY2hlbWEnO1xuXG5mdW5jdGlvbiBwaWNrKGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSlcbiAgICA/IHJhbmRvbS5waWNrKGRhdGEpXG4gICAgOiBkYXRhO1xufVxuXG5mdW5jdGlvbiBjeWNsZShkYXRhLCByZXZlcnNlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSByZXZlcnNlXG4gICAgPyBkYXRhLnBvcCgpXG4gICAgOiBkYXRhLnNoaWZ0KCk7XG5cbiAgaWYgKHJldmVyc2UpIHtcbiAgICBkYXRhLnVuc2hpZnQodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGRhdGEucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUob2JqLCBkYXRhLCB2YWx1ZXMsIHByb3BlcnR5KSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmICghdmFsdWVzKSB7XG4gICAgdmFsdWVzID0ge307XG4gIH1cblxuICBpZiAoIWRhdGEpIHtcbiAgICBkYXRhID0gb2JqO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKHggPT4gcmVzb2x2ZSh4LCBkYXRhLCB2YWx1ZXMsIHByb3BlcnR5KSk7XG4gIH1cblxuICBpZiAob2JqLmpzb25QYXRoKSB7XG4gICAgY29uc3QgeyBKU09OUGF0aCB9ID0gZ2V0RGVwZW5kZW5jaWVzKCk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB0eXBlb2Ygb2JqLmpzb25QYXRoICE9PSAnb2JqZWN0J1xuICAgICAgPyB7IHBhdGg6IG9iai5qc29uUGF0aCB9XG4gICAgICA6IG9iai5qc29uUGF0aDtcblxuICAgIHBhcmFtcy5ncm91cCA9IG9iai5ncm91cCB8fCBwYXJhbXMuZ3JvdXAgfHwgcHJvcGVydHk7XG4gICAgcGFyYW1zLmN5Y2xlID0gb2JqLmN5Y2xlIHx8IHBhcmFtcy5jeWNsZSB8fCBmYWxzZTtcbiAgICBwYXJhbXMucmV2ZXJzZSA9IG9iai5yZXZlcnNlIHx8IHBhcmFtcy5yZXZlcnNlIHx8IGZhbHNlO1xuICAgIHBhcmFtcy5jb3VudCA9IG9iai5jb3VudCB8fCBwYXJhbXMuY291bnQgfHwgMTtcblxuICAgIGNvbnN0IGtleSA9IGAke3BhcmFtcy5ncm91cH1fXyR7cGFyYW1zLnBhdGh9YDtcblxuICAgIGlmICghdmFsdWVzW2tleV0pIHtcbiAgICAgIGlmIChwYXJhbXMuY291bnQgPiAxKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gSlNPTlBhdGgocGFyYW1zLnBhdGgsIGRhdGEpLnNsaWNlKDAsIHBhcmFtcy5jb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IEpTT05QYXRoKHBhcmFtcy5wYXRoLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmN5Y2xlIHx8IHBhcmFtcy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gY3ljbGUodmFsdWVzW2tleV0sIHBhcmFtcy5yZXZlcnNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGljayh2YWx1ZXNba2V5XSk7XG4gIH1cblxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goayA9PiB7XG4gICAgb2JqW2tdID0gcmVzb2x2ZShvYmpba10sIGRhdGEsIHZhbHVlcywgayk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8vIFRPRE8gcHJvdmlkZSB0eXBlcz9cbmZ1bmN0aW9uIHJ1bihyZWZzLCBzY2hlbWEsIGNvbnRhaW5lciwgc3luY2hyb25vdXMpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzY2hlbWEpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnB1dCwgZXhwZWN0aW5nIG9iamVjdCBidXQgZ2l2ZW4gJHt0eXBlb2Ygc2NoZW1hfWApO1xuICB9XG5cbiAgY29uc3QgcmVmRGVwdGhNaW4gPSBvcHRpb25BUEkoJ3JlZkRlcHRoTWluJykgfHwgMDtcbiAgY29uc3QgcmVmRGVwdGhNYXggPSBvcHRpb25BUEkoJ3JlZkRlcHRoTWF4JykgfHwgMztcblxuICB0cnkge1xuICAgIGNvbnN0IHsgcmVzb2x2ZVNjaGVtYSB9ID0gYnVpbGRSZXNvbHZlU2NoZW1hKHtcbiAgICAgIHJlZnMsXG4gICAgICBzY2hlbWEsXG4gICAgICBjb250YWluZXIsXG4gICAgICBzeW5jaHJvbm91cyxcbiAgICAgIHJlZkRlcHRoTWluLFxuICAgICAgcmVmRGVwdGhNYXgsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhdmVyc2UodXRpbHMuY2xvbmUoc2NoZW1hKSwgW10sIHJlc29sdmVTY2hlbWEpO1xuXG4gICAgaWYgKG9wdGlvbkFQSSgncmVzb2x2ZUpzb25QYXRoJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiByZXNvbHZlKHJlc3VsdC52YWx1ZSksXG4gICAgICAgIGNvbnRleHQ6IHJlc3VsdC5jb250ZXh0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUucGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2UubWVzc2FnZX0gaW4gLyR7ZS5wYXRoLmpvaW4oJy8nKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcnVuO1xuIiwiZnVuY3Rpb24gcmVuZGVySlMocmVzKSB7XG4gIHJldHVybiByZXMudmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlckpTO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDaGFyID0ge1xuICBBTkNIT1I6ICcmJyxcbiAgQ09NTUVOVDogJyMnLFxuICBUQUc6ICchJyxcbiAgRElSRUNUSVZFU19FTkQ6ICctJyxcbiAgRE9DVU1FTlRfRU5EOiAnLidcbn07XG5jb25zdCBUeXBlID0ge1xuICBBTElBUzogJ0FMSUFTJyxcbiAgQkxBTktfTElORTogJ0JMQU5LX0xJTkUnLFxuICBCTE9DS19GT0xERUQ6ICdCTE9DS19GT0xERUQnLFxuICBCTE9DS19MSVRFUkFMOiAnQkxPQ0tfTElURVJBTCcsXG4gIENPTU1FTlQ6ICdDT01NRU5UJyxcbiAgRElSRUNUSVZFOiAnRElSRUNUSVZFJyxcbiAgRE9DVU1FTlQ6ICdET0NVTUVOVCcsXG4gIEZMT1dfTUFQOiAnRkxPV19NQVAnLFxuICBGTE9XX1NFUTogJ0ZMT1dfU0VRJyxcbiAgTUFQOiAnTUFQJyxcbiAgTUFQX0tFWTogJ01BUF9LRVknLFxuICBNQVBfVkFMVUU6ICdNQVBfVkFMVUUnLFxuICBQTEFJTjogJ1BMQUlOJyxcbiAgUVVPVEVfRE9VQkxFOiAnUVVPVEVfRE9VQkxFJyxcbiAgUVVPVEVfU0lOR0xFOiAnUVVPVEVfU0lOR0xFJyxcbiAgU0VROiAnU0VRJyxcbiAgU0VRX0lURU06ICdTRVFfSVRFTSdcbn07XG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5jb25zdCBkZWZhdWx0VGFncyA9IHtcbiAgTUFQOiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJyxcbiAgU0VROiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgU1RSOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJ1xufTtcblxuZnVuY3Rpb24gZmluZExpbmVTdGFydHMoc3JjKSB7XG4gIGNvbnN0IGxzID0gWzBdO1xuICBsZXQgb2Zmc2V0ID0gc3JjLmluZGV4T2YoJ1xcbicpO1xuXG4gIHdoaWxlIChvZmZzZXQgIT09IC0xKSB7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgbHMucHVzaChvZmZzZXQpO1xuICAgIG9mZnNldCA9IHNyYy5pbmRleE9mKCdcXG4nLCBvZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIGxzO1xufVxuXG5mdW5jdGlvbiBnZXRTcmNJbmZvKGNzdCkge1xuICBsZXQgbGluZVN0YXJ0cywgc3JjO1xuXG4gIGlmICh0eXBlb2YgY3N0ID09PSAnc3RyaW5nJykge1xuICAgIGxpbmVTdGFydHMgPSBmaW5kTGluZVN0YXJ0cyhjc3QpO1xuICAgIHNyYyA9IGNzdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjc3QpKSBjc3QgPSBjc3RbMF07XG5cbiAgICBpZiAoY3N0ICYmIGNzdC5jb250ZXh0KSB7XG4gICAgICBpZiAoIWNzdC5saW5lU3RhcnRzKSBjc3QubGluZVN0YXJ0cyA9IGZpbmRMaW5lU3RhcnRzKGNzdC5jb250ZXh0LnNyYyk7XG4gICAgICBsaW5lU3RhcnRzID0gY3N0LmxpbmVTdGFydHM7XG4gICAgICBzcmMgPSBjc3QuY29udGV4dC5zcmM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lU3RhcnRzLFxuICAgIHNyY1xuICB9O1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW5lUG9zIC0gT25lLWluZGV4ZWQgcG9zaXRpb24gaW4gdGhlIHNvdXJjZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xcbiAqL1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgbGluZS9jb2wgcG9zaXRpb24gbWF0Y2hpbmcgYSBjaGFyYWN0ZXIgb2Zmc2V0LlxuICpcbiAqIEFjY2VwdHMgYSBzb3VyY2Ugc3RyaW5nIG9yIGEgQ1NUIGRvY3VtZW50IGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBXaXRoXG4gKiB0aGUgbGF0dGVyLCBzdGFydGluZyBpbmRpY2VzIGZvciBsaW5lcyBhcmUgY2FjaGVkIGluIHRoZSBkb2N1bWVudCBhc1xuICogYGxpbmVTdGFydHM6IG51bWJlcltdYC5cbiAqXG4gKiBSZXR1cm5zIGEgb25lLWluZGV4ZWQgYHsgbGluZSwgY29sIH1gIGxvY2F0aW9uIGlmIGZvdW5kLCBvclxuICogYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfERvY3VtZW50fERvY3VtZW50W119IGNzdFxuICogQHJldHVybnMgez9MaW5lUG9zfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZVBvcyhvZmZzZXQsIGNzdCkge1xuICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0IDwgMCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHtcbiAgICBsaW5lU3RhcnRzLFxuICAgIHNyY1xuICB9ID0gZ2V0U3JjSW5mbyhjc3QpO1xuICBpZiAoIWxpbmVTdGFydHMgfHwgIXNyYyB8fCBvZmZzZXQgPiBzcmMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTdGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBzdGFydCA9IGxpbmVTdGFydHNbaV07XG5cbiAgICBpZiAob2Zmc2V0IDwgc3RhcnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IGksXG4gICAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVN0YXJ0c1tpIC0gMV0gKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0KSByZXR1cm4ge1xuICAgICAgbGluZTogaSArIDEsXG4gICAgICBjb2w6IDFcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgbGluZSA9IGxpbmVTdGFydHMubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgY29sOiBvZmZzZXQgLSBsaW5lU3RhcnRzW2xpbmUgLSAxXSArIDFcbiAgfTtcbn1cbi8qKlxuICogR2V0IGEgc3BlY2lmaWVkIGxpbmUgZnJvbSB0aGUgc291cmNlLlxuICpcbiAqIEFjY2VwdHMgYSBzb3VyY2Ugc3RyaW5nIG9yIGEgQ1NUIGRvY3VtZW50IGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBXaXRoXG4gKiB0aGUgbGF0dGVyLCBzdGFydGluZyBpbmRpY2VzIGZvciBsaW5lcyBhcmUgY2FjaGVkIGluIHRoZSBkb2N1bWVudCBhc1xuICogYGxpbmVTdGFydHM6IG51bWJlcltdYC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBsaW5lIGFzIGEgc3RyaW5nIGlmIGZvdW5kLCBvciBgbnVsbGAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIE9uZS1pbmRleGVkIGxpbmUgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ3xEb2N1bWVudHxEb2N1bWVudFtdfSBjc3RcbiAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldExpbmUobGluZSwgY3N0KSB7XG4gIGNvbnN0IHtcbiAgICBsaW5lU3RhcnRzLFxuICAgIHNyY1xuICB9ID0gZ2V0U3JjSW5mbyhjc3QpO1xuICBpZiAoIWxpbmVTdGFydHMgfHwgIShsaW5lID49IDEpIHx8IGxpbmUgPiBsaW5lU3RhcnRzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHN0YXJ0ID0gbGluZVN0YXJ0c1tsaW5lIC0gMV07XG4gIGxldCBlbmQgPSBsaW5lU3RhcnRzW2xpbmVdOyAvLyB1bmRlZmluZWQgZm9yIGxhc3QgbGluZTsgdGhhdCdzIG9rIGZvciBzbGljZSgpXG5cbiAgd2hpbGUgKGVuZCAmJiBlbmQgPiBzdGFydCAmJiBzcmNbZW5kIC0gMV0gPT09ICdcXG4nKSAtLWVuZDtcblxuICByZXR1cm4gc3JjLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuLyoqXG4gKiBQcmV0dHktcHJpbnQgdGhlIHN0YXJ0aW5nIGxpbmUgZnJvbSB0aGUgc291cmNlIGluZGljYXRlZCBieSB0aGUgcmFuZ2UgYHBvc2BcbiAqXG4gKiBUcmltcyBvdXRwdXQgdG8gYG1heFdpZHRoYCBjaGFycyB3aGlsZSBrZWVwaW5nIHRoZSBzdGFydGluZyBjb2x1bW4gdmlzaWJsZSxcbiAqIHVzaW5nIGDigKZgIGF0IGVpdGhlciBlbmQgdG8gaW5kaWNhdGUgZHJvcHBlZCBjaGFyYWN0ZXJzLlxuICpcbiAqIFJldHVybnMgYSB0d28tbGluZSBzdHJpbmcgKG9yIGBudWxsYCkgd2l0aCBgXFxuYCBhcyBzZXBhcmF0b3I7IHRoZSBzZWNvbmQgbGluZVxuICogd2lsbCBob2xkIGFwcHJvcHJpYXRlbHkgaW5kZW50ZWQgYF5gIG1hcmtzIGluZGljYXRpbmcgdGhlIGNvbHVtbiByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gKiBAcGFyYW0ge0xpbmVQb3N9IHBvcy5zdGFydFxuICogQHBhcmFtIHtMaW5lUG9zfSBbcG9zLmVuZF1cbiAqIEBwYXJhbSB7c3RyaW5nfERvY3VtZW50fERvY3VtZW50W10qfSBjc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4V2lkdGg9ODBdXG4gKiBAcmV0dXJucyB7P3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRQcmV0dHlDb250ZXh0KHtcbiAgc3RhcnQsXG4gIGVuZFxufSwgY3N0LCBtYXhXaWR0aCA9IDgwKSB7XG4gIGxldCBzcmMgPSBnZXRMaW5lKHN0YXJ0LmxpbmUsIGNzdCk7XG4gIGlmICghc3JjKSByZXR1cm4gbnVsbDtcbiAgbGV0IHtcbiAgICBjb2xcbiAgfSA9IHN0YXJ0O1xuXG4gIGlmIChzcmMubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICBpZiAoY29sIDw9IG1heFdpZHRoIC0gMTApIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHIoMCwgbWF4V2lkdGggLSAxKSArICfigKYnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKG1heFdpZHRoIC8gMik7XG4gICAgICBpZiAoc3JjLmxlbmd0aCA+IGNvbCArIGhhbGZXaWR0aCkgc3JjID0gc3JjLnN1YnN0cigwLCBjb2wgKyBoYWxmV2lkdGggLSAxKSArICfigKYnO1xuICAgICAgY29sIC09IHNyYy5sZW5ndGggLSBtYXhXaWR0aDtcbiAgICAgIHNyYyA9ICfigKYnICsgc3JjLnN1YnN0cigxIC0gbWF4V2lkdGgpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBlcnJMZW4gPSAxO1xuICBsZXQgZXJyRW5kID0gJyc7XG5cbiAgaWYgKGVuZCkge1xuICAgIGlmIChlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBjb2wgKyAoZW5kLmNvbCAtIHN0YXJ0LmNvbCkgPD0gbWF4V2lkdGggKyAxKSB7XG4gICAgICBlcnJMZW4gPSBlbmQuY29sIC0gc3RhcnQuY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJMZW4gPSBNYXRoLm1pbihzcmMubGVuZ3RoICsgMSwgbWF4V2lkdGgpIC0gY29sO1xuICAgICAgZXJyRW5kID0gJ+KApic7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gY29sID4gMSA/ICcgJy5yZXBlYXQoY29sIC0gMSkgOiAnJztcbiAgY29uc3QgZXJyID0gJ14nLnJlcGVhdChlcnJMZW4pO1xuICByZXR1cm4gYCR7c3JjfVxcbiR7b2Zmc2V0fSR7ZXJyfSR7ZXJyRW5kfWA7XG59XG5cbmNsYXNzIFJhbmdlIHtcbiAgc3RhdGljIGNvcHkob3JpZykge1xuICAgIHJldHVybiBuZXcgUmFuZ2Uob3JpZy5zdGFydCwgb3JpZy5lbmQpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZCB8fCBzdGFydDtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnN0YXJ0ICE9PSAnbnVtYmVyJyB8fCAhdGhpcy5lbmQgfHwgdGhpcy5lbmQgPD0gdGhpcy5zdGFydDtcbiAgfVxuICAvKipcbiAgICogU2V0IGBvcmlnU3RhcnRgIGFuZCBgb3JpZ0VuZGAgdG8gcG9pbnQgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSByYW5nZSBmb3JcbiAgICogdGhpcyBub2RlLCB3aGljaCBtYXkgZGlmZmVyIGR1ZSB0byBkcm9wcGVkIENSIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGNyIC0gUG9zaXRpb25zIG9mIGRyb3BwZWQgQ1IgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gU3RhcnRpbmcgaW5kZXggb2YgYGNyYCBmcm9tIHRoZSBsYXN0IGNhbGxcbiAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgbmV4dCBvZmZzZXQsIG1hdGNoaW5nIHRoZSBvbmUgZm91bmQgZm9yIGBvcmlnU3RhcnRgXG4gICAqL1xuXG5cbiAgc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGNyLmxlbmd0aCA9PT0gMCB8fCBlbmQgPD0gY3JbMF0pIHtcbiAgICAgIHRoaXMub3JpZ1N0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLm9yaWdFbmQgPSBlbmQ7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGxldCBpID0gb2Zmc2V0O1xuXG4gICAgd2hpbGUgKGkgPCBjci5sZW5ndGgpIHtcbiAgICAgIGlmIChjcltpXSA+IHN0YXJ0KSBicmVhaztlbHNlICsraTtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdTdGFydCA9IHN0YXJ0ICsgaTtcbiAgICBjb25zdCBuZXh0T2Zmc2V0ID0gaTtcblxuICAgIHdoaWxlIChpIDwgY3IubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBlbmQgd2FzIGF0IFxcbiwgaXQgc2hvdWxkIG5vdyBiZSBhdCBcXHJcbiAgICAgIGlmIChjcltpXSA+PSBlbmQpIGJyZWFrO2Vsc2UgKytpO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ0VuZCA9IGVuZCArIGk7XG4gICAgcmV0dXJuIG5leHRPZmZzZXQ7XG4gIH1cblxufVxuXG4vKiogUm9vdCBjbGFzcyBvZiBhbGwgbm9kZXMgKi9cblxuY2xhc3MgTm9kZSB7XG4gIHN0YXRpYyBhZGRTdHJpbmdUZXJtaW5hdG9yKHNyYywgb2Zmc2V0LCBzdHIpIHtcbiAgICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHJldHVybiBzdHI7XG4gICAgY29uc3QgbmV4dCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gbmV4dCA+PSBzcmMubGVuZ3RoIHx8IHNyY1tuZXh0XSA9PT0gJ1xcbicgPyBzdHIgKyAnXFxuJyA6IHN0cjtcbiAgfSAvLyBeKC0tLXwuLi4pXG5cblxuICBzdGF0aWMgYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgb2Zmc2V0LCBzZXApIHtcbiAgICBjb25zdCBjaDAgPSBzcmNbb2Zmc2V0XTtcbiAgICBpZiAoIWNoMCkgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgcHJldiA9IHNyY1tvZmZzZXQgLSAxXTtcbiAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnXFxuJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHNlcCkge1xuICAgICAgaWYgKGNoMCAhPT0gc2VwKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaDAgIT09IENoYXIuRElSRUNUSVZFU19FTkQgJiYgY2gwICE9PSBDaGFyLkRPQ1VNRU5UX0VORCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNoMSA9IHNyY1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBjaDIgPSBzcmNbb2Zmc2V0ICsgMl07XG4gICAgaWYgKGNoMSAhPT0gY2gwIHx8IGNoMiAhPT0gY2gwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY2gzID0gc3JjW29mZnNldCArIDNdO1xuICAgIHJldHVybiAhY2gzIHx8IGNoMyA9PT0gJ1xcbicgfHwgY2gzID09PSAnXFx0JyB8fCBjaDMgPT09ICcgJztcbiAgfVxuXG4gIHN0YXRpYyBlbmRPZklkZW50aWZpZXIoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICBjb25zdCBpc1ZlcmJhdGltID0gY2ggPT09ICc8JztcbiAgICBjb25zdCBub3RPayA9IGlzVmVyYmF0aW0gPyBbJ1xcbicsICdcXHQnLCAnICcsICc+J10gOiBbJ1xcbicsICdcXHQnLCAnICcsICdbJywgJ10nLCAneycsICd9JywgJywnXTtcblxuICAgIHdoaWxlIChjaCAmJiBub3RPay5pbmRleE9mKGNoKSA9PT0gLTEpIGNoID0gc3JjW29mZnNldCArPSAxXTtcblxuICAgIGlmIChpc1ZlcmJhdGltICYmIGNoID09PSAnPicpIG9mZnNldCArPSAxO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzdGF0aWMgZW5kT2ZJbmRlbnQoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgIHdoaWxlIChjaCA9PT0gJyAnKSBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGljIGVuZE9mTGluZShzcmMsIG9mZnNldCkge1xuICAgIGxldCBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRpYyBlbmRPZldoaXRlU3BhY2Uoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgIHdoaWxlIChjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJykgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRpYyBzdGFydE9mTGluZShzcmMsIG9mZnNldCkge1xuICAgIGxldCBjaCA9IHNyY1tvZmZzZXQgLSAxXTtcbiAgICBpZiAoY2ggPT09ICdcXG4nKSByZXR1cm4gb2Zmc2V0O1xuXG4gICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykgY2ggPSBzcmNbb2Zmc2V0IC09IDFdO1xuXG4gICAgcmV0dXJuIG9mZnNldCArIDE7XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBvZiBpbmRlbnRhdGlvbiwgb3IgbnVsbCBpZiB0aGUgbGluZSdzIGluZGVudCBsZXZlbCBpcyBub3QgbW9yZVxuICAgKiB0aGFuIGBpbmRlbnRgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVN0YXJ0XG4gICAqIEByZXR1cm5zIHs/bnVtYmVyfVxuICAgKi9cblxuXG4gIHN0YXRpYyBlbmRPZkJsb2NrSW5kZW50KHNyYywgaW5kZW50LCBsaW5lU3RhcnQpIHtcbiAgICBjb25zdCBpbkVuZCA9IE5vZGUuZW5kT2ZJbmRlbnQoc3JjLCBsaW5lU3RhcnQpO1xuXG4gICAgaWYgKGluRW5kID4gbGluZVN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICByZXR1cm4gaW5FbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdzRW5kID0gTm9kZS5lbmRPZldoaXRlU3BhY2Uoc3JjLCBpbkVuZCk7XG4gICAgICBjb25zdCBjaCA9IHNyY1t3c0VuZF07XG4gICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxuJykgcmV0dXJuIHdzRW5kO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3RhdGljIGF0Qmxhbmsoc3JjLCBvZmZzZXQsIGVuZEFzQmxhbmspIHtcbiAgICBjb25zdCBjaCA9IHNyY1tvZmZzZXRdO1xuICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcgfHwgZW5kQXNCbGFuayAmJiAhY2g7XG4gIH1cblxuICBzdGF0aWMgbmV4dE5vZGVJc0luZGVudGVkKGNoLCBpbmRlbnREaWZmLCBpbmRpY2F0b3JBc0luZGVudCkge1xuICAgIGlmICghY2ggfHwgaW5kZW50RGlmZiA8IDApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaW5kZW50RGlmZiA+IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBpbmRpY2F0b3JBc0luZGVudCAmJiBjaCA9PT0gJy0nO1xuICB9IC8vIHNob3VsZCBiZSBhdCBsaW5lIG9yIHN0cmluZyBlbmQsIG9yIGF0IG5leHQgbm9uLXdoaXRlc3BhY2UgY2hhclxuXG5cbiAgc3RhdGljIG5vcm1hbGl6ZU9mZnNldChzcmMsIG9mZnNldCkge1xuICAgIGNvbnN0IGNoID0gc3JjW29mZnNldF07XG4gICAgcmV0dXJuICFjaCA/IG9mZnNldCA6IGNoICE9PSAnXFxuJyAmJiBzcmNbb2Zmc2V0IC0gMV0gPT09ICdcXG4nID8gb2Zmc2V0IC0gMSA6IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgfSAvLyBmb2xkIHNpbmdsZSBuZXdsaW5lIGludG8gc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzXG4gIC8vIHByZXN1bWVzIHNyY1tvZmZzZXRdID09PSAnXFxuJ1xuXG5cbiAgc3RhdGljIGZvbGROZXdsaW5lKHNyYywgb2Zmc2V0LCBpbmRlbnQpIHtcbiAgICBsZXQgaW5Db3VudCA9IDA7XG4gICAgbGV0IGVycm9yID0gZmFsc2U7XG4gICAgbGV0IGZvbGQgPSAnJztcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0ICsgMV07XG5cbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nKSB7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgaW5Db3VudCA9IDA7XG4gICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgZm9sZCArPSAnXFxuJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgIGlmIChpbkNvdW50IDw9IGluZGVudCkgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0ICsgMikgLSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgIGluQ291bnQgKz0gMTtcbiAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2ggPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgfVxuXG4gICAgaWYgKCFmb2xkKSBmb2xkID0gJyAnO1xuICAgIGlmIChjaCAmJiBpbkNvdW50IDw9IGluZGVudCkgZXJyb3IgPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICBmb2xkLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IodHlwZSwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbnRleHQnLCB7XG4gICAgICB2YWx1ZTogY29udGV4dCB8fCBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnZhbHVlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcyB8fCBbXTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG5cbiAgZ2V0UHJvcFZhbHVlKGlkeCwga2V5LCBza2lwS2V5KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcHNbaWR4XTtcbiAgICByZXR1cm4gcHJvcCAmJiBzcmNbcHJvcC5zdGFydF0gPT09IGtleSA/IHNyYy5zbGljZShwcm9wLnN0YXJ0ICsgKHNraXBLZXkgPyAxIDogMCksIHByb3AuZW5kKSA6IG51bGw7XG4gIH1cblxuICBnZXQgYW5jaG9yKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5nZXRQcm9wVmFsdWUoaSwgQ2hhci5BTkNIT1IsIHRydWUpO1xuICAgICAgaWYgKGFuY2hvciAhPSBudWxsKSByZXR1cm4gYW5jaG9yO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgY29uc3QgY29tbWVudHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuZ2V0UHJvcFZhbHVlKGksIENoYXIuQ09NTUVOVCwgdHJ1ZSk7XG4gICAgICBpZiAoY29tbWVudCAhPSBudWxsKSBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50cy5sZW5ndGggPiAwID8gY29tbWVudHMuam9pbignXFxuJykgOiBudWxsO1xuICB9XG5cbiAgY29tbWVudEhhc1JlcXVpcmVkV2hpdGVzcGFjZShzdGFydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgaWYgKHRoaXMuaGVhZGVyICYmIHN0YXJ0ID09PSB0aGlzLmhlYWRlci5lbmQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzLnZhbHVlUmFuZ2U7XG4gICAgcmV0dXJuIHN0YXJ0ICE9PSBlbmQgfHwgTm9kZS5hdEJsYW5rKHNyYywgZW5kIC0gMSk7XG4gIH1cblxuICBnZXQgaGFzQ29tbWVudCgpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNyY1xuICAgICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzcmNbdGhpcy5wcm9wc1tpXS5zdGFydF0gPT09IENoYXIuQ09NTUVOVCkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IGhhc1Byb3BzKCkge1xuICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3JjXG4gICAgICB9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNyY1t0aGlzLnByb3BzW2ldLnN0YXJ0XSAhPT0gQ2hhci5DT01NRU5UKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgaW5jbHVkZXNUcmFpbGluZ0xpbmVzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldCBqc29uTGlrZSgpIHtcbiAgICBjb25zdCBqc29uTGlrZVR5cGVzID0gW1R5cGUuRkxPV19NQVAsIFR5cGUuRkxPV19TRVEsIFR5cGUuUVVPVEVfRE9VQkxFLCBUeXBlLlFVT1RFX1NJTkdMRV07XG4gICAgcmV0dXJuIGpzb25MaWtlVHlwZXMuaW5kZXhPZih0aGlzLnR5cGUpICE9PSAtMTtcbiAgfVxuXG4gIGdldCByYW5nZUFzTGluZVBvcygpIHtcbiAgICBpZiAoIXRoaXMucmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdGFydCA9IGdldExpbmVQb3ModGhpcy5yYW5nZS5zdGFydCwgdGhpcy5jb250ZXh0LnJvb3QpO1xuICAgIGlmICghc3RhcnQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZW5kID0gZ2V0TGluZVBvcyh0aGlzLnJhbmdlLmVuZCwgdGhpcy5jb250ZXh0LnJvb3QpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH07XG4gIH1cblxuICBnZXQgcmF3VmFsdWUoKSB7XG4gICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UgfHwgIXRoaXMuY29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9ID0gdGhpcy52YWx1ZVJhbmdlO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuc3JjLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgZ2V0IHRhZygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0UHJvcFZhbHVlKGksIENoYXIuVEFHLCBmYWxzZSk7XG5cbiAgICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgICBpZiAodGFnWzFdID09PSAnPCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyYmF0aW06IHRhZy5zbGljZSgyLCAtMSlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgIGNvbnN0IFtfLCBoYW5kbGUsIHN1ZmZpeF0gPSB0YWcubWF0Y2goL14oLiohKShbXiFdKikkLyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhbmRsZSxcbiAgICAgICAgICAgIHN1ZmZpeFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCB2YWx1ZVJhbmdlQ29udGFpbnNOZXdsaW5lKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzLnZhbHVlUmFuZ2U7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBpZiAoc3JjW2ldID09PSAnXFxuJykgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcGFyc2VDb21tZW50KHN0YXJ0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGlmIChzcmNbc3RhcnRdID09PSBDaGFyLkNPTU1FTlQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IE5vZGUuZW5kT2ZMaW5lKHNyYywgc3RhcnQgKyAxKTtcbiAgICAgIGNvbnN0IGNvbW1lbnRSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kKTtcbiAgICAgIHRoaXMucHJvcHMucHVzaChjb21tZW50UmFuZ2UpO1xuICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhcnQ7XG4gIH1cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyB0aGUgYG9yaWdTdGFydGAgYW5kIGBvcmlnRW5kYCB2YWx1ZXMgb2YgYWxsIHJhbmdlcyBmb3IgdGhpc1xuICAgKiBub2RlLiBFeHRlbmRlZCBieSBjaGlsZCBjbGFzc2VzIHRvIGhhbmRsZSBkZXNjZW5kYW50IG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBjciAtIFBvc2l0aW9ucyBvZiBkcm9wcGVkIENSIGNoYXJhY3RlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFN0YXJ0aW5nIGluZGV4IG9mIGBjcmAgZnJvbSB0aGUgbGFzdCBjYWxsXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIG5leHQgb2Zmc2V0LCBtYXRjaGluZyB0aGUgb25lIGZvdW5kIGZvciBgb3JpZ1N0YXJ0YFxuICAgKi9cblxuXG4gIHNldE9yaWdSYW5nZXMoY3IsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLnJhbmdlKSBvZmZzZXQgPSB0aGlzLnJhbmdlLnNldE9yaWdSYW5nZShjciwgb2Zmc2V0KTtcbiAgICBpZiAodGhpcy52YWx1ZVJhbmdlKSB0aGlzLnZhbHVlUmFuZ2Uuc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpO1xuICAgIHRoaXMucHJvcHMuZm9yRWFjaChwcm9wID0+IHByb3Auc2V0T3JpZ1JhbmdlKGNyLCBvZmZzZXQpKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBzcmNcbiAgICAgIH0sXG4gICAgICByYW5nZSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzdHIgPSBzcmMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgcmV0dXJuIE5vZGUuYWRkU3RyaW5nVGVybWluYXRvcihzcmMsIHJhbmdlLmVuZCwgc3RyKTtcbiAgfVxuXG59XG5cbmNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobmFtZSwgc291cmNlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFtZXNzYWdlIHx8ICEoc291cmNlIGluc3RhbmNlb2YgTm9kZSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcmd1bWVudHMgZm9yIG5ldyAke25hbWV9YCk7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIH1cblxuICBtYWtlUHJldHR5KCkge1xuICAgIGlmICghdGhpcy5zb3VyY2UpIHJldHVybjtcbiAgICB0aGlzLm5vZGVUeXBlID0gdGhpcy5zb3VyY2UudHlwZTtcbiAgICBjb25zdCBjc3QgPSB0aGlzLnNvdXJjZS5jb250ZXh0ICYmIHRoaXMuc291cmNlLmNvbnRleHQucm9vdDtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgY29uc3Qgc3RhcnQgPSBjc3QgJiYgZ2V0TGluZVBvcyh0aGlzLm9mZnNldCwgY3N0KTtcblxuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IHtcbiAgICAgICAgICBsaW5lOiBzdGFydC5saW5lLFxuICAgICAgICAgIGNvbDogc3RhcnQuY29sICsgMVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpbmVQb3MgPSB7XG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLm9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYW5nZSA9IHRoaXMuc291cmNlLnJhbmdlO1xuICAgICAgdGhpcy5saW5lUG9zID0gdGhpcy5zb3VyY2UucmFuZ2VBc0xpbmVQb3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGluZVBvcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBjb2xcbiAgICAgIH0gPSB0aGlzLmxpbmVQb3Muc3RhcnQ7XG4gICAgICB0aGlzLm1lc3NhZ2UgKz0gYCBhdCBsaW5lICR7bGluZX0sIGNvbHVtbiAke2NvbH1gO1xuICAgICAgY29uc3QgY3R4ID0gY3N0ICYmIGdldFByZXR0eUNvbnRleHQodGhpcy5saW5lUG9zLCBjc3QpO1xuICAgICAgaWYgKGN0eCkgdGhpcy5tZXNzYWdlICs9IGA6XFxuXFxuJHtjdHh9XFxuYDtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5zb3VyY2U7XG4gIH1cblxufVxuY2xhc3MgWUFNTFJlZmVyZW5jZUVycm9yIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoJ1lBTUxSZWZlcmVuY2VFcnJvcicsIHNvdXJjZSwgbWVzc2FnZSk7XG4gIH1cblxufVxuY2xhc3MgWUFNTFNlbWFudGljRXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcignWUFNTFNlbWFudGljRXJyb3InLCBzb3VyY2UsIG1lc3NhZ2UpO1xuICB9XG5cbn1cbmNsYXNzIFlBTUxTeW50YXhFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKCdZQU1MU3ludGF4RXJyb3InLCBzb3VyY2UsIG1lc3NhZ2UpO1xuICB9XG5cbn1cbmNsYXNzIFlBTUxXYXJuaW5nIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoJ1lBTUxXYXJuaW5nJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5jbGFzcyBQbGFpblZhbHVlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyBlbmRPZkxpbmUoc3JjLCBzdGFydCwgaW5GbG93KSB7XG4gICAgbGV0IGNoID0gc3JjW3N0YXJ0XTtcbiAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG5cbiAgICB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICBpZiAoaW5GbG93ICYmIChjaCA9PT0gJ1snIHx8IGNoID09PSAnXScgfHwgY2ggPT09ICd7JyB8fCBjaCA9PT0gJ30nIHx8IGNoID09PSAnLCcpKSBicmVhaztcbiAgICAgIGNvbnN0IG5leHQgPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgICBpZiAoY2ggPT09ICc6JyAmJiAoIW5leHQgfHwgbmV4dCA9PT0gJ1xcbicgfHwgbmV4dCA9PT0gJ1xcdCcgfHwgbmV4dCA9PT0gJyAnIHx8IGluRmxvdyAmJiBuZXh0ID09PSAnLCcpKSBicmVhaztcbiAgICAgIGlmICgoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpICYmIG5leHQgPT09ICcjJykgYnJlYWs7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIGNoID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0IHN0clZhbHVlKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGxldCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gPSB0aGlzLnZhbHVlUmFuZ2U7XG4gICAgY29uc3Qge1xuICAgICAgc3JjXG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICBsZXQgY2ggPSBzcmNbZW5kIC0gMV07XG5cbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJykpIGNoID0gc3JjWy0tZW5kIC0gMV07XG5cbiAgICBsZXQgc3RyID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBzcmNbaV07XG5cbiAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvbGQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH0gPSBOb2RlLmZvbGROZXdsaW5lKHNyYywgaSwgLTEpO1xuICAgICAgICBzdHIgKz0gZm9sZDtcbiAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgLy8gdHJpbSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIGNvbnN0IHdzU3RhcnQgPSBpO1xuICAgICAgICBsZXQgbmV4dCA9IHNyY1tpICsgMV07XG5cbiAgICAgICAgd2hpbGUgKGkgPCBlbmQgJiYgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JykpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgbmV4dCA9IHNyY1tpICsgMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicpIHN0ciArPSBpID4gd3NTdGFydCA/IHNyYy5zbGljZSh3c1N0YXJ0LCBpICsgMSkgOiBjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBjaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaDAgPSBzcmNbc3RhcnRdO1xuXG4gICAgc3dpdGNoIChjaDApIHtcbiAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggYSB0YWIgY2hhcmFjdGVyJztcbiAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbbmV3IFlBTUxTZW1hbnRpY0Vycm9yKHRoaXMsIG1zZyldO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICBzdHJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgY2FzZSAnYCc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggcmVzZXJ2ZWQgY2hhcmFjdGVyICR7Y2gwfWA7XG4gICAgICAgICAgY29uc3QgZXJyb3JzID0gW25ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgc3RyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQmxvY2tWYWx1ZShzdGFydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGVudCxcbiAgICAgIGluRmxvdyxcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgIGxldCB2YWx1ZUVuZCA9IHN0YXJ0O1xuXG4gICAgZm9yIChsZXQgY2ggPSBzcmNbb2Zmc2V0XTsgY2ggPT09ICdcXG4nOyBjaCA9IHNyY1tvZmZzZXRdKSB7XG4gICAgICBpZiAoTm9kZS5hdERvY3VtZW50Qm91bmRhcnkoc3JjLCBvZmZzZXQgKyAxKSkgYnJlYWs7XG4gICAgICBjb25zdCBlbmQgPSBOb2RlLmVuZE9mQmxvY2tJbmRlbnQoc3JjLCBpbmRlbnQsIG9mZnNldCArIDEpO1xuICAgICAgaWYgKGVuZCA9PT0gbnVsbCB8fCBzcmNbZW5kXSA9PT0gJyMnKSBicmVhaztcblxuICAgICAgaWYgKHNyY1tlbmRdID09PSAnXFxuJykge1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZUVuZCA9IFBsYWluVmFsdWUuZW5kT2ZMaW5lKHNyYywgZW5kLCBpbkZsb3cpO1xuICAgICAgICBvZmZzZXQgPSB2YWx1ZUVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZVJhbmdlLmlzRW1wdHkoKSkgdGhpcy52YWx1ZVJhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy52YWx1ZVJhbmdlLmVuZCA9IHZhbHVlRW5kO1xuICAgIHJldHVybiB2YWx1ZUVuZDtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgcGxhaW4gdmFsdWUgZnJvbSB0aGUgc291cmNlXG4gICAqXG4gICAqIEFjY2VwdGVkIGZvcm1zIGFyZTpcbiAgICogYGBgXG4gICAqICNjb21tZW50XG4gICAqXG4gICAqIGZpcnN0IGxpbmVcbiAgICpcbiAgICogZmlyc3QgbGluZSAjY29tbWVudFxuICAgKlxuICAgKiBmaXJzdCBsaW5lXG4gICAqIGJsb2NrXG4gICAqIGxpbmVzXG4gICAqXG4gICAqICNjb21tZW50XG4gICAqIGJsb2NrXG4gICAqIGxpbmVzXG4gICAqIGBgYFxuICAgKiB3aGVyZSBibG9jayBsaW5lcyBhcmUgZW1wdHkgb3IgaGF2ZSBhbiBpbmRlbnQgbGV2ZWwgZ3JlYXRlciB0aGFuIGBpbmRlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnNlQ29udGV4dH0gY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBvZiBmaXJzdCBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoaXMgc2NhbGFyLCBtYXkgYmUgYFxcbmBcbiAgICovXG5cblxuICBwYXJzZShjb250ZXh0LCBzdGFydCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29uc3Qge1xuICAgICAgaW5GbG93LFxuICAgICAgc3JjXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgIGNvbnN0IGNoID0gc3JjW29mZnNldF07XG5cbiAgICBpZiAoY2ggJiYgY2ggIT09ICcjJyAmJiBjaCAhPT0gJ1xcbicpIHtcbiAgICAgIG9mZnNldCA9IFBsYWluVmFsdWUuZW5kT2ZMaW5lKHNyYywgc3RhcnQsIGluRmxvdyk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZVJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBvZmZzZXQpO1xuICAgIG9mZnNldCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgPSB0aGlzLnBhcnNlQ29tbWVudChvZmZzZXQpO1xuXG4gICAgaWYgKCF0aGlzLmhhc0NvbW1lbnQgfHwgdGhpcy52YWx1ZVJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUJsb2NrVmFsdWUob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbn1cblxuZXhwb3J0cy5DaGFyID0gQ2hhcjtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG5leHBvcnRzLlBsYWluVmFsdWUgPSBQbGFpblZhbHVlO1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZXhwb3J0cy5UeXBlID0gVHlwZTtcbmV4cG9ydHMuWUFNTEVycm9yID0gWUFNTEVycm9yO1xuZXhwb3J0cy5ZQU1MUmVmZXJlbmNlRXJyb3IgPSBZQU1MUmVmZXJlbmNlRXJyb3I7XG5leHBvcnRzLllBTUxTZW1hbnRpY0Vycm9yID0gWUFNTFNlbWFudGljRXJyb3I7XG5leHBvcnRzLllBTUxTeW50YXhFcnJvciA9IFlBTUxTeW50YXhFcnJvcjtcbmV4cG9ydHMuWUFNTFdhcm5pbmcgPSBZQU1MV2FybmluZztcbmV4cG9ydHMuX2RlZmluZVByb3BlcnR5ID0gX2RlZmluZVByb3BlcnR5O1xuZXhwb3J0cy5kZWZhdWx0VGFnUHJlZml4ID0gZGVmYXVsdFRhZ1ByZWZpeDtcbmV4cG9ydHMuZGVmYXVsdFRhZ3MgPSBkZWZhdWx0VGFncztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBsYWluVmFsdWUgPSByZXF1aXJlKCcuL1BsYWluVmFsdWUtZWM4ZTU4OGUuanMnKTtcblxuZnVuY3Rpb24gYWRkQ29tbWVudEJlZm9yZShzdHIsIGluZGVudCwgY29tbWVudCkge1xuICBpZiAoIWNvbW1lbnQpIHJldHVybiBzdHI7XG4gIGNvbnN0IGNjID0gY29tbWVudC5yZXBsYWNlKC9bXFxzXFxTXV4vZ20sIGAkJiR7aW5kZW50fSNgKTtcbiAgcmV0dXJuIGAjJHtjY31cXG4ke2luZGVudH0ke3N0cn1gO1xufVxuZnVuY3Rpb24gYWRkQ29tbWVudChzdHIsIGluZGVudCwgY29tbWVudCkge1xuICByZXR1cm4gIWNvbW1lbnQgPyBzdHIgOiBjb21tZW50LmluZGV4T2YoJ1xcbicpID09PSAtMSA/IGAke3N0cn0gIyR7Y29tbWVudH1gIDogYCR7c3RyfVxcbmAgKyBjb21tZW50LnJlcGxhY2UoL14vZ20sIGAke2luZGVudCB8fCAnJ30jYCk7XG59XG5cbmNsYXNzIE5vZGUge31cblxuZnVuY3Rpb24gdG9KU09OKHZhbHVlLCBhcmcsIGN0eCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5tYXAoKHYsIGkpID0+IHRvSlNPTih2LCBTdHJpbmcoaSksIGN0eCkpO1xuXG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgYW5jaG9yID0gY3R4ICYmIGN0eC5hbmNob3JzICYmIGN0eC5hbmNob3JzLmdldCh2YWx1ZSk7XG4gICAgaWYgKGFuY2hvcikgY3R4Lm9uQ3JlYXRlID0gcmVzID0+IHtcbiAgICAgIGFuY2hvci5yZXMgPSByZXM7XG4gICAgICBkZWxldGUgY3R4Lm9uQ3JlYXRlO1xuICAgIH07XG4gICAgY29uc3QgcmVzID0gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICBpZiAoYW5jaG9yICYmIGN0eC5vbkNyZWF0ZSkgY3R4Lm9uQ3JlYXRlKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGlmICgoIWN0eCB8fCAhY3R4LmtlZXApICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmNsYXNzIFNjYWxhciBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgdG9KU09OKGFyZywgY3R4KSB7XG4gICAgcmV0dXJuIGN0eCAmJiBjdHgua2VlcCA/IHRoaXMudmFsdWUgOiB0b0pTT04odGhpcy52YWx1ZSwgYXJnLCBjdHgpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25Gcm9tUGF0aChzY2hlbWEsIHBhdGgsIHZhbHVlKSB7XG4gIGxldCB2ID0gdmFsdWU7XG5cbiAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBjb25zdCBrID0gcGF0aFtpXTtcblxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGspICYmIGsgPj0gMCkge1xuICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgYVtrXSA9IHY7XG4gICAgICB2ID0gYTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbyA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGssIHtcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdiA9IG87XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNjaGVtYS5jcmVhdGVOb2RlKHYsIGZhbHNlKTtcbn0gLy8gbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlIChlLmcuIFtdKVxuXG5cbmNvbnN0IGlzRW1wdHlQYXRoID0gcGF0aCA9PiBwYXRoID09IG51bGwgfHwgdHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGhbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS5kb25lO1xuY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtc1wiLCBbXSk7XG5cbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuXG4gIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSB0aGlzLmFkZCh2YWx1ZSk7ZWxzZSB7XG4gICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7ZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKSB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICB9XG4gIH1cblxuICBkZWxldGVJbihba2V5LCAuLi5yZXN0XSkge1xuICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSByZXR1cm4gbm9kZS5kZWxldGVJbihyZXN0KTtlbHNlIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgfVxuXG4gIGdldEluKFtrZXksIC4uLnJlc3RdLCBrZWVwU2NhbGFyKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSByZXR1cm4gIWtlZXBTY2FsYXIgJiYgbm9kZSBpbnN0YW5jZW9mIFNjYWxhciA/IG5vZGUudmFsdWUgOiBub2RlO2Vsc2UgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gbm9kZS5nZXRJbihyZXN0LCBrZWVwU2NhbGFyKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGhhc0FsbE51bGxWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkobm9kZSA9PiB7XG4gICAgICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSAnUEFJUicpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IG4gPSBub2RlLnZhbHVlO1xuICAgICAgcmV0dXJuIG4gPT0gbnVsbCB8fCBuIGluc3RhbmNlb2YgU2NhbGFyICYmIG4udmFsdWUgPT0gbnVsbCAmJiAhbi5jb21tZW50QmVmb3JlICYmICFuLmNvbW1lbnQgJiYgIW4udGFnO1xuICAgIH0pO1xuICB9XG5cbiAgaGFzSW4oW2tleSwgLi4ucmVzdF0pIHtcbiAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IG5vZGUuaGFzSW4ocmVzdCkgOiBmYWxzZTtcbiAgfVxuXG4gIHNldEluKFtrZXksIC4uLnJlc3RdLCB2YWx1ZSkge1xuICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSBub2RlLnNldEluKHJlc3QsIHZhbHVlKTtlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgIH1cbiAgfSAvLyBvdmVycmlkZGVuIGluIGltcGxlbWVudGF0aW9uc1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0b1N0cmluZyhjdHgsIHtcbiAgICBibG9ja0l0ZW0sXG4gICAgZmxvd0NoYXJzLFxuICAgIGlzTWFwLFxuICAgIGl0ZW1JbmRlbnRcbiAgfSwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGVudCxcbiAgICAgIGluZGVudFN0ZXAsXG4gICAgICBzdHJpbmdpZnlcbiAgICB9ID0gY3R4O1xuICAgIGNvbnN0IGluRmxvdyA9IHRoaXMudHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkZMT1dfTUFQIHx8IHRoaXMudHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkZMT1dfU0VRIHx8IGN0eC5pbkZsb3c7XG4gICAgaWYgKGluRmxvdykgaXRlbUluZGVudCArPSBpbmRlbnRTdGVwO1xuICAgIGNvbnN0IGFsbE51bGxWYWx1ZXMgPSBpc01hcCAmJiB0aGlzLmhhc0FsbE51bGxWYWx1ZXMoKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgIGFsbE51bGxWYWx1ZXMsXG4gICAgICBpbmRlbnQ6IGl0ZW1JbmRlbnQsXG4gICAgICBpbkZsb3csXG4gICAgICB0eXBlOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBoYXNJdGVtV2l0aE5ld0xpbmUgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuaXRlbXMucmVkdWNlKChub2RlcywgaXRlbSwgaSkgPT4ge1xuICAgICAgbGV0IGNvbW1lbnQ7XG5cbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGlmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUpIG5vZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdjb21tZW50JyxcbiAgICAgICAgICBzdHI6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBpdGVtLmNvbW1lbnRCZWZvcmUubWF0Y2goL14uKiQvZ20pLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnY29tbWVudCcsXG4gICAgICAgICAgICBzdHI6IGAjJHtsaW5lfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIGlmIChpbkZsb3cgJiYgKCFjaG9tcEtlZXAgJiYgaXRlbS5zcGFjZUJlZm9yZSB8fCBpdGVtLmNvbW1lbnRCZWZvcmUgfHwgaXRlbS5jb21tZW50IHx8IGl0ZW0ua2V5ICYmIChpdGVtLmtleS5jb21tZW50QmVmb3JlIHx8IGl0ZW0ua2V5LmNvbW1lbnQpIHx8IGl0ZW0udmFsdWUgJiYgKGl0ZW0udmFsdWUuY29tbWVudEJlZm9yZSB8fCBpdGVtLnZhbHVlLmNvbW1lbnQpKSkgaGFzSXRlbVdpdGhOZXdMaW5lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICBsZXQgc3RyID0gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgKCkgPT4gY29tbWVudCA9IG51bGwsICgpID0+IGNob21wS2VlcCA9IHRydWUpO1xuICAgICAgaWYgKGluRmxvdyAmJiAhaGFzSXRlbVdpdGhOZXdMaW5lICYmIHN0ci5pbmNsdWRlcygnXFxuJykpIGhhc0l0ZW1XaXRoTmV3TGluZSA9IHRydWU7XG4gICAgICBpZiAoaW5GbG93ICYmIGkgPCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHN0ciArPSAnLCc7XG4gICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudCk7XG4gICAgICBpZiAoY2hvbXBLZWVwICYmIChjb21tZW50IHx8IGluRmxvdykpIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdpdGVtJyxcbiAgICAgICAgc3RyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LCBbXSk7XG4gICAgbGV0IHN0cjtcblxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN0ciA9IGZsb3dDaGFycy5zdGFydCArIGZsb3dDaGFycy5lbmQ7XG4gICAgfSBlbHNlIGlmIChpbkZsb3cpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZFxuICAgICAgfSA9IGZsb3dDaGFycztcbiAgICAgIGNvbnN0IHN0cmluZ3MgPSBub2Rlcy5tYXAobiA9PiBuLnN0cik7XG5cbiAgICAgIGlmIChoYXNJdGVtV2l0aE5ld0xpbmUgfHwgc3RyaW5ncy5yZWR1Y2UoKHN1bSwgc3RyKSA9PiBzdW0gKyBzdHIubGVuZ3RoICsgMiwgMikgPiBDb2xsZWN0aW9uLm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoKSB7XG4gICAgICAgIHN0ciA9IHN0YXJ0O1xuXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzdHJpbmdzKSB7XG4gICAgICAgICAgc3RyICs9IHMgPyBgXFxuJHtpbmRlbnRTdGVwfSR7aW5kZW50fSR7c31gIDogJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gYFxcbiR7aW5kZW50fSR7ZW5kfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBgJHtzdGFydH0gJHtzdHJpbmdzLmpvaW4oJyAnKX0gJHtlbmR9YDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyaW5ncyA9IG5vZGVzLm1hcChibG9ja0l0ZW0pO1xuICAgICAgc3RyID0gc3RyaW5ncy5zaGlmdCgpO1xuXG4gICAgICBmb3IgKGNvbnN0IHMgb2Ygc3RyaW5ncykgc3RyICs9IHMgPyBgXFxuJHtpbmRlbnR9JHtzfWAgOiAnXFxuJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICBzdHIgKz0gJ1xcbicgKyB0aGlzLmNvbW1lbnQucmVwbGFjZSgvXi9nbSwgYCR7aW5kZW50fSNgKTtcbiAgICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgIH0gZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSBvbkNob21wS2VlcCgpO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG59XG5cblBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KENvbGxlY3Rpb24sIFwibWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGhcIiwgNjApO1xuXG5mdW5jdGlvbiBhc0l0ZW1JbmRleChrZXkpIHtcbiAgbGV0IGlkeCA9IGtleSBpbnN0YW5jZW9mIFNjYWxhciA/IGtleS52YWx1ZSA6IGtleTtcbiAgaWYgKGlkeCAmJiB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJykgaWR4ID0gTnVtYmVyKGlkeCk7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGlkeCkgJiYgaWR4ID49IDAgPyBpZHggOiBudWxsO1xufVxuXG5jbGFzcyBZQU1MU2VxIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gIGFkZCh2YWx1ZSkge1xuICAgIHRoaXMuaXRlbXMucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXQgaW5zdGFuY2VvZiBTY2FsYXIgPyBpdC52YWx1ZSA6IGl0O1xuICB9XG5cbiAgaGFzKGtleSkge1xuICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHZhbGlkIGluZGV4LCBub3QgJHtrZXl9LmApO1xuICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICB9XG5cbiAgdG9KU09OKF8sIGN0eCkge1xuICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUoc2VxKTtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykgc2VxLnB1c2godG9KU09OKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcblxuICAgIHJldHVybiBzZXE7XG4gIH1cblxuICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBpZiAoIWN0eCkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIHJldHVybiBzdXBlci50b1N0cmluZyhjdHgsIHtcbiAgICAgIGJsb2NrSXRlbTogbiA9PiBuLnR5cGUgPT09ICdjb21tZW50JyA/IG4uc3RyIDogYC0gJHtuLnN0cn1gLFxuICAgICAgZmxvd0NoYXJzOiB7XG4gICAgICAgIHN0YXJ0OiAnWycsXG4gICAgICAgIGVuZDogJ10nXG4gICAgICB9LFxuICAgICAgaXNNYXA6IGZhbHNlLFxuICAgICAgaXRlbUluZGVudDogKGN0eC5pbmRlbnQgfHwgJycpICsgJyAgJ1xuICAgIH0sIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG5cbn1cblxuY29uc3Qgc3RyaW5naWZ5S2V5ID0gKGtleSwganNLZXksIGN0eCkgPT4ge1xuICBpZiAoanNLZXkgPT09IG51bGwpIHJldHVybiAnJztcbiAgaWYgKHR5cGVvZiBqc0tleSAhPT0gJ29iamVjdCcpIHJldHVybiBTdHJpbmcoanNLZXkpO1xuICBpZiAoa2V5IGluc3RhbmNlb2YgTm9kZSAmJiBjdHggJiYgY3R4LmRvYykgcmV0dXJuIGtleS50b1N0cmluZyh7XG4gICAgYW5jaG9yczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBkb2M6IGN0eC5kb2MsXG4gICAgaW5kZW50OiAnJyxcbiAgICBpbmRlbnRTdGVwOiBjdHguaW5kZW50U3RlcCxcbiAgICBpbkZsb3c6IHRydWUsXG4gICAgaW5TdHJpbmdpZnlLZXk6IHRydWUsXG4gICAgc3RyaW5naWZ5OiBjdHguc3RyaW5naWZ5XG4gIH0pO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNLZXkpO1xufTtcblxuY2xhc3MgUGFpciBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlID0gbnVsbCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudHlwZSA9IFBhaXIuVHlwZS5QQUlSO1xuICB9XG5cbiAgZ2V0IGNvbW1lbnRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5IGluc3RhbmNlb2YgTm9kZSA/IHRoaXMua2V5LmNvbW1lbnRCZWZvcmUgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBzZXQgY29tbWVudEJlZm9yZShjYikge1xuICAgIGlmICh0aGlzLmtleSA9PSBudWxsKSB0aGlzLmtleSA9IG5ldyBTY2FsYXIobnVsbCk7XG4gICAgaWYgKHRoaXMua2V5IGluc3RhbmNlb2YgTm9kZSkgdGhpcy5rZXkuY29tbWVudEJlZm9yZSA9IGNiO2Vsc2Uge1xuICAgICAgY29uc3QgbXNnID0gJ1BhaXIuY29tbWVudEJlZm9yZSBpcyBhbiBhbGlhcyBmb3IgUGFpci5rZXkuY29tbWVudEJlZm9yZS4gVG8gc2V0IGl0LCB0aGUga2V5IG11c3QgYmUgYSBOb2RlLic7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gIH1cblxuICBhZGRUb0pTTWFwKGN0eCwgbWFwKSB7XG4gICAgY29uc3Qga2V5ID0gdG9KU09OKHRoaXMua2V5LCAnJywgY3R4KTtcblxuICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdG9KU09OKHRoaXMudmFsdWUsIGtleSwgY3R4KTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIG1hcC5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyaW5nS2V5ID0gc3RyaW5naWZ5S2V5KHRoaXMua2V5LCBrZXksIGN0eCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRvSlNPTih0aGlzLnZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgc3RyaW5nS2V5LCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtlbHNlIG1hcFtzdHJpbmdLZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHRvSlNPTihfLCBjdHgpIHtcbiAgICBjb25zdCBwYWlyID0gY3R4ICYmIGN0eC5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmFkZFRvSlNNYXAoY3R4LCBwYWlyKTtcbiAgfVxuXG4gIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGlmICghY3R4IHx8ICFjdHguZG9jKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZW50OiBpbmRlbnRTaXplLFxuICAgICAgaW5kZW50U2VxLFxuICAgICAgc2ltcGxlS2V5c1xuICAgIH0gPSBjdHguZG9jLm9wdGlvbnM7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGtleUNvbW1lbnQgPSBrZXkgaW5zdGFuY2VvZiBOb2RlICYmIGtleS5jb21tZW50O1xuXG4gICAgaWYgKHNpbXBsZUtleXMpIHtcbiAgICAgIGlmIChrZXlDb21tZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywga2V5IG5vZGVzIGNhbm5vdCBoYXZlIGNvbW1lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHNpbXBsZSBrZXlzLCBjb2xsZWN0aW9uIGNhbm5vdCBiZSB1c2VkIGFzIGEga2V5IHZhbHVlJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGV4cGxpY2l0S2V5ID0gIXNpbXBsZUtleXMgJiYgKCFrZXkgfHwga2V5Q29tbWVudCB8fCAoa2V5IGluc3RhbmNlb2YgTm9kZSA/IGtleSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gfHwga2V5LnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5CTE9DS19GT0xERUQgfHwga2V5LnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5CTE9DS19MSVRFUkFMIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjb25zdCB7XG4gICAgICBkb2MsXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRTdGVwLFxuICAgICAgc3RyaW5naWZ5XG4gICAgfSA9IGN0eDtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXksXG4gICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeShrZXksIGN0eCwgKCkgPT4ga2V5Q29tbWVudCA9IG51bGwsICgpID0+IGNob21wS2VlcCA9IHRydWUpO1xuICAgIHN0ciA9IGFkZENvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBrZXlDb21tZW50KTtcblxuICAgIGlmICghZXhwbGljaXRLZXkgJiYgc3RyLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgIGlmIChzaW1wbGVLZXlzKSB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIHNpbmdsZSBsaW5lIHNjYWxhciBtdXN0IG5vdCBzcGFuIG1vcmUgdGhhbiAxMDI0IGNoYXJhY3RlcnMnKTtcbiAgICAgIGV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY3R4LmFsbE51bGxWYWx1ZXMgJiYgIXNpbXBsZUtleXMpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICAgICAgc3RyID0gYWRkQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIHRoaXMuY29tbWVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcEtlZXAgJiYgIWtleUNvbW1lbnQgJiYgb25DaG9tcEtlZXApIG9uQ2hvbXBLZWVwKCk7XG5cbiAgICAgIHJldHVybiBjdHguaW5GbG93ICYmICFleHBsaWNpdEtleSA/IHN0ciA6IGA/ICR7c3RyfWA7XG4gICAgfVxuXG4gICAgc3RyID0gZXhwbGljaXRLZXkgPyBgPyAke3N0cn1cXG4ke2luZGVudH06YCA6IGAke3N0cn06YDtcblxuICAgIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICAgIC8vIGV4cGVjdGVkIChidXQgbm90IHN0cmljdGx5IHJlcXVpcmVkKSB0byBiZSBhIHNpbmdsZS1saW5lIGNvbW1lbnRcbiAgICAgIHN0ciA9IGFkZENvbW1lbnQoc3RyLCBjdHguaW5kZW50LCB0aGlzLmNvbW1lbnQpO1xuICAgICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gICAgfVxuXG4gICAgbGV0IHZjYiA9ICcnO1xuICAgIGxldCB2YWx1ZUNvbW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgaWYgKHZhbHVlLnNwYWNlQmVmb3JlKSB2Y2IgPSAnXFxuJztcblxuICAgICAgaWYgKHZhbHVlLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgY29uc3QgY3MgPSB2YWx1ZS5jb21tZW50QmVmb3JlLnJlcGxhY2UoL14vZ20sIGAke2N0eC5pbmRlbnR9I2ApO1xuICAgICAgICB2Y2IgKz0gYFxcbiR7Y3N9YDtcbiAgICAgIH1cblxuICAgICAgdmFsdWVDb21tZW50ID0gdmFsdWUuY29tbWVudDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbHVlID0gZG9jLnNjaGVtYS5jcmVhdGVOb2RlKHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjdHguaW1wbGljaXRLZXkgPSBmYWxzZTtcbiAgICBpZiAoIWV4cGxpY2l0S2V5ICYmICF0aGlzLmNvbW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTY2FsYXIpIGN0eC5pbmRlbnRBdFN0YXJ0ID0gc3RyLmxlbmd0aCArIDE7XG4gICAgY2hvbXBLZWVwID0gZmFsc2U7XG5cbiAgICBpZiAoIWluZGVudFNlcSAmJiBpbmRlbnRTaXplID49IDIgJiYgIWN0eC5pbkZsb3cgJiYgIWV4cGxpY2l0S2V5ICYmIHZhbHVlIGluc3RhbmNlb2YgWUFNTFNlcSAmJiB2YWx1ZS50eXBlICE9PSBQbGFpblZhbHVlLlR5cGUuRkxPV19TRVEgJiYgIXZhbHVlLnRhZyAmJiAhZG9jLmFuY2hvcnMuZ2V0TmFtZSh2YWx1ZSkpIHtcbiAgICAgIC8vIElmIGluZGVudFNlcSA9PT0gZmFsc2UsIGNvbnNpZGVyICctICcgYXMgcGFydCBvZiBpbmRlbnRhdGlvbiB3aGVyZSBwb3NzaWJsZVxuICAgICAgY3R4LmluZGVudCA9IGN0eC5pbmRlbnQuc3Vic3RyKDIpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlU3RyID0gc3RyaW5naWZ5KHZhbHVlLCBjdHgsICgpID0+IHZhbHVlQ29tbWVudCA9IG51bGwsICgpID0+IGNob21wS2VlcCA9IHRydWUpO1xuICAgIGxldCB3cyA9ICcgJztcblxuICAgIGlmICh2Y2IgfHwgdGhpcy5jb21tZW50KSB7XG4gICAgICB3cyA9IGAke3ZjYn1cXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9IGVsc2UgaWYgKCFleHBsaWNpdEtleSAmJiB2YWx1ZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGZsb3cgPSB2YWx1ZVN0clswXSA9PT0gJ1snIHx8IHZhbHVlU3RyWzBdID09PSAneyc7XG4gICAgICBpZiAoIWZsb3cgfHwgdmFsdWVTdHIuaW5jbHVkZXMoJ1xcbicpKSB3cyA9IGBcXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlU3RyWzBdID09PSAnXFxuJykgd3MgPSAnJztcblxuICAgIGlmIChjaG9tcEtlZXAgJiYgIXZhbHVlQ29tbWVudCAmJiBvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcbiAgICByZXR1cm4gYWRkQ29tbWVudChzdHIgKyB3cyArIHZhbHVlU3RyLCBjdHguaW5kZW50LCB2YWx1ZUNvbW1lbnQpO1xuICB9XG5cbn1cblxuUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkoUGFpciwgXCJUeXBlXCIsIHtcbiAgUEFJUjogJ1BBSVInLFxuICBNRVJHRV9QQUlSOiAnTUVSR0VfUEFJUidcbn0pO1xuXG5jb25zdCBnZXRBbGlhc0NvdW50ID0gKG5vZGUsIGFuY2hvcnMpID0+IHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBbGlhcykge1xuICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvcnMuZ2V0KG5vZGUuc291cmNlKTtcbiAgICByZXR1cm4gYW5jaG9yLmNvdW50ICogYW5jaG9yLmFsaWFzQ291bnQ7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuaXRlbXMpIHtcbiAgICAgIGNvbnN0IGMgPSBnZXRBbGlhc0NvdW50KGl0ZW0sIGFuY2hvcnMpO1xuICAgICAgaWYgKGMgPiBjb3VudCkgY291bnQgPSBjO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUGFpcikge1xuICAgIGNvbnN0IGtjID0gZ2V0QWxpYXNDb3VudChub2RlLmtleSwgYW5jaG9ycyk7XG4gICAgY29uc3QgdmMgPSBnZXRBbGlhc0NvdW50KG5vZGUudmFsdWUsIGFuY2hvcnMpO1xuICAgIHJldHVybiBNYXRoLm1heChrYywgdmMpO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59O1xuXG5jbGFzcyBBbGlhcyBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgc3RyaW5naWZ5KHtcbiAgICByYW5nZSxcbiAgICBzb3VyY2VcbiAgfSwge1xuICAgIGFuY2hvcnMsXG4gICAgZG9jLFxuICAgIGltcGxpY2l0S2V5LFxuICAgIGluU3RyaW5naWZ5S2V5XG4gIH0pIHtcbiAgICBsZXQgYW5jaG9yID0gT2JqZWN0LmtleXMoYW5jaG9ycykuZmluZChhID0+IGFuY2hvcnNbYV0gPT09IHNvdXJjZSk7XG4gICAgaWYgKCFhbmNob3IgJiYgaW5TdHJpbmdpZnlLZXkpIGFuY2hvciA9IGRvYy5hbmNob3JzLmdldE5hbWUoc291cmNlKSB8fCBkb2MuYW5jaG9ycy5uZXdOYW1lKCk7XG4gICAgaWYgKGFuY2hvcikgcmV0dXJuIGAqJHthbmNob3J9JHtpbXBsaWNpdEtleSA/ICcgJyA6ICcnfWA7XG4gICAgY29uc3QgbXNnID0gZG9jLmFuY2hvcnMuZ2V0TmFtZShzb3VyY2UpID8gJ0FsaWFzIG5vZGUgbXVzdCBiZSBhZnRlciBzb3VyY2Ugbm9kZScgOiAnU291cmNlIG5vZGUgbm90IGZvdW5kIGZvciBhbGlhcyBub2RlJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bXNnfSBbJHtyYW5nZX1dYCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudHlwZSA9IFBsYWluVmFsdWUuVHlwZS5BTElBUztcbiAgfVxuXG4gIHNldCB0YWcodCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWxpYXMgbm9kZXMgY2Fubm90IGhhdmUgdGFncycpO1xuICB9XG5cbiAgdG9KU09OKGFyZywgY3R4KSB7XG4gICAgaWYgKCFjdHgpIHJldHVybiB0b0pTT04odGhpcy5zb3VyY2UsIGFyZywgY3R4KTtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JzLFxuICAgICAgbWF4QWxpYXNDb3VudFxuICAgIH0gPSBjdHg7XG4gICAgY29uc3QgYW5jaG9yID0gYW5jaG9ycy5nZXQodGhpcy5zb3VyY2UpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgaWYgKCFhbmNob3IgfHwgYW5jaG9yLnJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtc2cgPSAnVGhpcyBzaG91bGQgbm90IGhhcHBlbjogQWxpYXMgYW5jaG9yIHdhcyBub3QgcmVzb2x2ZWQ/JztcbiAgICAgIGlmICh0aGlzLmNzdE5vZGUpIHRocm93IG5ldyBQbGFpblZhbHVlLllBTUxSZWZlcmVuY2VFcnJvcih0aGlzLmNzdE5vZGUsIG1zZyk7ZWxzZSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICB9XG5cbiAgICBpZiAobWF4QWxpYXNDb3VudCA+PSAwKSB7XG4gICAgICBhbmNob3IuY291bnQgKz0gMTtcbiAgICAgIGlmIChhbmNob3IuYWxpYXNDb3VudCA9PT0gMCkgYW5jaG9yLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KHRoaXMuc291cmNlLCBhbmNob3JzKTtcblxuICAgICAgaWYgKGFuY2hvci5jb3VudCAqIGFuY2hvci5hbGlhc0NvdW50ID4gbWF4QWxpYXNDb3VudCkge1xuICAgICAgICBjb25zdCBtc2cgPSAnRXhjZXNzaXZlIGFsaWFzIGNvdW50IGluZGljYXRlcyBhIHJlc291cmNlIGV4aGF1c3Rpb24gYXR0YWNrJztcbiAgICAgICAgaWYgKHRoaXMuY3N0Tm9kZSkgdGhyb3cgbmV3IFBsYWluVmFsdWUuWUFNTFJlZmVyZW5jZUVycm9yKHRoaXMuY3N0Tm9kZSwgbXNnKTtlbHNlIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmNob3IucmVzO1xuICB9IC8vIE9ubHkgY2FsbGVkIHdoZW4gc3RyaW5naWZ5aW5nIGFuIGFsaWFzIG1hcHBpbmcga2V5IHdoaWxlIGNvbnN0cnVjdGluZ1xuICAvLyBPYmplY3Qgb3V0cHV0LlxuXG5cbiAgdG9TdHJpbmcoY3R4KSB7XG4gICAgcmV0dXJuIEFsaWFzLnN0cmluZ2lmeSh0aGlzLCBjdHgpO1xuICB9XG5cbn1cblxuUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkoQWxpYXMsIFwiZGVmYXVsdFwiLCB0cnVlKTtcblxuZnVuY3Rpb24gZmluZFBhaXIoaXRlbXMsIGtleSkge1xuICBjb25zdCBrID0ga2V5IGluc3RhbmNlb2YgU2NhbGFyID8ga2V5LnZhbHVlIDoga2V5O1xuXG4gIGZvciAoY29uc3QgaXQgb2YgaXRlbXMpIHtcbiAgICBpZiAoaXQgaW5zdGFuY2VvZiBQYWlyKSB7XG4gICAgICBpZiAoaXQua2V5ID09PSBrZXkgfHwgaXQua2V5ID09PSBrKSByZXR1cm4gaXQ7XG4gICAgICBpZiAoaXQua2V5ICYmIGl0LmtleS52YWx1ZSA9PT0gaykgcmV0dXJuIGl0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBZQU1MTWFwIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAoIXBhaXIpIHBhaXIgPSBuZXcgUGFpcihwYWlyKTtlbHNlIGlmICghKHBhaXIgaW5zdGFuY2VvZiBQYWlyKSkgcGFpciA9IG5ldyBQYWlyKHBhaXIua2V5IHx8IHBhaXIsIHBhaXIudmFsdWUpO1xuICAgIGNvbnN0IHByZXYgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBwYWlyLmtleSk7XG4gICAgY29uc3Qgc29ydEVudHJpZXMgPSB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS5zb3J0TWFwRW50cmllcztcblxuICAgIGlmIChwcmV2KSB7XG4gICAgICBpZiAob3ZlcndyaXRlKSBwcmV2LnZhbHVlID0gcGFpci52YWx1ZTtlbHNlIHRocm93IG5ldyBFcnJvcihgS2V5ICR7cGFpci5rZXl9IGFscmVhZHkgc2V0YCk7XG4gICAgfSBlbHNlIGlmIChzb3J0RW50cmllcykge1xuICAgICAgY29uc3QgaSA9IHRoaXMuaXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gc29ydEVudHJpZXMocGFpciwgaXRlbSkgPCAwKTtcbiAgICAgIGlmIChpID09PSAtMSkgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO2Vsc2UgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgcGFpcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXRlbXMucHVzaChwYWlyKTtcbiAgICB9XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgIGlmICghaXQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBkZWwgPSB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YoaXQpLCAxKTtcbiAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gIH1cblxuICBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgIGNvbnN0IG5vZGUgPSBpdCAmJiBpdC52YWx1ZTtcbiAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgbm9kZSBpbnN0YW5jZW9mIFNjYWxhciA/IG5vZGUudmFsdWUgOiBub2RlO1xuICB9XG5cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gIH1cblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuYWRkKG5ldyBQYWlyKGtleSwgdmFsdWUpLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsqfSBhcmcgaWdub3JlZFxuICAgKiBAcGFyYW0geyp9IGN0eCBDb252ZXJzaW9uIGNvbnRleHQsIG9yaWdpbmFsbHkgc2V0IGluIERvY3VtZW50I3RvSlNPTigpXG4gICAqIEBwYXJhbSB7Q2xhc3N9IFR5cGUgSWYgc2V0LCBmb3JjZXMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gdHlwZVxuICAgKiBAcmV0dXJucyB7Kn0gSW5zdGFuY2Ugb2YgVHlwZSwgTWFwLCBvciBPYmplY3RcbiAgICovXG5cblxuICB0b0pTT04oXywgY3R4LCBUeXBlKSB7XG4gICAgY29uc3QgbWFwID0gVHlwZSA/IG5ldyBUeXBlKCkgOiBjdHggJiYgY3R4Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgaWYgKGN0eCAmJiBjdHgub25DcmVhdGUpIGN0eC5vbkNyZWF0ZShtYXApO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIGl0ZW0uYWRkVG9KU01hcChjdHgsIG1hcCk7XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgaWYgKCFjdHgpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgUGFpcikpIHRocm93IG5ldyBFcnJvcihgTWFwIGl0ZW1zIG11c3QgYWxsIGJlIHBhaXJzOyBmb3VuZCAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfSBpbnN0ZWFkYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKGN0eCwge1xuICAgICAgYmxvY2tJdGVtOiBuID0+IG4uc3RyLFxuICAgICAgZmxvd0NoYXJzOiB7XG4gICAgICAgIHN0YXJ0OiAneycsXG4gICAgICAgIGVuZDogJ30nXG4gICAgICB9LFxuICAgICAgaXNNYXA6IHRydWUsXG4gICAgICBpdGVtSW5kZW50OiBjdHguaW5kZW50IHx8ICcnXG4gICAgfSwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cblxufVxuXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuY2xhc3MgTWVyZ2UgZXh0ZW5kcyBQYWlyIHtcbiAgY29uc3RydWN0b3IocGFpcikge1xuICAgIGlmIChwYWlyIGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgbGV0IHNlcSA9IHBhaXIudmFsdWU7XG5cbiAgICAgIGlmICghKHNlcSBpbnN0YW5jZW9mIFlBTUxTZXEpKSB7XG4gICAgICAgIHNlcSA9IG5ldyBZQU1MU2VxKCk7XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKHBhaXIudmFsdWUpO1xuICAgICAgICBzZXEucmFuZ2UgPSBwYWlyLnZhbHVlLnJhbmdlO1xuICAgICAgfVxuXG4gICAgICBzdXBlcihwYWlyLmtleSwgc2VxKTtcbiAgICAgIHRoaXMucmFuZ2UgPSBwYWlyLnJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlcihuZXcgU2NhbGFyKE1FUkdFX0tFWSksIG5ldyBZQU1MU2VxKCkpO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IFBhaXIuVHlwZS5NRVJHRV9QQUlSO1xuICB9IC8vIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBtZXJnZSBrZXkgaXMgYSBzaW5nbGUgbWFwcGluZyBub2RlLCBlYWNoIG9mXG4gIC8vIGl0cyBrZXkvdmFsdWUgcGFpcnMgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY3VycmVudCBtYXBwaW5nLCB1bmxlc3MgdGhlIGtleVxuICAvLyBhbHJlYWR5IGV4aXN0cyBpbiBpdC4gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVyZ2Uga2V5IGlzIGFcbiAgLy8gc2VxdWVuY2UsIHRoZW4gdGhpcyBzZXF1ZW5jZSBpcyBleHBlY3RlZCB0byBjb250YWluIG1hcHBpbmcgbm9kZXMgYW5kIGVhY2hcbiAgLy8gb2YgdGhlc2Ugbm9kZXMgaXMgbWVyZ2VkIGluIHR1cm4gYWNjb3JkaW5nIHRvIGl0cyBvcmRlciBpbiB0aGUgc2VxdWVuY2UuXG4gIC8vIEtleXMgaW4gbWFwcGluZyBub2RlcyBlYXJsaWVyIGluIHRoZSBzZXF1ZW5jZSBvdmVycmlkZSBrZXlzIHNwZWNpZmllZCBpblxuICAvLyBsYXRlciBtYXBwaW5nIG5vZGVzLiAtLSBodHRwOi8veWFtbC5vcmcvdHlwZS9tZXJnZS5odG1sXG5cblxuICBhZGRUb0pTTWFwKGN0eCwgbWFwKSB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzb3VyY2VcbiAgICB9IG9mIHRoaXMudmFsdWUuaXRlbXMpIHtcbiAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFlBTUxNYXApKSB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzJyk7XG4gICAgICBjb25zdCBzcmNNYXAgPSBzb3VyY2UudG9KU09OKG51bGwsIGN0eCwgTWFwKTtcblxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSkgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQpIHtcbiAgICBjb25zdCBzZXEgPSB0aGlzLnZhbHVlO1xuICAgIGlmIChzZXEuaXRlbXMubGVuZ3RoID4gMSkgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKGN0eCwgb25Db21tZW50KTtcbiAgICB0aGlzLnZhbHVlID0gc2VxLml0ZW1zWzBdO1xuICAgIGNvbnN0IHN0ciA9IHN1cGVyLnRvU3RyaW5nKGN0eCwgb25Db21tZW50KTtcbiAgICB0aGlzLnZhbHVlID0gc2VxO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxufVxuXG5jb25zdCBiaW5hcnlPcHRpb25zID0ge1xuICBkZWZhdWx0VHlwZTogUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0xJVEVSQUwsXG4gIGxpbmVXaWR0aDogNzZcbn07XG5jb25zdCBib29sT3B0aW9ucyA9IHtcbiAgdHJ1ZVN0cjogJ3RydWUnLFxuICBmYWxzZVN0cjogJ2ZhbHNlJ1xufTtcbmNvbnN0IGludE9wdGlvbnMgPSB7XG4gIGFzQmlnSW50OiBmYWxzZVxufTtcbmNvbnN0IG51bGxPcHRpb25zID0ge1xuICBudWxsU3RyOiAnbnVsbCdcbn07XG5jb25zdCBzdHJPcHRpb25zID0ge1xuICBkZWZhdWx0VHlwZTogUGxhaW5WYWx1ZS5UeXBlLlBMQUlOLFxuICBkb3VibGVRdW90ZWQ6IHtcbiAgICBqc29uRW5jb2Rpbmc6IGZhbHNlLFxuICAgIG1pbk11bHRpTGluZUxlbmd0aDogNDBcbiAgfSxcbiAgZm9sZDoge1xuICAgIGxpbmVXaWR0aDogODAsXG4gICAgbWluQ29udGVudFdpZHRoOiAyMFxuICB9XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlU2NhbGFyKHN0ciwgdGFncywgc2NhbGFyRmFsbGJhY2spIHtcbiAgZm9yIChjb25zdCB7XG4gICAgZm9ybWF0LFxuICAgIHRlc3QsXG4gICAgcmVzb2x2ZVxuICB9IG9mIHRhZ3MpIHtcbiAgICBpZiAodGVzdCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2godGVzdCk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBsZXQgcmVzID0gcmVzb2x2ZS5hcHBseShudWxsLCBtYXRjaCk7XG4gICAgICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIFNjYWxhcikpIHJlcyA9IG5ldyBTY2FsYXIocmVzKTtcbiAgICAgICAgaWYgKGZvcm1hdCkgcmVzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2NhbGFyRmFsbGJhY2spIHN0ciA9IHNjYWxhckZhbGxiYWNrKHN0cik7XG4gIHJldHVybiBuZXcgU2NhbGFyKHN0cik7XG59XG5cbmNvbnN0IEZPTERfRkxPVyA9ICdmbG93JztcbmNvbnN0IEZPTERfQkxPQ0sgPSAnYmxvY2snO1xuY29uc3QgRk9MRF9RVU9URUQgPSAncXVvdGVkJzsgLy8gcHJlc3VtZXMgaSsxIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmVcbi8vIHJldHVybnMgaW5kZXggb2YgbGFzdCBuZXdsaW5lIGluIG1vcmUtaW5kZW50ZWQgYmxvY2tcblxuY29uc3QgY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzID0gKHRleHQsIGkpID0+IHtcbiAgbGV0IGNoID0gdGV4dFtpICsgMV07XG5cbiAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgZG8ge1xuICAgICAgY2ggPSB0ZXh0W2kgKz0gMV07XG4gICAgfSB3aGlsZSAoY2ggJiYgY2ggIT09ICdcXG4nKTtcblxuICAgIGNoID0gdGV4dFtpICsgMV07XG4gIH1cblxuICByZXR1cm4gaTtcbn07XG4vKipcbiAqIFRyaWVzIHRvIGtlZXAgaW5wdXQgYXQgdXAgdG8gYGxpbmVXaWR0aGAgY2hhcmFjdGVycywgc3BsaXR0aW5nIG9ubHkgb24gc3BhY2VzXG4gKiBub3QgZm9sbG93ZWQgYnkgbmV3bGluZXMgb3Igc3BhY2VzIHVubGVzcyBgbW9kZWAgaXMgYCdxdW90ZWQnYC4gTGluZXMgYXJlXG4gKiB0ZXJtaW5hdGVkIHdpdGggYFxcbmAgYW5kIHN0YXJ0ZWQgd2l0aCBgaW5kZW50YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGluZGVudFxuICogQHBhcmFtIHtzdHJpbmd9IFttb2RlPSdmbG93J10gYCdibG9jaydgIHByZXZlbnRzIG1vcmUtaW5kZW50ZWQgbGluZXNcbiAqICAgZnJvbSBiZWluZyBmb2xkZWQ7IGAncXVvdGVkJ2AgYWxsb3dzIGZvciBgXFxgIGVzY2FwZXMsIGluY2x1ZGluZyBlc2NhcGVkXG4gKiAgIG5ld2xpbmVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmluZGVudEF0U3RhcnRdIEFjY291bnRzIGZvciBsZWFkaW5nIGNvbnRlbnRzIG9uXG4gKiAgIHRoZSBmaXJzdCBsaW5lLCBkZWZhdWx0aW5nIHRvIGBpbmRlbnQubGVuZ3RoYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbmVXaWR0aD04MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5Db250ZW50V2lkdGg9MjBdIEFsbG93IGhpZ2hseSBpbmRlbnRlZCBsaW5lcyB0b1xuICogICBzdHJldGNoIHRoZSBsaW5lIHdpZHRoIG9yIGluZGVudCBjb250ZW50IGZyb20gdGhlIHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLm9uRm9sZCBDYWxsZWQgb25jZSBpZiB0aGUgdGV4dCBpcyBmb2xkZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMub25Gb2xkIENhbGxlZCBvbmNlIGlmIGFueSBsaW5lIG9mIHRleHQgZXhjZWVkc1xuICogICBsaW5lV2lkdGggY2hhcmFjdGVyc1xuICovXG5cblxuZnVuY3Rpb24gZm9sZEZsb3dMaW5lcyh0ZXh0LCBpbmRlbnQsIG1vZGUsIHtcbiAgaW5kZW50QXRTdGFydCxcbiAgbGluZVdpZHRoID0gODAsXG4gIG1pbkNvbnRlbnRXaWR0aCA9IDIwLFxuICBvbkZvbGQsXG4gIG9uT3ZlcmZsb3dcbn0pIHtcbiAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMCkgcmV0dXJuIHRleHQ7XG4gIGNvbnN0IGVuZFN0ZXAgPSBNYXRoLm1heCgxICsgbWluQ29udGVudFdpZHRoLCAxICsgbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aCk7XG4gIGlmICh0ZXh0Lmxlbmd0aCA8PSBlbmRTdGVwKSByZXR1cm4gdGV4dDtcbiAgY29uc3QgZm9sZHMgPSBbXTtcbiAgY29uc3QgZXNjYXBlZEZvbGRzID0ge307XG4gIGxldCBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoO1xuXG4gIGlmICh0eXBlb2YgaW5kZW50QXRTdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoaW5kZW50QXRTdGFydCA+IGxpbmVXaWR0aCAtIE1hdGgubWF4KDIsIG1pbkNvbnRlbnRXaWR0aCkpIGZvbGRzLnB1c2goMCk7ZWxzZSBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnRBdFN0YXJ0O1xuICB9XG5cbiAgbGV0IHNwbGl0ID0gdW5kZWZpbmVkO1xuICBsZXQgcHJldiA9IHVuZGVmaW5lZDtcbiAgbGV0IG92ZXJmbG93ID0gZmFsc2U7XG4gIGxldCBpID0gLTE7XG4gIGxldCBlc2NTdGFydCA9IC0xO1xuICBsZXQgZXNjRW5kID0gLTE7XG5cbiAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spIHtcbiAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpO1xuICAgIGlmIChpICE9PSAtMSkgZW5kID0gaSArIGVuZFN0ZXA7XG4gIH1cblxuICBmb3IgKGxldCBjaDsgY2ggPSB0ZXh0W2kgKz0gMV07KSB7XG4gICAgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEICYmIGNoID09PSAnXFxcXCcpIHtcbiAgICAgIGVzY1N0YXJ0ID0gaTtcblxuICAgICAgc3dpdGNoICh0ZXh0W2kgKyAxXSkge1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgZXNjRW5kID0gaTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKTtcbiAgICAgIGVuZCA9IGkgKyBlbmRTdGVwO1xuICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaCA9PT0gJyAnICYmIHByZXYgJiYgcHJldiAhPT0gJyAnICYmIHByZXYgIT09ICdcXG4nICYmIHByZXYgIT09ICdcXHQnKSB7XG4gICAgICAgIC8vIHNwYWNlIHN1cnJvdW5kZWQgYnkgbm9uLXNwYWNlIGNhbiBiZSByZXBsYWNlZCB3aXRoIG5ld2xpbmUgKyBpbmRlbnRcbiAgICAgICAgY29uc3QgbmV4dCA9IHRleHRbaSArIDFdO1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSAnICcgJiYgbmV4dCAhPT0gJ1xcbicgJiYgbmV4dCAhPT0gJ1xcdCcpIHNwbGl0ID0gaTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPj0gZW5kKSB7XG4gICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgIGZvbGRzLnB1c2goc3BsaXQpO1xuICAgICAgICAgIGVuZCA9IHNwbGl0ICsgZW5kU3RlcDtcbiAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCkge1xuICAgICAgICAgIC8vIHdoaXRlLXNwYWNlIGNvbGxlY3RlZCBhdCBlbmQgbWF5IHN0cmV0Y2ggcGFzdCBsaW5lV2lkdGhcbiAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBwcmV2ID0gY2g7XG4gICAgICAgICAgICBjaCA9IHRleHRbaSArPSAxXTtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIEFjY291bnQgZm9yIG5ld2xpbmUgZXNjYXBlLCBidXQgZG9uJ3QgYnJlYWsgcHJlY2VkaW5nIGVzY2FwZVxuXG5cbiAgICAgICAgICBjb25zdCBqID0gaSA+IGVzY0VuZCArIDEgPyBpIC0gMiA6IGVzY1N0YXJ0IC0gMTsgLy8gQmFpbCBvdXQgaWYgbGluZVdpZHRoICYgbWluQ29udGVudFdpZHRoIGFyZSBzaG9ydGVyIHRoYW4gYW4gZXNjYXBlIHN0cmluZ1xuXG4gICAgICAgICAgaWYgKGVzY2FwZWRGb2xkc1tqXSkgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgZm9sZHMucHVzaChqKTtcbiAgICAgICAgICBlc2NhcGVkRm9sZHNbal0gPSB0cnVlO1xuICAgICAgICAgIGVuZCA9IGogKyBlbmRTdGVwO1xuICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHByZXYgPSBjaDtcbiAgfVxuXG4gIGlmIChvdmVyZmxvdyAmJiBvbk92ZXJmbG93KSBvbk92ZXJmbG93KCk7XG4gIGlmIChmb2xkcy5sZW5ndGggPT09IDApIHJldHVybiB0ZXh0O1xuICBpZiAob25Gb2xkKSBvbkZvbGQoKTtcbiAgbGV0IHJlcyA9IHRleHQuc2xpY2UoMCwgZm9sZHNbMF0pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBmb2xkID0gZm9sZHNbaV07XG4gICAgY29uc3QgZW5kID0gZm9sZHNbaSArIDFdIHx8IHRleHQubGVuZ3RoO1xuICAgIGlmIChmb2xkID09PSAwKSByZXMgPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKDAsIGVuZCl9YDtlbHNlIHtcbiAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBlc2NhcGVkRm9sZHNbZm9sZF0pIHJlcyArPSBgJHt0ZXh0W2ZvbGRdfVxcXFxgO1xuICAgICAgcmVzICs9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoZm9sZCArIDEsIGVuZCl9YDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBnZXRGb2xkT3B0aW9ucyA9ICh7XG4gIGluZGVudEF0U3RhcnRcbn0pID0+IGluZGVudEF0U3RhcnQgPyBPYmplY3QuYXNzaWduKHtcbiAgaW5kZW50QXRTdGFydFxufSwgc3RyT3B0aW9ucy5mb2xkKSA6IHN0ck9wdGlvbnMuZm9sZDsgLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuXG5cbmNvbnN0IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIgPSBzdHIgPT4gL14oJXwtLS18XFwuXFwuXFwuKS9tLnRlc3Qoc3RyKTtcblxuZnVuY3Rpb24gbGluZUxlbmd0aE92ZXJMaW1pdChzdHIsIGxpbmVXaWR0aCwgaW5kZW50TGVuZ3RoKSB7XG4gIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gIGNvbnN0IHN0ckxlbiA9IHN0ci5sZW5ndGg7XG4gIGlmIChzdHJMZW4gPD0gbGltaXQpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMCwgc3RhcnQgPSAwOyBpIDwgc3RyTGVuOyArK2kpIHtcbiAgICBpZiAoc3RyW2ldID09PSAnXFxuJykge1xuICAgICAgaWYgKGkgLSBzdGFydCA+IGxpbWl0KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICBpZiAoc3RyTGVuIC0gc3RhcnQgPD0gbGltaXQpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgY29uc3Qge1xuICAgIGltcGxpY2l0S2V5XG4gIH0gPSBjdHg7XG4gIGNvbnN0IHtcbiAgICBqc29uRW5jb2RpbmcsXG4gICAgbWluTXVsdGlMaW5lTGVuZ3RoXG4gIH0gPSBzdHJPcHRpb25zLmRvdWJsZVF1b3RlZDtcbiAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgaWYgKGpzb25FbmNvZGluZykgcmV0dXJuIGpzb247XG4gIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgbGV0IHN0ciA9ICcnO1xuICBsZXQgc3RhcnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwLCBjaCA9IGpzb25baV07IGNoOyBjaCA9IGpzb25bKytpXSkge1xuICAgIGlmIChjaCA9PT0gJyAnICYmIGpzb25baSArIDFdID09PSAnXFxcXCcgJiYganNvbltpICsgMl0gPT09ICduJykge1xuICAgICAgLy8gc3BhY2UgYmVmb3JlIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG4gICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxcXCAnO1xuICAgICAgaSArPSAxO1xuICAgICAgc3RhcnQgPSBpO1xuICAgICAgY2ggPSAnXFxcXCc7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgICB7XG4gICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgIGNvbnN0IGNvZGUgPSBqc29uLnN1YnN0cihpICsgMiwgNCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJzAwMDAnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzAwMDcnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxhJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzAwMGInOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx2JztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzAwMWInOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxlJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzAwODUnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxOJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzAwYTAnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxfJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzIwMjgnOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxMJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzIwMjknOlxuICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxQJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChjb2RlLnN1YnN0cigwLCAyKSA9PT0gJzAwJykgc3RyICs9ICdcXFxceCcgKyBjb2RlLnN1YnN0cigyKTtlbHNlIHN0ciArPSBqc29uLnN1YnN0cihpLCA2KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbic6XG4gICAgICAgIGlmIChpbXBsaWNpdEtleSB8fCBqc29uW2kgKyAyXSA9PT0gJ1wiJyB8fCBqc29uLmxlbmd0aCA8IG1pbk11bHRpTGluZUxlbmd0aCkge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmb2xkaW5nIHdpbGwgZWF0IGZpcnN0IG5ld2xpbmVcbiAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxuXFxuJztcblxuICAgICAgICAgIHdoaWxlIChqc29uW2kgKyAyXSA9PT0gJ1xcXFwnICYmIGpzb25baSArIDNdID09PSAnbicgJiYganNvbltpICsgNF0gIT09ICdcIicpIHtcbiAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHIgKz0gaW5kZW50OyAvLyBzcGFjZSBhZnRlciBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuXG4gICAgICAgICAgaWYgKGpzb25baSArIDJdID09PSAnICcpIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaSArPSAxO1xuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHN0YXJ0ID8gc3RyICsganNvbi5zbGljZShzdGFydCkgOiBqc29uO1xuICByZXR1cm4gaW1wbGljaXRLZXkgPyBzdHIgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX1FVT1RFRCwgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gIGlmIChjdHguaW1wbGljaXRLZXkpIHtcbiAgICBpZiAoL1xcbi8udGVzdCh2YWx1ZSkpIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gc2luZ2xlIHF1b3RlZCBzdHJpbmcgY2FuJ3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgYXJvdW5kIG5ld2xpbmVcbiAgICBpZiAoL1sgXFx0XVxcbnxcXG5bIFxcdF0vLnRlc3QodmFsdWUpKSByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9XG5cbiAgY29uc3QgaW5kZW50ID0gY3R4LmluZGVudCB8fCAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICBjb25zdCByZXMgPSBcIidcIiArIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApICsgXCInXCI7XG4gIHJldHVybiBjdHguaW1wbGljaXRLZXkgPyByZXMgOiBmb2xkRmxvd0xpbmVzKHJlcywgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuXG5mdW5jdGlvbiBibG9ja1N0cmluZyh7XG4gIGNvbW1lbnQsXG4gIHR5cGUsXG4gIHZhbHVlXG59LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgLy8gMS4gQmxvY2sgY2FuJ3QgZW5kIGluIHdoaXRlc3BhY2UgdW5sZXNzIHRoZSBsYXN0IGxpbmUgaXMgbm9uLWVtcHR5LlxuICAvLyAyLiBTdHJpbmdzIGNvbnNpc3Rpbmcgb2Ygb25seSB3aGl0ZXNwYWNlIGFyZSBiZXN0IHJlbmRlcmVkIGV4cGxpY2l0bHkuXG4gIGlmICgvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpIHx8IC9eXFxzKiQvLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgY29uc3QgaW5kZW50U2l6ZSA9IGluZGVudCA/ICcyJyA6ICcxJzsgLy8gcm9vdCBpcyBhdCAtMVxuXG4gIGNvbnN0IGxpdGVyYWwgPSB0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfRk9MREVEID8gZmFsc2UgOiB0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfTElURVJBTCA/IHRydWUgOiAhbGluZUxlbmd0aE92ZXJMaW1pdCh2YWx1ZSwgc3RyT3B0aW9ucy5mb2xkLmxpbmVXaWR0aCwgaW5kZW50Lmxlbmd0aCk7XG4gIGxldCBoZWFkZXIgPSBsaXRlcmFsID8gJ3wnIDogJz4nO1xuICBpZiAoIXZhbHVlKSByZXR1cm4gaGVhZGVyICsgJ1xcbic7XG4gIGxldCB3c1N0YXJ0ID0gJyc7XG4gIGxldCB3c0VuZCA9ICcnO1xuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1tcXG5cXHQgXSokLywgd3MgPT4ge1xuICAgIGNvbnN0IG4gPSB3cy5pbmRleE9mKCdcXG4nKTtcblxuICAgIGlmIChuID09PSAtMSkge1xuICAgICAgaGVhZGVyICs9ICctJzsgLy8gc3RyaXBcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB3cyB8fCBuICE9PSB3cy5sZW5ndGggLSAxKSB7XG4gICAgICBoZWFkZXIgKz0gJysnOyAvLyBrZWVwXG5cbiAgICAgIGlmIChvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcbiAgICB9XG5cbiAgICB3c0VuZCA9IHdzLnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgcmV0dXJuICcnO1xuICB9KS5yZXBsYWNlKC9eW1xcbiBdKi8sIHdzID0+IHtcbiAgICBpZiAod3MuaW5kZXhPZignICcpICE9PSAtMSkgaGVhZGVyICs9IGluZGVudFNpemU7XG4gICAgY29uc3QgbSA9IHdzLm1hdGNoKC8gKyQvKTtcblxuICAgIGlmIChtKSB7XG4gICAgICB3c1N0YXJ0ID0gd3Muc2xpY2UoMCwgLW1bMF0ubGVuZ3RoKTtcbiAgICAgIHJldHVybiBtWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3c1N0YXJ0ID0gd3M7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9KTtcbiAgaWYgKHdzRW5kKSB3c0VuZCA9IHdzRW5kLnJlcGxhY2UoL1xcbisoPyFcXG58JCkvZywgYCQmJHtpbmRlbnR9YCk7XG4gIGlmICh3c1N0YXJ0KSB3c1N0YXJ0ID0gd3NTdGFydC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuXG4gIGlmIChjb21tZW50KSB7XG4gICAgaGVhZGVyICs9ICcgIycgKyBjb21tZW50LnJlcGxhY2UoLyA/W1xcclxcbl0rL2csICcgJyk7XG4gICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gIH1cblxuICBpZiAoIXZhbHVlKSByZXR1cm4gYCR7aGVhZGVyfSR7aW5kZW50U2l6ZX1cXG4ke2luZGVudH0ke3dzRW5kfWA7XG5cbiAgaWYgKGxpdGVyYWwpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgcmV0dXJuIGAke2hlYWRlcn1cXG4ke2luZGVudH0ke3dzU3RhcnR9JHt2YWx1ZX0ke3dzRW5kfWA7XG4gIH1cblxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgJ1xcbiQmJykucmVwbGFjZSgvKD86XnxcXG4pKFtcXHQgXS4qKSg/OihbXFxuXFx0IF0qKVxcbig/IVtcXG5cXHQgXSkpPy9nLCAnJDEkMicpIC8vIG1vcmUtaW5kZW50ZWQgbGluZXMgYXJlbid0IGZvbGRlZFxuICAvLyAgICAgICAgIF4gaW5kLmxpbmUgIF4gZW1wdHkgICAgIF4gY2FwdHVyZSBuZXh0IGVtcHR5IGxpbmVzIG9ubHkgYXQgZW5kIG9mIGluZGVudFxuICAucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgY29uc3QgYm9keSA9IGZvbGRGbG93TGluZXMoYCR7d3NTdGFydH0ke3ZhbHVlfSR7d3NFbmR9YCwgaW5kZW50LCBGT0xEX0JMT0NLLCBzdHJPcHRpb25zLmZvbGQpO1xuICByZXR1cm4gYCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7Ym9keX1gO1xufVxuXG5mdW5jdGlvbiBwbGFpblN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgY29uc3Qge1xuICAgIGNvbW1lbnQsXG4gICAgdHlwZSxcbiAgICB2YWx1ZVxuICB9ID0gaXRlbTtcbiAgY29uc3Qge1xuICAgIGFjdHVhbFN0cmluZyxcbiAgICBpbXBsaWNpdEtleSxcbiAgICBpbmRlbnQsXG4gICAgaW5GbG93XG4gIH0gPSBjdHg7XG5cbiAgaWYgKGltcGxpY2l0S2V5ICYmIC9bXFxuW1xcXXt9LF0vLnRlc3QodmFsdWUpIHx8IGluRmxvdyAmJiAvW1tcXF17fSxdLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH1cblxuICBpZiAoIXZhbHVlIHx8IC9eW1xcblxcdCAsW1xcXXt9IyYqIXw+J1wiJUBgXXxeWz8tXSR8Xls/LV1bIFxcdF18W1xcbjpdWyBcXHRdfFsgXFx0XVxcbnxbXFxuXFx0IF0jfFtcXG5cXHQgOl0kLy50ZXN0KHZhbHVlKSkge1xuICAgIC8vIG5vdCBhbGxvd2VkOlxuICAgIC8vIC0gZW1wdHkgc3RyaW5nLCAnLScgb3IgJz8nXG4gICAgLy8gLSBzdGFydCB3aXRoIGFuIGluZGljYXRvciBjaGFyYWN0ZXIgKGV4Y2VwdCBbPzotXSkgb3IgL1s/LV0gL1xuICAgIC8vIC0gJ1xcbiAnLCAnOiAnIG9yICcgXFxuJyBhbnl3aGVyZVxuICAgIC8vIC0gJyMnIG5vdCBwcmVjZWRlZCBieSBhIG5vbi1zcGFjZSBjaGFyXG4gICAgLy8gLSBlbmQgd2l0aCAnICcgb3IgJzonXG4gICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvdyB8fCB2YWx1ZS5pbmRleE9mKCdcXG4nKSA9PT0gLTEgPyB2YWx1ZS5pbmRleE9mKCdcIicpICE9PSAtMSAmJiB2YWx1ZS5pbmRleE9mKFwiJ1wiKSA9PT0gLTEgPyBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkgOiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkgOiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG5cbiAgaWYgKCFpbXBsaWNpdEtleSAmJiAhaW5GbG93ICYmIHR5cGUgIT09IFBsYWluVmFsdWUuVHlwZS5QTEFJTiAmJiB2YWx1ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAvLyBXaGVyZSBhbGxvd2VkICYgdHlwZSBub3Qgc2V0IGV4cGxpY2l0bHksIHByZWZlciBibG9jayBzdHlsZSBmb3IgbXVsdGlsaW5lIHN0cmluZ3NcbiAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG4gIGlmIChpbmRlbnQgPT09ICcnICYmIGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpKSB7XG4gICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSB0cnVlO1xuICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG5cbiAgY29uc3Qgc3RyID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKTsgLy8gVmVyaWZ5IHRoYXQgb3V0cHV0IHdpbGwgYmUgcGFyc2VkIGFzIGEgc3RyaW5nLCBhcyBlLmcuIHBsYWluIG51bWJlcnMgYW5kXG4gIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgLy8gYW5kIG90aGVycyBpbiB2MS4xLlxuXG4gIGlmIChhY3R1YWxTdHJpbmcpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdzXG4gICAgfSA9IGN0eC5kb2Muc2NoZW1hO1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVNjYWxhcihzdHIsIHRhZ3MsIHRhZ3Muc2NhbGFyRmFsbGJhY2spLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZWQgIT09ICdzdHJpbmcnKSByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9XG5cbiAgY29uc3QgYm9keSA9IGltcGxpY2l0S2V5ID8gc3RyIDogZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgRk9MRF9GTE9XLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcblxuICBpZiAoY29tbWVudCAmJiAhaW5GbG93ICYmIChib2R5LmluZGV4T2YoJ1xcbicpICE9PSAtMSB8fCBjb21tZW50LmluZGV4T2YoJ1xcbicpICE9PSAtMSkpIHtcbiAgICBpZiAob25Db21tZW50KSBvbkNvbW1lbnQoKTtcbiAgICByZXR1cm4gYWRkQ29tbWVudEJlZm9yZShib2R5LCBpbmRlbnQsIGNvbW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGJvZHk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRUeXBlXG4gIH0gPSBzdHJPcHRpb25zO1xuICBjb25zdCB7XG4gICAgaW1wbGljaXRLZXksXG4gICAgaW5GbG93XG4gIH0gPSBjdHg7XG4gIGxldCB7XG4gICAgdHlwZSxcbiAgICB2YWx1ZVxuICB9ID0gaXRlbTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwge1xuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IF9zdHJpbmdpZnkgPSBfdHlwZSA9PiB7XG4gICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfRk9MREVEOlxuICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfTElURVJBTDpcbiAgICAgICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLlFVT1RFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcblxuICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuUVVPVEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gc2luZ2xlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuXG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5QTEFJTjpcbiAgICAgICAgcmV0dXJuIHBsYWluU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZSAhPT0gUGxhaW5WYWx1ZS5UeXBlLlFVT1RFX0RPVUJMRSAmJiAvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5Zl0vLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnNcbiAgICB0eXBlID0gUGxhaW5WYWx1ZS5UeXBlLlFVT1RFX0RPVUJMRTtcbiAgfSBlbHNlIGlmICgoaW1wbGljaXRLZXkgfHwgaW5GbG93KSAmJiAodHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0ZPTERFRCB8fCB0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfTElURVJBTCkpIHtcbiAgICAvLyBzaG91bGQgbm90IGhhcHBlbjsgYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgIHR5cGUgPSBQbGFpblZhbHVlLlR5cGUuUVVPVEVfRE9VQkxFO1xuICB9XG5cbiAgbGV0IHJlcyA9IF9zdHJpbmdpZnkodHlwZSk7XG5cbiAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgIHJlcyA9IF9zdHJpbmdpZnkoZGVmYXVsdFR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke2RlZmF1bHRUeXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5TnVtYmVyKHtcbiAgZm9ybWF0LFxuICBtaW5GcmFjdGlvbkRpZ2l0cyxcbiAgdGFnLFxuICB2YWx1ZVxufSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JykgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gaXNOYU4odmFsdWUpID8gJy5uYW4nIDogdmFsdWUgPCAwID8gJy0uaW5mJyA6ICcuaW5mJztcbiAgbGV0IG4gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgaWYgKCFmb3JtYXQgJiYgbWluRnJhY3Rpb25EaWdpdHMgJiYgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJiAvXlxcZC8udGVzdChuKSkge1xuICAgIGxldCBpID0gbi5pbmRleE9mKCcuJyk7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgIG4gKz0gJy4nO1xuICAgIH1cblxuICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG5cbiAgICB3aGlsZSAoZC0tID4gMCkgbiArPSAnMCc7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gY2hlY2tGbG93Q29sbGVjdGlvbkVuZChlcnJvcnMsIGNzdCkge1xuICBsZXQgY2hhciwgbmFtZTtcblxuICBzd2l0Y2ggKGNzdC50eXBlKSB7XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuRkxPV19NQVA6XG4gICAgICBjaGFyID0gJ30nO1xuICAgICAgbmFtZSA9ICdmbG93IG1hcCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkZMT1dfU0VROlxuICAgICAgY2hhciA9ICddJztcbiAgICAgIG5hbWUgPSAnZmxvdyBzZXF1ZW5jZSc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihjc3QsICdOb3QgYSBmbG93IGNvbGxlY3Rpb24hPycpKTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBsYXN0SXRlbTtcblxuICBmb3IgKGxldCBpID0gY3N0Lml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgaXRlbSA9IGNzdC5pdGVtc1tpXTtcblxuICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgIT09IFBsYWluVmFsdWUuVHlwZS5DT01NRU5UKSB7XG4gICAgICBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAobGFzdEl0ZW0gJiYgbGFzdEl0ZW0uY2hhciAhPT0gY2hhcikge1xuICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCAke25hbWV9IHRvIGVuZCB3aXRoICR7Y2hhcn1gO1xuICAgIGxldCBlcnI7XG5cbiAgICBpZiAodHlwZW9mIGxhc3RJdGVtLm9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVyciA9IG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgIGVyci5vZmZzZXQgPSBsYXN0SXRlbS5vZmZzZXQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnIgPSBuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihsYXN0SXRlbSwgbXNnKTtcbiAgICAgIGlmIChsYXN0SXRlbS5yYW5nZSAmJiBsYXN0SXRlbS5yYW5nZS5lbmQpIGVyci5vZmZzZXQgPSBsYXN0SXRlbS5yYW5nZS5lbmQgLSBsYXN0SXRlbS5yYW5nZS5zdGFydDtcbiAgICB9XG5cbiAgICBlcnJvcnMucHVzaChlcnIpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0Zsb3dDb21tZW50U3BhY2UoZXJyb3JzLCBjb21tZW50KSB7XG4gIGNvbnN0IHByZXYgPSBjb21tZW50LmNvbnRleHQuc3JjW2NvbW1lbnQucmFuZ2Uuc3RhcnQgLSAxXTtcblxuICBpZiAocHJldiAhPT0gJ1xcbicgJiYgcHJldiAhPT0gJ1xcdCcgJiYgcHJldiAhPT0gJyAnKSB7XG4gICAgY29uc3QgbXNnID0gJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnO1xuICAgIGVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGNvbW1lbnQsIG1zZykpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb25nS2V5RXJyb3Ioc291cmNlLCBrZXkpIHtcbiAgY29uc3Qgc2sgPSBTdHJpbmcoa2V5KTtcbiAgY29uc3QgayA9IHNrLnN1YnN0cigwLCA4KSArICcuLi4nICsgc2suc3Vic3RyKC04KTtcbiAgcmV0dXJuIG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKHNvdXJjZSwgYFRoZSBcIiR7a31cIiBrZXkgaXMgdG9vIGxvbmdgKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb21tZW50cyhjb2xsZWN0aW9uLCBjb21tZW50cykge1xuICBmb3IgKGNvbnN0IHtcbiAgICBhZnRlcktleSxcbiAgICBiZWZvcmUsXG4gICAgY29tbWVudFxuICB9IG9mIGNvbW1lbnRzKSB7XG4gICAgbGV0IGl0ZW0gPSBjb2xsZWN0aW9uLml0ZW1zW2JlZm9yZV07XG5cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24uY29tbWVudCkgY29sbGVjdGlvbi5jb21tZW50ICs9ICdcXG4nICsgY29tbWVudDtlbHNlIGNvbGxlY3Rpb24uY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhZnRlcktleSAmJiBpdGVtLnZhbHVlKSBpdGVtID0gaXRlbS52YWx1ZTtcblxuICAgICAgaWYgKGNvbW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYWZ0ZXJLZXkgfHwgIWl0ZW0uY29tbWVudEJlZm9yZSkgaXRlbS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBpdGVtLmNvbW1lbnRCZWZvcmUgKz0gJ1xcbicgKyBjb21tZW50O2Vsc2UgaXRlbS5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gb24gZXJyb3IsIHdpbGwgcmV0dXJuIHsgc3RyOiBzdHJpbmcsIGVycm9yczogRXJyb3JbXSB9XG5mdW5jdGlvbiByZXNvbHZlU3RyaW5nKGRvYywgbm9kZSkge1xuICBjb25zdCByZXMgPSBub2RlLnN0clZhbHVlO1xuICBpZiAoIXJlcykgcmV0dXJuICcnO1xuICBpZiAodHlwZW9mIHJlcyA9PT0gJ3N0cmluZycpIHJldHVybiByZXM7XG4gIHJlcy5lcnJvcnMuZm9yRWFjaChlcnJvciA9PiB7XG4gICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgfSk7XG4gIHJldHVybiByZXMuc3RyO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFnSGFuZGxlKGRvYywgbm9kZSkge1xuICBjb25zdCB7XG4gICAgaGFuZGxlLFxuICAgIHN1ZmZpeFxuICB9ID0gbm9kZS50YWc7XG4gIGxldCBwcmVmaXggPSBkb2MudGFnUHJlZml4ZXMuZmluZChwID0+IHAuaGFuZGxlID09PSBoYW5kbGUpO1xuXG4gIGlmICghcHJlZml4KSB7XG4gICAgY29uc3QgZHRwID0gZG9jLmdldERlZmF1bHRzKCkudGFnUHJlZml4ZXM7XG4gICAgaWYgKGR0cCkgcHJlZml4ID0gZHRwLmZpbmQocCA9PiBwLmhhbmRsZSA9PT0gaGFuZGxlKTtcbiAgICBpZiAoIXByZWZpeCkgdGhyb3cgbmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgYFRoZSAke2hhbmRsZX0gdGFnIGhhbmRsZSBpcyBub24tZGVmYXVsdCBhbmQgd2FzIG5vdCBkZWNsYXJlZC5gKTtcbiAgfVxuXG4gIGlmICghc3VmZml4KSB0aHJvdyBuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihub2RlLCBgVGhlICR7aGFuZGxlfSB0YWcgaGFzIG5vIHN1ZmZpeC5gKTtcblxuICBpZiAoaGFuZGxlID09PSAnIScgJiYgKGRvYy52ZXJzaW9uIHx8IGRvYy5vcHRpb25zLnZlcnNpb24pID09PSAnMS4wJykge1xuICAgIGlmIChzdWZmaXhbMF0gPT09ICdeJykge1xuICAgICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFdhcm5pbmcobm9kZSwgJ1lBTUwgMS4wIF4gdGFnIGV4cGFuc2lvbiBpcyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgcmV0dXJuIHN1ZmZpeDtcbiAgICB9XG5cbiAgICBpZiAoL1s6L10vLnRlc3Qoc3VmZml4KSkge1xuICAgICAgLy8gd29yZC9mb28gLT4gdGFnOndvcmQueWFtbC5vcmcsMjAwMjpmb29cbiAgICAgIGNvbnN0IHZvY2FiID0gc3VmZml4Lm1hdGNoKC9eKFthLXowLTktXSspXFwvKC4qKS9pKTtcbiAgICAgIHJldHVybiB2b2NhYiA/IGB0YWc6JHt2b2NhYlsxXX0ueWFtbC5vcmcsMjAwMjoke3ZvY2FiWzJdfWAgOiBgdGFnOiR7c3VmZml4fWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZWZpeC5wcmVmaXggKyBkZWNvZGVVUklDb21wb25lbnQoc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZ05hbWUoZG9jLCBub2RlKSB7XG4gIGNvbnN0IHtcbiAgICB0YWcsXG4gICAgdHlwZVxuICB9ID0gbm9kZTtcbiAgbGV0IG5vblNwZWNpZmljID0gZmFsc2U7XG5cbiAgaWYgKHRhZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZSxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHZlcmJhdGltXG4gICAgfSA9IHRhZztcblxuICAgIGlmICh2ZXJiYXRpbSkge1xuICAgICAgaWYgKHZlcmJhdGltICE9PSAnIScgJiYgdmVyYmF0aW0gIT09ICchIScpIHJldHVybiB2ZXJiYXRpbTtcbiAgICAgIGNvbnN0IG1zZyA9IGBWZXJiYXRpbSB0YWdzIGFyZW4ndCByZXNvbHZlZCwgc28gJHt2ZXJiYXRpbX0gaXMgaW52YWxpZC5gO1xuICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlID09PSAnIScgJiYgIXN1ZmZpeCkge1xuICAgICAgbm9uU3BlY2lmaWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVRhZ0hhbmRsZShkb2MsIG5vZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5CTE9DS19GT0xERUQ6XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfTElURVJBTDpcbiAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5RVU9URV9ET1VCTEU6XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuUVVPVEVfU0lOR0xFOlxuICAgICAgcmV0dXJuIFBsYWluVmFsdWUuZGVmYXVsdFRhZ3MuU1RSO1xuXG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuRkxPV19NQVA6XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuTUFQOlxuICAgICAgcmV0dXJuIFBsYWluVmFsdWUuZGVmYXVsdFRhZ3MuTUFQO1xuXG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuRkxPV19TRVE6XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuU0VROlxuICAgICAgcmV0dXJuIFBsYWluVmFsdWUuZGVmYXVsdFRhZ3MuU0VRO1xuXG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuUExBSU46XG4gICAgICByZXR1cm4gbm9uU3BlY2lmaWMgPyBQbGFpblZhbHVlLmRlZmF1bHRUYWdzLlNUUiA6IG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJ5VGFnTmFtZShkb2MsIG5vZGUsIHRhZ05hbWUpIHtcbiAgY29uc3Qge1xuICAgIHRhZ3NcbiAgfSA9IGRvYy5zY2hlbWE7XG4gIGNvbnN0IG1hdGNoV2l0aFRlc3QgPSBbXTtcblxuICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgaWYgKHRhZy50YWcgPT09IHRhZ05hbWUpIHtcbiAgICAgIGlmICh0YWcudGVzdCkgbWF0Y2hXaXRoVGVzdC5wdXNoKHRhZyk7ZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKGRvYywgbm9kZSk7XG4gICAgICAgIHJldHVybiByZXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uID8gcmVzIDogbmV3IFNjYWxhcihyZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ciA9IHJlc29sdmVTdHJpbmcoZG9jLCBub2RlKTtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIG1hdGNoV2l0aFRlc3QubGVuZ3RoID4gMCkgcmV0dXJuIHJlc29sdmVTY2FsYXIoc3RyLCBtYXRjaFdpdGhUZXN0LCB0YWdzLnNjYWxhckZhbGxiYWNrKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEZhbGxiYWNrVGFnTmFtZSh7XG4gIHR5cGVcbn0pIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuRkxPV19NQVA6XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuTUFQOlxuICAgICAgcmV0dXJuIFBsYWluVmFsdWUuZGVmYXVsdFRhZ3MuTUFQO1xuXG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuRkxPV19TRVE6XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuU0VROlxuICAgICAgcmV0dXJuIFBsYWluVmFsdWUuZGVmYXVsdFRhZ3MuU0VRO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQbGFpblZhbHVlLmRlZmF1bHRUYWdzLlNUUjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFnKGRvYywgbm9kZSwgdGFnTmFtZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IHJlc29sdmVCeVRhZ05hbWUoZG9jLCBub2RlLCB0YWdOYW1lKTtcblxuICAgIGlmIChyZXMpIHtcbiAgICAgIGlmICh0YWdOYW1lICYmIG5vZGUudGFnKSByZXMudGFnID0gdGFnTmFtZTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZXJyb3Iuc291cmNlKSBlcnJvci5zb3VyY2UgPSBub2RlO1xuICAgIGRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGZhbGxiYWNrID0gZ2V0RmFsbGJhY2tUYWdOYW1lKG5vZGUpO1xuICAgIGlmICghZmFsbGJhY2spIHRocm93IG5ldyBFcnJvcihgVGhlIHRhZyAke3RhZ05hbWV9IGlzIHVuYXZhaWxhYmxlYCk7XG4gICAgY29uc3QgbXNnID0gYFRoZSB0YWcgJHt0YWdOYW1lfSBpcyB1bmF2YWlsYWJsZSwgZmFsbGluZyBiYWNrIHRvICR7ZmFsbGJhY2t9YDtcbiAgICBkb2Mud2FybmluZ3MucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MV2FybmluZyhub2RlLCBtc2cpKTtcbiAgICBjb25zdCByZXMgPSByZXNvbHZlQnlUYWdOYW1lKGRvYywgbm9kZSwgZmFsbGJhY2spO1xuICAgIHJlcy50YWcgPSB0YWdOYW1lO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgcmVmRXJyb3IgPSBuZXcgUGxhaW5WYWx1ZS5ZQU1MUmVmZXJlbmNlRXJyb3Iobm9kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgcmVmRXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICBkb2MuZXJyb3JzLnB1c2gocmVmRXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmNvbnN0IGlzQ29sbGVjdGlvbkl0ZW0gPSBub2RlID0+IHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHtcbiAgICB0eXBlXG4gIH0gPSBub2RlO1xuICByZXR1cm4gdHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLk1BUF9LRVkgfHwgdHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLk1BUF9WQUxVRSB8fCB0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuU0VRX0lURU07XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlTm9kZVByb3BzKGVycm9ycywgbm9kZSkge1xuICBjb25zdCBjb21tZW50cyA9IHtcbiAgICBiZWZvcmU6IFtdLFxuICAgIGFmdGVyOiBbXVxuICB9O1xuICBsZXQgaGFzQW5jaG9yID0gZmFsc2U7XG4gIGxldCBoYXNUYWcgPSBmYWxzZTtcbiAgY29uc3QgcHJvcHMgPSBpc0NvbGxlY3Rpb25JdGVtKG5vZGUuY29udGV4dC5wYXJlbnQpID8gbm9kZS5jb250ZXh0LnBhcmVudC5wcm9wcy5jb25jYXQobm9kZS5wcm9wcykgOiBub2RlLnByb3BzO1xuXG4gIGZvciAoY29uc3Qge1xuICAgIHN0YXJ0LFxuICAgIGVuZFxuICB9IG9mIHByb3BzKSB7XG4gICAgc3dpdGNoIChub2RlLmNvbnRleHQuc3JjW3N0YXJ0XSkge1xuICAgICAgY2FzZSBQbGFpblZhbHVlLkNoYXIuQ09NTUVOVDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbm9kZS5jb21tZW50SGFzUmVxdWlyZWRXaGl0ZXNwYWNlKHN0YXJ0KSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgdmFsdWVSYW5nZVxuICAgICAgICAgIH0gPSBub2RlO1xuICAgICAgICAgIGNvbnN0IGNjID0gdmFsdWVSYW5nZSAmJiAoc3RhcnQgPiB2YWx1ZVJhbmdlLnN0YXJ0IHx8IGhlYWRlciAmJiBzdGFydCA+IGhlYWRlci5zdGFydCkgPyBjb21tZW50cy5hZnRlciA6IGNvbW1lbnRzLmJlZm9yZTtcbiAgICAgICAgICBjYy5wdXNoKG5vZGUuY29udGV4dC5zcmMuc2xpY2Uoc3RhcnQgKyAxLCBlbmQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gQWN0dWFsIGFuY2hvciAmIHRhZyByZXNvbHV0aW9uIGlzIGhhbmRsZWQgYnkgc2NoZW1hLCBoZXJlIHdlIGp1c3QgY29tcGxhaW5cblxuICAgICAgY2FzZSBQbGFpblZhbHVlLkNoYXIuQU5DSE9SOlxuICAgICAgICBpZiAoaGFzQW5jaG9yKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InO1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzQW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5DaGFyLlRBRzpcbiAgICAgICAgaWYgKGhhc1RhZykge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgdGFnJztcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1RhZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tbWVudHMsXG4gICAgaGFzQW5jaG9yLFxuICAgIGhhc1RhZ1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTm9kZVZhbHVlKGRvYywgbm9kZSkge1xuICBjb25zdCB7XG4gICAgYW5jaG9ycyxcbiAgICBlcnJvcnMsXG4gICAgc2NoZW1hXG4gIH0gPSBkb2M7XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkFMSUFTKSB7XG4gICAgY29uc3QgbmFtZSA9IG5vZGUucmF3VmFsdWU7XG4gICAgY29uc3Qgc3JjID0gYW5jaG9ycy5nZXROb2RlKG5hbWUpO1xuXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBBbGlhc2VkIGFuY2hvciBub3QgZm91bmQ6ICR7bmFtZX1gO1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFJlZmVyZW5jZUVycm9yKG5vZGUsIG1zZykpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBMYXp5IHJlc29sdXRpb24gZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcblxuXG4gICAgY29uc3QgcmVzID0gbmV3IEFsaWFzKHNyYyk7XG5cbiAgICBhbmNob3JzLl9jc3RBbGlhc2VzLnB1c2gocmVzKTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBjb25zdCB0YWdOYW1lID0gcmVzb2x2ZVRhZ05hbWUoZG9jLCBub2RlKTtcbiAgaWYgKHRhZ05hbWUpIHJldHVybiByZXNvbHZlVGFnKGRvYywgbm9kZSwgdGFnTmFtZSk7XG5cbiAgaWYgKG5vZGUudHlwZSAhPT0gUGxhaW5WYWx1ZS5UeXBlLlBMQUlOKSB7XG4gICAgY29uc3QgbXNnID0gYEZhaWxlZCB0byByZXNvbHZlICR7bm9kZS50eXBlfSBub2RlIGhlcmVgO1xuICAgIGVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTeW50YXhFcnJvcihub2RlLCBtc2cpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RyID0gcmVzb2x2ZVN0cmluZyhkb2MsIG5vZGUpO1xuICAgIHJldHVybiByZXNvbHZlU2NhbGFyKHN0ciwgc2NoZW1hLnRhZ3MsIHNjaGVtYS50YWdzLnNjYWxhckZhbGxiYWNrKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIWVycm9yLnNvdXJjZSkgZXJyb3Iuc291cmNlID0gbm9kZTtcbiAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0gLy8gc2V0cyBub2RlLnJlc29sdmVkIG9uIHN1Y2Nlc3NcblxuXG5mdW5jdGlvbiByZXNvbHZlTm9kZShkb2MsIG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgaWYgKG5vZGUuZXJyb3IpIGRvYy5lcnJvcnMucHVzaChub2RlLmVycm9yKTtcbiAgY29uc3Qge1xuICAgIGNvbW1lbnRzLFxuICAgIGhhc0FuY2hvcixcbiAgICBoYXNUYWdcbiAgfSA9IHJlc29sdmVOb2RlUHJvcHMoZG9jLmVycm9ycywgbm9kZSk7XG5cbiAgaWYgKGhhc0FuY2hvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcnNcbiAgICB9ID0gZG9jO1xuICAgIGNvbnN0IG5hbWUgPSBub2RlLmFuY2hvcjtcbiAgICBjb25zdCBwcmV2ID0gYW5jaG9ycy5nZXROb2RlKG5hbWUpOyAvLyBBdCB0aGlzIHBvaW50LCBhbGlhc2VzIGZvciBhbnkgcHJlY2VkaW5nIG5vZGUgd2l0aCB0aGUgc2FtZSBhbmNob3JcbiAgICAvLyBuYW1lIGhhdmUgYWxyZWFkeSBiZWVuIHJlc29sdmVkLCBzbyBpdCBtYXkgc2FmZWx5IGJlIHJlbmFtZWQuXG5cbiAgICBpZiAocHJldikgYW5jaG9ycy5tYXBbYW5jaG9ycy5uZXdOYW1lKG5hbWUpXSA9IHByZXY7IC8vIER1cmluZyBwYXJzaW5nLCB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBDU1Qgbm9kZSBpbiBhbmNob3JzLm1hcCBhc1xuICAgIC8vIGFuY2hvcnMgbmVlZCB0byBiZSBhdmFpbGFibGUgZHVyaW5nIHJlc29sdXRpb24gdG8gYWxsb3cgZm9yXG4gICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICAgIGFuY2hvcnMubWFwW25hbWVdID0gbm9kZTtcbiAgfVxuXG4gIGlmIChub2RlLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5BTElBUyAmJiAoaGFzQW5jaG9yIHx8IGhhc1RhZykpIHtcbiAgICBjb25zdCBtc2cgPSAnQW4gYWxpYXMgbm9kZSBtdXN0IG5vdCBzcGVjaWZ5IGFueSBwcm9wZXJ0aWVzJztcbiAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgbXNnKSk7XG4gIH1cblxuICBjb25zdCByZXMgPSByZXNvbHZlTm9kZVZhbHVlKGRvYywgbm9kZSk7XG5cbiAgaWYgKHJlcykge1xuICAgIHJlcy5yYW5nZSA9IFtub2RlLnJhbmdlLnN0YXJ0LCBub2RlLnJhbmdlLmVuZF07XG4gICAgaWYgKGRvYy5vcHRpb25zLmtlZXBDc3ROb2RlcykgcmVzLmNzdE5vZGUgPSBub2RlO1xuICAgIGlmIChkb2Mub3B0aW9ucy5rZWVwTm9kZVR5cGVzKSByZXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICBjb25zdCBjYiA9IGNvbW1lbnRzLmJlZm9yZS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChjYikge1xuICAgICAgcmVzLmNvbW1lbnRCZWZvcmUgPSByZXMuY29tbWVudEJlZm9yZSA/IGAke3Jlcy5jb21tZW50QmVmb3JlfVxcbiR7Y2J9YCA6IGNiO1xuICAgIH1cblxuICAgIGNvbnN0IGNhID0gY29tbWVudHMuYWZ0ZXIuam9pbignXFxuJyk7XG4gICAgaWYgKGNhKSByZXMuY29tbWVudCA9IHJlcy5jb21tZW50ID8gYCR7cmVzLmNvbW1lbnR9XFxuJHtjYX1gIDogY2E7XG4gIH1cblxuICByZXR1cm4gbm9kZS5yZXNvbHZlZCA9IHJlcztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1hcChkb2MsIGNzdCkge1xuICBpZiAoY3N0LnR5cGUgIT09IFBsYWluVmFsdWUuVHlwZS5NQVAgJiYgY3N0LnR5cGUgIT09IFBsYWluVmFsdWUuVHlwZS5GTE9XX01BUCkge1xuICAgIGNvbnN0IG1zZyA9IGBBICR7Y3N0LnR5cGV9IG5vZGUgY2Fubm90IGJlIHJlc29sdmVkIGFzIGEgbWFwcGluZ2A7XG4gICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTeW50YXhFcnJvcihjc3QsIG1zZykpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGNvbW1lbnRzLFxuICAgIGl0ZW1zXG4gIH0gPSBjc3QudHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkZMT1dfTUFQID8gcmVzb2x2ZUZsb3dNYXBJdGVtcyhkb2MsIGNzdCkgOiByZXNvbHZlQmxvY2tNYXBJdGVtcyhkb2MsIGNzdCk7XG4gIGNvbnN0IG1hcCA9IG5ldyBZQU1MTWFwKCk7XG4gIG1hcC5pdGVtcyA9IGl0ZW1zO1xuICByZXNvbHZlQ29tbWVudHMobWFwLCBjb21tZW50cyk7XG4gIGxldCBoYXNDb2xsZWN0aW9uS2V5ID0gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGtleTogaUtleVxuICAgIH0gPSBpdGVtc1tpXTtcbiAgICBpZiAoaUtleSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIGhhc0NvbGxlY3Rpb25LZXkgPSB0cnVlO1xuXG4gICAgaWYgKGRvYy5zY2hlbWEubWVyZ2UgJiYgaUtleSAmJiBpS2V5LnZhbHVlID09PSBNRVJHRV9LRVkpIHtcbiAgICAgIGl0ZW1zW2ldID0gbmV3IE1lcmdlKGl0ZW1zW2ldKTtcbiAgICAgIGNvbnN0IHNvdXJjZXMgPSBpdGVtc1tpXS52YWx1ZS5pdGVtcztcbiAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICBzb3VyY2VzLnNvbWUobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQWxpYXMpIHtcbiAgICAgICAgICAvLyBEdXJpbmcgcGFyc2luZywgYWxpYXMgc291cmNlcyBhcmUgQ1NUIG5vZGVzOyB0byBhY2NvdW50IGZvclxuICAgICAgICAgIC8vIGNpcmN1bGFyIHJlZmVyZW5jZXMgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzIGNhbid0IGJlIHVzZWQgaGVyZS5cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSA9IG5vZGUuc291cmNlO1xuICAgICAgICAgIGlmICh0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuTUFQIHx8IHR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5GTE9XX01BUCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlcnJvciA9ICdNZXJnZSBub2RlcyBhbGlhc2VzIGNhbiBvbmx5IHBvaW50IHRvIG1hcHMnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yID0gJ01lcmdlIG5vZGVzIGNhbiBvbmx5IGhhdmUgQWxpYXMgbm9kZXMgYXMgdmFsdWVzJztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVycm9yKSBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoY3N0LCBlcnJvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAga2V5OiBqS2V5XG4gICAgICAgIH0gPSBpdGVtc1tqXTtcblxuICAgICAgICBpZiAoaUtleSA9PT0gaktleSB8fCBpS2V5ICYmIGpLZXkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlLZXksICd2YWx1ZScpICYmIGlLZXkudmFsdWUgPT09IGpLZXkudmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgTWFwIGtleXMgbXVzdCBiZSB1bmlxdWU7IFwiJHtpS2V5fVwiIGlzIHJlcGVhdGVkYDtcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoY3N0LCBtc2cpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNDb2xsZWN0aW9uS2V5ICYmICFkb2Mub3B0aW9ucy5tYXBBc01hcCkge1xuICAgIGNvbnN0IHdhcm4gPSAnS2V5cyB3aXRoIGNvbGxlY3Rpb24gdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgWUFNTCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9ucy4gVXNlIG1hcEFzTWFwOiB0cnVlIHRvIGF2b2lkIHRoaXMuJztcbiAgICBkb2Mud2FybmluZ3MucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MV2FybmluZyhjc3QsIHdhcm4pKTtcbiAgfVxuXG4gIGNzdC5yZXNvbHZlZCA9IG1hcDtcbiAgcmV0dXJuIG1hcDtcbn1cblxuY29uc3QgdmFsdWVIYXNQYWlyQ29tbWVudCA9ICh7XG4gIGNvbnRleHQ6IHtcbiAgICBsaW5lU3RhcnQsXG4gICAgbm9kZSxcbiAgICBzcmNcbiAgfSxcbiAgcHJvcHNcbn0pID0+IHtcbiAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7XG4gICAgc3RhcnRcbiAgfSA9IHByb3BzWzBdO1xuICBpZiAobm9kZSAmJiBzdGFydCA+IG5vZGUudmFsdWVSYW5nZS5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoc3JjW3N0YXJ0XSAhPT0gUGxhaW5WYWx1ZS5DaGFyLkNPTU1FTlQpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gbGluZVN0YXJ0OyBpIDwgc3RhcnQ7ICsraSkgaWYgKHNyY1tpXSA9PT0gJ1xcbicpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWlyQ29tbWVudChpdGVtLCBwYWlyKSB7XG4gIGlmICghdmFsdWVIYXNQYWlyQ29tbWVudChpdGVtKSkgcmV0dXJuO1xuICBjb25zdCBjb21tZW50ID0gaXRlbS5nZXRQcm9wVmFsdWUoMCwgUGxhaW5WYWx1ZS5DaGFyLkNPTU1FTlQsIHRydWUpO1xuICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgY29uc3QgY2IgPSBwYWlyLnZhbHVlLmNvbW1lbnRCZWZvcmU7XG5cbiAgaWYgKGNiICYmIGNiLnN0YXJ0c1dpdGgoY29tbWVudCkpIHtcbiAgICBwYWlyLnZhbHVlLmNvbW1lbnRCZWZvcmUgPSBjYi5zdWJzdHIoY29tbWVudC5sZW5ndGggKyAxKTtcbiAgICBmb3VuZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2MgPSBwYWlyLnZhbHVlLmNvbW1lbnQ7XG5cbiAgICBpZiAoIWl0ZW0ubm9kZSAmJiBjYyAmJiBjYy5zdGFydHNXaXRoKGNvbW1lbnQpKSB7XG4gICAgICBwYWlyLnZhbHVlLmNvbW1lbnQgPSBjYy5zdWJzdHIoY29tbWVudC5sZW5ndGggKyAxKTtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmQpIHBhaXIuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja01hcEl0ZW1zKGRvYywgY3N0KSB7XG4gIGNvbnN0IGNvbW1lbnRzID0gW107XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGxldCBrZXkgPSB1bmRlZmluZWQ7XG4gIGxldCBrZXlTdGFydCA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3QuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkJMQU5LX0xJTkU6XG4gICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGFmdGVyS2V5OiAhIWtleSxcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkNPTU1FTlQ6XG4gICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGFmdGVyS2V5OiAhIWtleSxcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICBjb21tZW50OiBpdGVtLmNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5NQVBfS0VZOlxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG4gICAgICAgIGtleSA9IHJlc29sdmVOb2RlKGRvYywgaXRlbS5ub2RlKTtcbiAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuTUFQX1ZBTFVFOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBudWxsO1xuICAgICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG5cbiAgICAgICAgICBpZiAoIWl0ZW0uY29udGV4dC5hdExpbmVTdGFydCAmJiBpdGVtLm5vZGUgJiYgaXRlbS5ub2RlLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5NQVAgJiYgIWl0ZW0ubm9kZS5jb250ZXh0LmF0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnTmVzdGVkIG1hcHBpbmdzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wYWN0IG1hcHBpbmdzJztcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihpdGVtLm5vZGUsIG1zZykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB2YWx1ZU5vZGUgPSBpdGVtLm5vZGU7XG5cbiAgICAgICAgICBpZiAoIXZhbHVlTm9kZSAmJiBpdGVtLnByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvbW1lbnRzIG9uIGFuIGVtcHR5IG1hcHBpbmcgdmFsdWUgbmVlZCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNvbnN0cnVjdCBhIG1pbmltYWwgZW1wdHkgbm9kZSBoZXJlIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZVxuICAgICAgICAgICAgLy8gbWlzc2luZyBgaXRlbS5ub2RlYC4gLS0gZWVtZWxpL3lhbWwjMTlcbiAgICAgICAgICAgIHZhbHVlTm9kZSA9IG5ldyBQbGFpblZhbHVlLlBsYWluVmFsdWUoUGxhaW5WYWx1ZS5UeXBlLlBMQUlOLCBbXSk7XG4gICAgICAgICAgICB2YWx1ZU5vZGUuY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBpdGVtLFxuICAgICAgICAgICAgICBzcmM6IGl0ZW0uY29udGV4dC5zcmNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBpdGVtLnJhbmdlLnN0YXJ0ICsgMTtcbiAgICAgICAgICAgIHZhbHVlTm9kZS5yYW5nZSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgICAgICAgICAgZW5kOiBwb3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZU5vZGUudmFsdWVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgICAgICAgICAgZW5kOiBwb3NcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS5yYW5nZS5vcmlnU3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdQb3MgPSBpdGVtLnJhbmdlLm9yaWdTdGFydCArIDE7XG4gICAgICAgICAgICAgIHZhbHVlTm9kZS5yYW5nZS5vcmlnU3RhcnQgPSB2YWx1ZU5vZGUucmFuZ2Uub3JpZ0VuZCA9IG9yaWdQb3M7XG4gICAgICAgICAgICAgIHZhbHVlTm9kZS52YWx1ZVJhbmdlLm9yaWdTdGFydCA9IHZhbHVlTm9kZS52YWx1ZVJhbmdlLm9yaWdFbmQgPSBvcmlnUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXksIHJlc29sdmVOb2RlKGRvYywgdmFsdWVOb2RlKSk7XG4gICAgICAgICAgcmVzb2x2ZVBhaXJDb21tZW50KGl0ZW0sIHBhaXIpO1xuICAgICAgICAgIGl0ZW1zLnB1c2gocGFpcik7XG5cbiAgICAgICAgICBpZiAoa2V5ICYmIHR5cGVvZiBrZXlTdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnJhbmdlLnN0YXJ0ID4ga2V5U3RhcnQgKyAxMDI0KSBkb2MuZXJyb3JzLnB1c2goZ2V0TG9uZ0tleUVycm9yKGNzdCwga2V5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICBrZXkgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0pO1xuICAgICAgICBrZXlTdGFydCA9IGl0ZW0ucmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtLmVycm9yKSBkb2MuZXJyb3JzLnB1c2goaXRlbS5lcnJvcik7XG5cbiAgICAgICAgbmV4dDogZm9yIChsZXQgaiA9IGkgKyAxOzsgKytqKSB7XG4gICAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSBjc3QuaXRlbXNbal07XG5cbiAgICAgICAgICBzd2l0Y2ggKG5leHRJdGVtICYmIG5leHRJdGVtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkJMQU5LX0xJTkU6XG4gICAgICAgICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5DT01NRU5UOlxuICAgICAgICAgICAgICBjb250aW51ZSBuZXh0O1xuXG4gICAgICAgICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5NQVBfVkFMVUU6XG4gICAgICAgICAgICAgIGJyZWFrIG5leHQ7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnSW1wbGljaXQgbWFwIGtleXMgbmVlZCB0byBiZSBmb2xsb3dlZCBieSBtYXAgdmFsdWVzJztcbiAgICAgICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgbXNnKSk7XG4gICAgICAgICAgICAgICAgYnJlYWsgbmV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLnZhbHVlUmFuZ2VDb250YWluc05ld2xpbmUpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnSW1wbGljaXQgbWFwIGtleXMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJztcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgbXNnKSk7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tZW50cyxcbiAgICBpdGVtc1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRmxvd01hcEl0ZW1zKGRvYywgY3N0KSB7XG4gIGNvbnN0IGNvbW1lbnRzID0gW107XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGxldCBrZXkgPSB1bmRlZmluZWQ7XG4gIGxldCBleHBsaWNpdEtleSA9IGZhbHNlO1xuICBsZXQgbmV4dCA9ICd7JztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNzdC5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0uY2hhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2hhcixcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gaXRlbTtcblxuICAgICAgaWYgKGNoYXIgPT09ICc/JyAmJiBrZXkgPT09IHVuZGVmaW5lZCAmJiAhZXhwbGljaXRLZXkpIHtcbiAgICAgICAgZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBuZXh0ID0gJzonO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXIgPT09ICc6Jykge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIGtleSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG5leHQgPT09ICc6Jykge1xuICAgICAgICAgIG5leHQgPSAnLCc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChleHBsaWNpdEtleSkge1xuICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCAmJiBjaGFyICE9PSAnLCcpIGtleSA9IG51bGw7XG4gICAgICAgICAgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGNoYXIgPT09ICcsJykge1xuICAgICAgICAgICAgbmV4dCA9ICc6JztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhciA9PT0gJ30nKSB7XG4gICAgICAgIGlmIChpID09PSBjc3QuaXRlbXMubGVuZ3RoIC0gMSkgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IG5leHQpIHtcbiAgICAgICAgbmV4dCA9ICc6JztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1zZyA9IGBGbG93IG1hcCBjb250YWlucyBhbiB1bmV4cGVjdGVkICR7Y2hhcn1gO1xuICAgICAgY29uc3QgZXJyID0gbmV3IFBsYWluVmFsdWUuWUFNTFN5bnRheEVycm9yKGNzdCwgbXNnKTtcbiAgICAgIGVyci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBkb2MuZXJyb3JzLnB1c2goZXJyKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkJMQU5LX0xJTkUpIHtcbiAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICBhZnRlcktleTogISFrZXksXG4gICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkNPTU1FTlQpIHtcbiAgICAgIGNoZWNrRmxvd0NvbW1lbnRTcGFjZShkb2MuZXJyb3JzLCBpdGVtKTtcbiAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICBhZnRlcktleTogISFrZXksXG4gICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoLFxuICAgICAgICBjb21tZW50OiBpdGVtLmNvbW1lbnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChuZXh0ID09PSAnLCcpIGRvYy5lcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihpdGVtLCAnU2VwYXJhdG9yICwgbWlzc2luZyBpbiBmbG93IG1hcCcpKTtcbiAgICAgIGtleSA9IHJlc29sdmVOb2RlKGRvYywgaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0ICE9PSAnLCcpIGRvYy5lcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihpdGVtLCAnSW5kaWNhdG9yIDogbWlzc2luZyBpbiBmbG93IG1hcCBlbnRyeScpKTtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5LCByZXNvbHZlTm9kZShkb2MsIGl0ZW0pKSk7XG4gICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRmxvd0NvbGxlY3Rpb25FbmQoZG9jLmVycm9ycywgY3N0KTtcbiAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICByZXR1cm4ge1xuICAgIGNvbW1lbnRzLFxuICAgIGl0ZW1zXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTZXEoZG9jLCBjc3QpIHtcbiAgaWYgKGNzdC50eXBlICE9PSBQbGFpblZhbHVlLlR5cGUuU0VRICYmIGNzdC50eXBlICE9PSBQbGFpblZhbHVlLlR5cGUuRkxPV19TRVEpIHtcbiAgICBjb25zdCBtc2cgPSBgQSAke2NzdC50eXBlfSBub2RlIGNhbm5vdCBiZSByZXNvbHZlZCBhcyBhIHNlcXVlbmNlYDtcbiAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFN5bnRheEVycm9yKGNzdCwgbXNnKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfSA9IGNzdC50eXBlID09PSBQbGFpblZhbHVlLlR5cGUuRkxPV19TRVEgPyByZXNvbHZlRmxvd1NlcUl0ZW1zKGRvYywgY3N0KSA6IHJlc29sdmVCbG9ja1NlcUl0ZW1zKGRvYywgY3N0KTtcbiAgY29uc3Qgc2VxID0gbmV3IFlBTUxTZXEoKTtcbiAgc2VxLml0ZW1zID0gaXRlbXM7XG4gIHJlc29sdmVDb21tZW50cyhzZXEsIGNvbW1lbnRzKTtcblxuICBpZiAoIWRvYy5vcHRpb25zLm1hcEFzTWFwICYmIGl0ZW1zLnNvbWUoaXQgPT4gaXQgaW5zdGFuY2VvZiBQYWlyICYmIGl0LmtleSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pKSB7XG4gICAgY29uc3Qgd2FybiA9ICdLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBhcyBZQU1MIGR1ZSB0byBKUyBPYmplY3QgcmVzdHJpY3Rpb25zLiBVc2UgbWFwQXNNYXA6IHRydWUgdG8gYXZvaWQgdGhpcy4nO1xuICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxXYXJuaW5nKGNzdCwgd2FybikpO1xuICB9XG5cbiAgY3N0LnJlc29sdmVkID0gc2VxO1xuICByZXR1cm4gc2VxO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTZXFJdGVtcyhkb2MsIGNzdCkge1xuICBjb25zdCBjb21tZW50cyA9IFtdO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IGNzdC5pdGVtc1tpXTtcblxuICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5CTEFOS19MSU5FOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkNPTU1FTlQ6XG4gICAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGNvbW1lbnQ6IGl0ZW0uY29tbWVudCxcbiAgICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLlNFUV9JVEVNOlxuICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuICAgICAgICBpdGVtcy5wdXNoKHJlc29sdmVOb2RlKGRvYywgaXRlbS5ub2RlKSk7XG5cbiAgICAgICAgaWYgKGl0ZW0uaGFzUHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnU2VxdWVuY2UgaXRlbXMgY2Fubm90IGhhdmUgdGFncyBvciBhbmNob3JzIGJlZm9yZSB0aGUgLSBpbmRpY2F0b3InO1xuICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihpdGVtLCBtc2cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFN5bnRheEVycm9yKGl0ZW0sIGBVbmV4cGVjdGVkICR7aXRlbS50eXBlfSBub2RlIGluIHNlcXVlbmNlYCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dTZXFJdGVtcyhkb2MsIGNzdCkge1xuICBjb25zdCBjb21tZW50cyA9IFtdO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBsZXQgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgbGV0IGtleSA9IHVuZGVmaW5lZDtcbiAgbGV0IGtleVN0YXJ0ID0gbnVsbDtcbiAgbGV0IG5leHQgPSAnWyc7XG4gIGxldCBwcmV2SXRlbSA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3QuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmNoYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoYXIsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGl0ZW07XG5cbiAgICAgIGlmIChjaGFyICE9PSAnOicgJiYgKGV4cGxpY2l0S2V5IHx8IGtleSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBpZiAoZXhwbGljaXRLZXkgJiYga2V5ID09PSB1bmRlZmluZWQpIGtleSA9IG5leHQgPyBpdGVtcy5wb3AoKSA6IG51bGw7XG4gICAgICAgIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAga2V5U3RhcnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhciA9PT0gbmV4dCkge1xuICAgICAgICBuZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIW5leHQgJiYgY2hhciA9PT0gJz8nKSB7XG4gICAgICAgIGV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dCAhPT0gJ1snICYmIGNoYXIgPT09ICc6JyAmJiBrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobmV4dCA9PT0gJywnKSB7XG4gICAgICAgICAga2V5ID0gaXRlbXMucG9wKCk7XG5cbiAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ0NoYWluaW5nIGZsb3cgc2VxdWVuY2UgcGFpcnMgaXMgaW52YWxpZCc7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihjc3QsIG1zZyk7XG4gICAgICAgICAgICBlcnIub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleHBsaWNpdEtleSAmJiB0eXBlb2Yga2V5U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlFbmQgPSBpdGVtLnJhbmdlID8gaXRlbS5yYW5nZS5zdGFydCA6IGl0ZW0ub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGtleUVuZCA+IGtleVN0YXJ0ICsgMTAyNCkgZG9jLmVycm9ycy5wdXNoKGdldExvbmdLZXlFcnJvcihjc3QsIGtleSkpO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIH0gPSBwcmV2SXRlbS5jb250ZXh0O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0ga2V5U3RhcnQ7IGkgPCBrZXlFbmQ7ICsraSkgaWYgKHNyY1tpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnO1xuICAgICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IocHJldkl0ZW0sIG1zZykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgICAgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5leHQgPT09ICdbJyB8fCBjaGFyICE9PSAnXScgfHwgaSA8IGNzdC5pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBGbG93IHNlcXVlbmNlIGNvbnRhaW5zIGFuIHVuZXhwZWN0ZWQgJHtjaGFyfWA7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBQbGFpblZhbHVlLllBTUxTeW50YXhFcnJvcihjc3QsIG1zZyk7XG4gICAgICAgIGVyci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGRvYy5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQkxBTktfTElORSkge1xuICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkNPTU1FTlQpIHtcbiAgICAgIGNoZWNrRmxvd0NvbW1lbnRTcGFjZShkb2MuZXJyb3JzLCBpdGVtKTtcbiAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICBjb21tZW50OiBpdGVtLmNvbW1lbnQsXG4gICAgICAgIGJlZm9yZTogaXRlbXMubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIGEgJHtuZXh0fSBpbiBmbG93IHNlcXVlbmNlYDtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sIG1zZykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmVOb2RlKGRvYywgaXRlbSk7XG5cbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgcHJldkl0ZW0gPSBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXMucHVzaChuZXcgUGFpcihrZXksIHZhbHVlKSk7XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAga2V5U3RhcnQgPSBpdGVtLnJhbmdlLnN0YXJ0O1xuICAgICAgbmV4dCA9ICcsJztcbiAgICB9XG4gIH1cblxuICBjaGVja0Zsb3dDb2xsZWN0aW9uRW5kKGRvYy5lcnJvcnMsIGNzdCk7XG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tZW50cyxcbiAgICBpdGVtc1xuICB9O1xufVxuXG5leHBvcnRzLkFsaWFzID0gQWxpYXM7XG5leHBvcnRzLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuZXhwb3J0cy5NZXJnZSA9IE1lcmdlO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuUGFpciA9IFBhaXI7XG5leHBvcnRzLlNjYWxhciA9IFNjYWxhcjtcbmV4cG9ydHMuWUFNTE1hcCA9IFlBTUxNYXA7XG5leHBvcnRzLllBTUxTZXEgPSBZQU1MU2VxO1xuZXhwb3J0cy5hZGRDb21tZW50ID0gYWRkQ29tbWVudDtcbmV4cG9ydHMuYmluYXJ5T3B0aW9ucyA9IGJpbmFyeU9wdGlvbnM7XG5leHBvcnRzLmJvb2xPcHRpb25zID0gYm9vbE9wdGlvbnM7XG5leHBvcnRzLmZpbmRQYWlyID0gZmluZFBhaXI7XG5leHBvcnRzLmludE9wdGlvbnMgPSBpbnRPcHRpb25zO1xuZXhwb3J0cy5pc0VtcHR5UGF0aCA9IGlzRW1wdHlQYXRoO1xuZXhwb3J0cy5udWxsT3B0aW9ucyA9IG51bGxPcHRpb25zO1xuZXhwb3J0cy5yZXNvbHZlTWFwID0gcmVzb2x2ZU1hcDtcbmV4cG9ydHMucmVzb2x2ZU5vZGUgPSByZXNvbHZlTm9kZTtcbmV4cG9ydHMucmVzb2x2ZVNlcSA9IHJlc29sdmVTZXE7XG5leHBvcnRzLnJlc29sdmVTdHJpbmcgPSByZXNvbHZlU3RyaW5nO1xuZXhwb3J0cy5zdHJPcHRpb25zID0gc3RyT3B0aW9ucztcbmV4cG9ydHMuc3RyaW5naWZ5TnVtYmVyID0gc3RyaW5naWZ5TnVtYmVyO1xuZXhwb3J0cy5zdHJpbmdpZnlTdHJpbmcgPSBzdHJpbmdpZnlTdHJpbmc7XG5leHBvcnRzLnRvSlNPTiA9IHRvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBsYWluVmFsdWUgPSByZXF1aXJlKCcuL1BsYWluVmFsdWUtZWM4ZTU4OGUuanMnKTtcbnZhciByZXNvbHZlU2VxID0gcmVxdWlyZSgnLi9yZXNvbHZlU2VxLWQwM2NiMDM3LmpzJyk7XG5cbi8qIGdsb2JhbCBhdG9iLCBidG9hLCBCdWZmZXIgKi9cbmNvbnN0IGJpbmFyeSA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgLy8gQnVmZmVyIGluaGVyaXRzIGZyb20gVWludDhBcnJheVxuICBkZWZhdWx0OiBmYWxzZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JyxcblxuICAvKipcbiAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAqXG4gICAqIFRvIHVzZSB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBhcyBhbiBpbWFnZSwgeW91J2xsIHdhbnQgdG8gZG8gc29tZXRoaW5nIGxpa2U6XG4gICAqXG4gICAqICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwaG90bycpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICovXG4gIHJlc29sdmU6IChkb2MsIG5vZGUpID0+IHtcbiAgICBjb25zdCBzcmMgPSByZXNvbHZlU2VxLnJlc29sdmVTdHJpbmcoZG9jLCBub2RlKTtcblxuICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3JjLCAnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSAnVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHJlYWRpbmcgYmluYXJ5IHRhZ3M7IGVpdGhlciBCdWZmZXIgb3IgYXRvYiBpcyByZXF1aXJlZCc7XG4gICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFJlZmVyZW5jZUVycm9yKG5vZGUsIG1zZykpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBvcHRpb25zOiByZXNvbHZlU2VxLmJpbmFyeU9wdGlvbnMsXG4gIHN0cmluZ2lmeTogKHtcbiAgICBjb21tZW50LFxuICAgIHR5cGUsXG4gICAgdmFsdWVcbiAgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSA9PiB7XG4gICAgbGV0IHNyYztcblxuICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzcmMgPSB2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlciA/IHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSA6IEJ1ZmZlci5mcm9tKHZhbHVlLmJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxldCBzID0gJyc7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZVtpXSk7XG5cbiAgICAgIHNyYyA9IGJ0b2Eocyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHdyaXRpbmcgYmluYXJ5IHRhZ3M7IGVpdGhlciBCdWZmZXIgb3IgYnRvYSBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGlmICghdHlwZSkgdHlwZSA9IHJlc29sdmVTZXEuYmluYXJ5T3B0aW9ucy5kZWZhdWx0VHlwZTtcblxuICAgIGlmICh0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuUVVPVEVfRE9VQkxFKSB7XG4gICAgICB2YWx1ZSA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH0gPSByZXNvbHZlU2VxLmJpbmFyeU9wdGlvbnM7XG4gICAgICBjb25zdCBuID0gTWF0aC5jZWlsKHNyYy5sZW5ndGggLyBsaW5lV2lkdGgpO1xuICAgICAgY29uc3QgbGluZXMgPSBuZXcgQXJyYXkobik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgbGluZXNbaV0gPSBzcmMuc3Vic3RyKG8sIGxpbmVXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbGluZXMuam9pbih0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfTElURVJBTCA/ICdcXG4nIDogJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZVNlcS5zdHJpbmdpZnlTdHJpbmcoe1xuICAgICAgY29tbWVudCxcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZVxuICAgIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlUGFpcnMoZG9jLCBjc3QpIHtcbiAgY29uc3Qgc2VxID0gcmVzb2x2ZVNlcS5yZXNvbHZlU2VxKGRvYywgY3N0KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIGxldCBpdGVtID0gc2VxLml0ZW1zW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5QYWlyKSBjb250aW51ZTtlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5ZQU1MTWFwKSB7XG4gICAgICBpZiAoaXRlbS5pdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdFYWNoIHBhaXIgbXVzdCBoYXZlIGl0cyBvd24gc2VxdWVuY2UgaW5kaWNhdG9yJztcbiAgICAgICAgdGhyb3cgbmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoY3N0LCBtc2cpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYWlyID0gaXRlbS5pdGVtc1swXSB8fCBuZXcgcmVzb2x2ZVNlcS5QYWlyKCk7XG4gICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKSBwYWlyLmNvbW1lbnRCZWZvcmUgPSBwYWlyLmNvbW1lbnRCZWZvcmUgPyBgJHtpdGVtLmNvbW1lbnRCZWZvcmV9XFxuJHtwYWlyLmNvbW1lbnRCZWZvcmV9YCA6IGl0ZW0uY29tbWVudEJlZm9yZTtcbiAgICAgIGlmIChpdGVtLmNvbW1lbnQpIHBhaXIuY29tbWVudCA9IHBhaXIuY29tbWVudCA/IGAke2l0ZW0uY29tbWVudH1cXG4ke3BhaXIuY29tbWVudH1gIDogaXRlbS5jb21tZW50O1xuICAgICAgaXRlbSA9IHBhaXI7XG4gICAgfVxuICAgIHNlcS5pdGVtc1tpXSA9IGl0ZW0gaW5zdGFuY2VvZiByZXNvbHZlU2VxLlBhaXIgPyBpdGVtIDogbmV3IHJlc29sdmVTZXEuUGFpcihpdGVtKTtcbiAgfVxuXG4gIHJldHVybiBzZXE7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgY29uc3QgcGFpcnMgPSBuZXcgcmVzb2x2ZVNlcS5ZQU1MU2VxKHNjaGVtYSk7XG4gIHBhaXJzLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc7XG5cbiAgZm9yIChjb25zdCBpdCBvZiBpdGVyYWJsZSkge1xuICAgIGxldCBrZXksIHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXQpKSB7XG4gICAgICBpZiAoaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGtleSA9IGl0WzBdO1xuICAgICAgICB2YWx1ZSA9IGl0WzFdO1xuICAgICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFtrZXksIHZhbHVlXSB0dXBsZTogJHtpdH1gKTtcbiAgICB9IGVsc2UgaWYgKGl0ICYmIGl0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcbiAgICAgICAgdmFsdWUgPSBpdFtrZXldO1xuICAgICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHsga2V5OiB2YWx1ZSB9IHR1cGxlOiAke2l0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBpdDtcbiAgICB9XG5cbiAgICBjb25zdCBwYWlyID0gc2NoZW1hLmNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICBwYWlycy5pdGVtcy5wdXNoKHBhaXIpO1xuICB9XG5cbiAgcmV0dXJuIHBhaXJzO1xufVxuY29uc3QgcGFpcnMgPSB7XG4gIGRlZmF1bHQ6IGZhbHNlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsXG4gIHJlc29sdmU6IHBhcnNlUGFpcnMsXG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZVBhaXJzXG59O1xuXG5jbGFzcyBZQU1MT01hcCBleHRlbmRzIHJlc29sdmVTZXEuWUFNTFNlcSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBQbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZFwiLCByZXNvbHZlU2VxLllBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpKTtcblxuICAgIFBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVsZXRlXCIsIHJlc29sdmVTZXEuWUFNTE1hcC5wcm90b3R5cGUuZGVsZXRlLmJpbmQodGhpcykpO1xuXG4gICAgUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRcIiwgcmVzb2x2ZVNlcS5ZQU1MTWFwLnByb3RvdHlwZS5nZXQuYmluZCh0aGlzKSk7XG5cbiAgICBQbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc1wiLCByZXNvbHZlU2VxLllBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpKTtcblxuICAgIFBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0XCIsIHJlc29sdmVTZXEuWUFNTE1hcC5wcm90b3R5cGUuc2V0LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy50YWcgPSBZQU1MT01hcC50YWc7XG4gIH1cblxuICB0b0pTT04oXywgY3R4KSB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUobWFwKTtcblxuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICBsZXQga2V5LCB2YWx1ZTtcblxuICAgICAgaWYgKHBhaXIgaW5zdGFuY2VvZiByZXNvbHZlU2VxLlBhaXIpIHtcbiAgICAgICAga2V5ID0gcmVzb2x2ZVNlcS50b0pTT04ocGFpci5rZXksICcnLCBjdHgpO1xuICAgICAgICB2YWx1ZSA9IHJlc29sdmVTZXEudG9KU09OKHBhaXIudmFsdWUsIGtleSwgY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IHJlc29sdmVTZXEudG9KU09OKHBhaXIsICcnLCBjdHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFwLmhhcyhrZXkpKSB0aHJvdyBuZXcgRXJyb3IoJ09yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzJyk7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH1cblxufVxuXG5QbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eShZQU1MT01hcCwgXCJ0YWdcIiwgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnKTtcblxuZnVuY3Rpb24gcGFyc2VPTWFwKGRvYywgY3N0KSB7XG4gIGNvbnN0IHBhaXJzID0gcGFyc2VQYWlycyhkb2MsIGNzdCk7XG4gIGNvbnN0IHNlZW5LZXlzID0gW107XG5cbiAgZm9yIChjb25zdCB7XG4gICAga2V5XG4gIH0gb2YgcGFpcnMuaXRlbXMpIHtcbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5TY2FsYXIpIHtcbiAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cyc7XG4gICAgICAgIHRocm93IG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW5LZXlzLnB1c2goa2V5LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTE9NYXAoKSwgcGFpcnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPTWFwKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICBjb25zdCBwYWlycyA9IGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCk7XG4gIGNvbnN0IG9tYXAgPSBuZXcgWUFNTE9NYXAoKTtcbiAgb21hcC5pdGVtcyA9IHBhaXJzLml0ZW1zO1xuICByZXR1cm4gb21hcDtcbn1cblxuY29uc3Qgb21hcCA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgTWFwLFxuICBub2RlQ2xhc3M6IFlBTUxPTWFwLFxuICBkZWZhdWx0OiBmYWxzZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsXG4gIHJlc29sdmU6IHBhcnNlT01hcCxcbiAgY3JlYXRlTm9kZTogY3JlYXRlT01hcFxufTtcblxuY2xhc3MgWUFNTFNldCBleHRlbmRzIHJlc29sdmVTZXEuWUFNTE1hcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YWcgPSBZQU1MU2V0LnRhZztcbiAgfVxuXG4gIGFkZChrZXkpIHtcbiAgICBjb25zdCBwYWlyID0ga2V5IGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5QYWlyID8ga2V5IDogbmV3IHJlc29sdmVTZXEuUGFpcihrZXkpO1xuICAgIGNvbnN0IHByZXYgPSByZXNvbHZlU2VxLmZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICBpZiAoIXByZXYpIHRoaXMuaXRlbXMucHVzaChwYWlyKTtcbiAgfVxuXG4gIGdldChrZXksIGtlZXBQYWlyKSB7XG4gICAgY29uc3QgcGFpciA9IHJlc29sdmVTZXEuZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICByZXR1cm4gIWtlZXBQYWlyICYmIHBhaXIgaW5zdGFuY2VvZiByZXNvbHZlU2VxLlBhaXIgPyBwYWlyLmtleSBpbnN0YW5jZW9mIHJlc29sdmVTZXEuU2NhbGFyID8gcGFpci5rZXkudmFsdWUgOiBwYWlyLmtleSA6IHBhaXI7XG4gIH1cblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIHZhbHVlIGZvciBzZXQoa2V5LCB2YWx1ZSkgaW4gYSBZQU1MIHNldCwgbm90ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIGNvbnN0IHByZXYgPSByZXNvbHZlU2VxLmZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG5cbiAgICBpZiAocHJldiAmJiAhdmFsdWUpIHtcbiAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihwcmV2KSwgMSk7XG4gICAgfSBlbHNlIGlmICghcHJldiAmJiB2YWx1ZSkge1xuICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyByZXNvbHZlU2VxLlBhaXIoa2V5KSk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKF8sIGN0eCkge1xuICAgIHJldHVybiBzdXBlci50b0pTT04oXywgY3R4LCBTZXQpO1xuICB9XG5cbiAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgaWYgKCFjdHgpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKCkpIHJldHVybiBzdXBlci50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICB9XG5cbn1cblxuUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkoWUFNTFNldCwgXCJ0YWdcIiwgJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcpO1xuXG5mdW5jdGlvbiBwYXJzZVNldChkb2MsIGNzdCkge1xuICBjb25zdCBtYXAgPSByZXNvbHZlU2VxLnJlc29sdmVNYXAoZG9jLCBjc3QpO1xuICBpZiAoIW1hcC5oYXNBbGxOdWxsVmFsdWVzKCkpIHRocm93IG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MU2V0KCksIG1hcCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNldChzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFlBTUxTZXQoKTtcblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSBzZXQuaXRlbXMucHVzaChzY2hlbWEuY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG5cbiAgcmV0dXJuIHNldDtcbn1cblxuY29uc3Qgc2V0ID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBTZXQsXG4gIG5vZGVDbGFzczogWUFNTFNldCxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsXG4gIHJlc29sdmU6IHBhcnNlU2V0LFxuICBjcmVhdGVOb2RlOiBjcmVhdGVTZXRcbn07XG5cbmNvbnN0IHBhcnNlU2V4YWdlc2ltYWwgPSAoc2lnbiwgcGFydHMpID0+IHtcbiAgY29uc3QgbiA9IHBhcnRzLnNwbGl0KCc6JykucmVkdWNlKChuLCBwKSA9PiBuICogNjAgKyBOdW1iZXIocCksIDApO1xuICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLW4gOiBuO1xufTsgLy8gaGhoaDptbTpzcy5zc3NcblxuXG5jb25zdCBzdHJpbmdpZnlTZXhhZ2VzaW1hbCA9ICh7XG4gIHZhbHVlXG59KSA9PiB7XG4gIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIHJlc29sdmVTZXEuc3RyaW5naWZ5TnVtYmVyKHZhbHVlKTtcbiAgbGV0IHNpZ24gPSAnJztcblxuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgc2lnbiA9ICctJztcbiAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnRzID0gW3ZhbHVlICUgNjBdOyAvLyBzZWNvbmRzLCBpbmNsdWRpbmcgbXNcblxuICBpZiAodmFsdWUgPCA2MCkge1xuICAgIHBhcnRzLnVuc2hpZnQoMCk7IC8vIGF0IGxlYXN0IG9uZSA6IGlzIHJlcXVpcmVkXG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKCh2YWx1ZSAtIHBhcnRzWzBdKSAvIDYwKTtcbiAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlICUgNjApOyAvLyBtaW51dGVzXG5cbiAgICBpZiAodmFsdWUgPj0gNjApIHtcbiAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCgodmFsdWUgLSBwYXJ0c1swXSkgLyA2MCk7XG4gICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlKTsgLy8gaG91cnNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2lnbiArIHBhcnRzLm1hcChuID0+IG4gPCAxMCA/ICcwJyArIFN0cmluZyhuKSA6IFN0cmluZyhuKSkuam9pbignOicpLnJlcGxhY2UoLzAwMDAwMFxcZCokLywgJycpIC8vICUgNjAgbWF5IGludHJvZHVjZSBlcnJvclxuICA7XG59O1xuXG5jb25zdCBpbnRUaW1lID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgZm9ybWF0OiAnVElNRScsXG4gIHRlc3Q6IC9eKFstK10/KShbMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pKykkLyxcbiAgcmVzb2x2ZTogKHN0ciwgc2lnbiwgcGFydHMpID0+IHBhcnNlU2V4YWdlc2ltYWwoc2lnbiwgcGFydHMucmVwbGFjZSgvXy9nLCAnJykpLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeVNleGFnZXNpbWFsXG59O1xuY29uc3QgZmxvYXRUaW1lID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICBmb3JtYXQ6ICdUSU1FJyxcbiAgdGVzdDogL14oWy0rXT8pKFswLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKikkLyxcbiAgcmVzb2x2ZTogKHN0ciwgc2lnbiwgcGFydHMpID0+IHBhcnNlU2V4YWdlc2ltYWwoc2lnbiwgcGFydHMucmVwbGFjZSgvXy9nLCAnJykpLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeVNleGFnZXNpbWFsXG59O1xuY29uc3QgdGltZXN0YW1wID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLFxuICAvLyBJZiB0aGUgdGltZSB6b25lIGlzIG9taXR0ZWQsIHRoZSB0aW1lc3RhbXAgaXMgYXNzdW1lZCB0byBiZSBzcGVjaWZpZWQgaW4gVVRDLiBUaGUgdGltZSBwYXJ0XG4gIC8vIG1heSBiZSBvbWl0dGVkIGFsdG9nZXRoZXIsIHJlc3VsdGluZyBpbiBhIGRhdGUgZm9ybWF0LiBJbiBzdWNoIGEgY2FzZSwgdGhlIHRpbWUgcGFydCBpc1xuICAvLyBhc3N1bWVkIHRvIGJlIDAwOjAwOjAwWiAoc3RhcnQgb2YgZGF5LCBVVEMpLlxuICB0ZXN0OiBSZWdFeHAoJ14oPzonICsgJyhbMC05XXs0fSktKFswLTldezEsMn0pLShbMC05XXsxLDJ9KScgKyAvLyBZWVlZLU1tLURkXG4gICcoPzooPzp0fFR8WyBcXFxcdF0rKScgKyAvLyB0IHwgVCB8IHdoaXRlc3BhY2VcbiAgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0oXFxcXC5bMC05XSspPyknICsgLy8gSGg6TW06U3MoLnNzKT9cbiAgJyg/OlsgXFxcXHRdKihafFstK11bMDEyXT9bMC05XSg/OjpbMC05XXsyfSk/KSk/JyArIC8vIFogfCArNSB8IC0wMzozMFxuICAnKT8nICsgJykkJyksXG4gIHJlc29sdmU6IChzdHIsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlYywgdHopID0+IHtcbiAgICBpZiAobWlsbGlzZWMpIG1pbGxpc2VjID0gKG1pbGxpc2VjICsgJzAwJykuc3Vic3RyKDEsIDMpO1xuICAgIGxldCBkYXRlID0gRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIgfHwgMCwgbWludXRlIHx8IDAsIHNlY29uZCB8fCAwLCBtaWxsaXNlYyB8fCAwKTtcblxuICAgIGlmICh0eiAmJiB0eiAhPT0gJ1onKSB7XG4gICAgICBsZXQgZCA9IHBhcnNlU2V4YWdlc2ltYWwodHpbMF0sIHR6LnNsaWNlKDEpKTtcbiAgICAgIGlmIChNYXRoLmFicyhkKSA8IDMwKSBkICo9IDYwO1xuICAgICAgZGF0ZSAtPSA2MDAwMCAqIGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICB9LFxuICBzdHJpbmdpZnk6ICh7XG4gICAgdmFsdWVcbiAgfSkgPT4gdmFsdWUudG9JU09TdHJpbmcoKS5yZXBsYWNlKC8oKFQwMDowMCk/OjAwKT9cXC4wMDBaJC8sICcnKVxufTtcblxuLyogZ2xvYmFsIGNvbnNvbGUsIHByb2Nlc3MsIFlBTUxfU0lMRU5DRV9ERVBSRUNBVElPTl9XQVJOSU5HUywgWUFNTF9TSUxFTkNFX1dBUk5JTkdTICovXG5mdW5jdGlvbiBzaG91bGRXYXJuKGRlcHJlY2F0aW9uKSB7XG4gIGNvbnN0IGVudiA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiB8fCB7fTtcblxuICBpZiAoZGVwcmVjYXRpb24pIHtcbiAgICBpZiAodHlwZW9mIFlBTUxfU0lMRU5DRV9ERVBSRUNBVElPTl9XQVJOSU5HUyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiAhWUFNTF9TSUxFTkNFX0RFUFJFQ0FUSU9OX1dBUk5JTkdTO1xuICAgIHJldHVybiAhZW52LllBTUxfU0lMRU5DRV9ERVBSRUNBVElPTl9XQVJOSU5HUztcbiAgfVxuXG4gIGlmICh0eXBlb2YgWUFNTF9TSUxFTkNFX1dBUk5JTkdTICE9PSAndW5kZWZpbmVkJykgcmV0dXJuICFZQU1MX1NJTEVOQ0VfV0FSTklOR1M7XG4gIHJldHVybiAhZW52LllBTUxfU0lMRU5DRV9XQVJOSU5HUztcbn1cblxuZnVuY3Rpb24gd2Fybih3YXJuaW5nLCB0eXBlKSB7XG4gIGlmIChzaG91bGRXYXJuKGZhbHNlKSkge1xuICAgIGNvbnN0IGVtaXQgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbWl0V2FybmluZzsgLy8gVGhpcyB3aWxsIHRocm93IGluIEplc3QgaWYgYHdhcm5pbmdgIGlzIGFuIEVycm9yIGluc3RhbmNlIGR1ZSB0b1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0L2lzc3Vlcy8yNTQ5XG5cbiAgICBpZiAoZW1pdCkgZW1pdCh3YXJuaW5nLCB0eXBlKTtlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4odHlwZSA/IGAke3R5cGV9OiAke3dhcm5pbmd9YCA6IHdhcm5pbmcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd2FybkZpbGVEZXByZWNhdGlvbihmaWxlbmFtZSkge1xuICBpZiAoc2hvdWxkV2Fybih0cnVlKSkge1xuICAgIGNvbnN0IHBhdGggPSBmaWxlbmFtZS5yZXBsYWNlKC8uKnlhbWxbL1xcXFxdL2ksICcnKS5yZXBsYWNlKC9cXC5qcyQvLCAnJykucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgIHdhcm4oYFRoZSBlbmRwb2ludCAneWFtbC8ke3BhdGh9JyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5gLCAnRGVwcmVjYXRpb25XYXJuaW5nJyk7XG4gIH1cbn1cbmNvbnN0IHdhcm5lZCA9IHt9O1xuZnVuY3Rpb24gd2Fybk9wdGlvbkRlcHJlY2F0aW9uKG5hbWUsIGFsdGVybmF0aXZlKSB7XG4gIGlmICghd2FybmVkW25hbWVdICYmIHNob3VsZFdhcm4odHJ1ZSkpIHtcbiAgICB3YXJuZWRbbmFtZV0gPSB0cnVlO1xuICAgIGxldCBtc2cgPSBgVGhlIG9wdGlvbiAnJHtuYW1lfScgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2VgO1xuICAgIG1zZyArPSBhbHRlcm5hdGl2ZSA/IGAsIHVzZSAnJHthbHRlcm5hdGl2ZX0nIGluc3RlYWQuYCA6ICcuJztcbiAgICB3YXJuKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICB9XG59XG5cbmV4cG9ydHMuYmluYXJ5ID0gYmluYXJ5O1xuZXhwb3J0cy5mbG9hdFRpbWUgPSBmbG9hdFRpbWU7XG5leHBvcnRzLmludFRpbWUgPSBpbnRUaW1lO1xuZXhwb3J0cy5vbWFwID0gb21hcDtcbmV4cG9ydHMucGFpcnMgPSBwYWlycztcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuZXhwb3J0cy53YXJuRmlsZURlcHJlY2F0aW9uID0gd2FybkZpbGVEZXByZWNhdGlvbjtcbmV4cG9ydHMud2Fybk9wdGlvbkRlcHJlY2F0aW9uID0gd2Fybk9wdGlvbkRlcHJlY2F0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGxhaW5WYWx1ZSA9IHJlcXVpcmUoJy4vUGxhaW5WYWx1ZS1lYzhlNTg4ZS5qcycpO1xudmFyIHJlc29sdmVTZXEgPSByZXF1aXJlKCcuL3Jlc29sdmVTZXEtZDAzY2IwMzcuanMnKTtcbnZhciB3YXJuaW5ncyA9IHJlcXVpcmUoJy4vd2FybmluZ3MtMTAwMGEzNzIuanMnKTtcblxuZnVuY3Rpb24gY3JlYXRlTWFwKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgY29uc3QgbWFwID0gbmV3IHJlc29sdmVTZXEuWUFNTE1hcChzY2hlbWEpO1xuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopIG1hcC5pdGVtcy5wdXNoKHNjaGVtYS5jcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICB9IGVsc2UgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIG1hcC5pdGVtcy5wdXNoKHNjaGVtYS5jcmVhdGVQYWlyKGtleSwgb2JqW2tleV0sIGN0eCkpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEuc29ydE1hcEVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICB9XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxuY29uc3QgbWFwID0ge1xuICBjcmVhdGVOb2RlOiBjcmVhdGVNYXAsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIG5vZGVDbGFzczogcmVzb2x2ZVNlcS5ZQU1MTWFwLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLFxuICByZXNvbHZlOiByZXNvbHZlU2VxLnJlc29sdmVNYXBcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gIGNvbnN0IHNlcSA9IG5ldyByZXNvbHZlU2VxLllBTUxTZXEoc2NoZW1hKTtcblxuICBpZiAob2JqICYmIG9ialtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgZm9yIChjb25zdCBpdCBvZiBvYmopIHtcbiAgICAgIGNvbnN0IHYgPSBzY2hlbWEuY3JlYXRlTm9kZShpdCwgY3R4LndyYXBTY2FsYXJzLCBudWxsLCBjdHgpO1xuICAgICAgc2VxLml0ZW1zLnB1c2godik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcTtcbn1cblxuY29uc3Qgc2VxID0ge1xuICBjcmVhdGVOb2RlOiBjcmVhdGVTZXEsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIG5vZGVDbGFzczogcmVzb2x2ZVNlcS5ZQU1MU2VxLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICByZXNvbHZlOiByZXNvbHZlU2VxLnJlc29sdmVTZXFcbn07XG5cbmNvbnN0IHN0cmluZyA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gIHJlc29sdmU6IHJlc29sdmVTZXEucmVzb2x2ZVN0cmluZyxcblxuICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhY3R1YWxTdHJpbmc6IHRydWVcbiAgICB9LCBjdHgpO1xuICAgIHJldHVybiByZXNvbHZlU2VxLnN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9LFxuXG4gIG9wdGlvbnM6IHJlc29sdmVTZXEuc3RyT3B0aW9uc1xufTtcblxuY29uc3QgZmFpbHNhZmUgPSBbbWFwLCBzZXEsIHN0cmluZ107XG5cbi8qIGdsb2JhbCBCaWdJbnQgKi9cblxuY29uc3QgaW50SWRlbnRpZnkkMiA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5cbmNvbnN0IGludFJlc29sdmUkMSA9IChzcmMsIHBhcnQsIHJhZGl4KSA9PiByZXNvbHZlU2VxLmludE9wdGlvbnMuYXNCaWdJbnQgPyBCaWdJbnQoc3JjKSA6IHBhcnNlSW50KHBhcnQsIHJhZGl4KTtcblxuZnVuY3Rpb24gaW50U3RyaW5naWZ5JDEobm9kZSwgcmFkaXgsIHByZWZpeCkge1xuICBjb25zdCB7XG4gICAgdmFsdWVcbiAgfSA9IG5vZGU7XG4gIGlmIChpbnRJZGVudGlmeSQyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwKSByZXR1cm4gcHJlZml4ICsgdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICByZXR1cm4gcmVzb2x2ZVNlcS5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5cbmNvbnN0IG51bGxPYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICBjcmVhdGVOb2RlOiAoc2NoZW1hLCB2YWx1ZSwgY3R4KSA9PiBjdHgud3JhcFNjYWxhcnMgPyBuZXcgcmVzb2x2ZVNlcS5TY2FsYXIobnVsbCkgOiBudWxsLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgdGVzdDogL14oPzp+fFtObl11bGx8TlVMTCk/JC8sXG4gIHJlc29sdmU6ICgpID0+IG51bGwsXG4gIG9wdGlvbnM6IHJlc29sdmVTZXEubnVsbE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogKCkgPT4gcmVzb2x2ZVNlcS5udWxsT3B0aW9ucy5udWxsU3RyXG59O1xuY29uc3QgYm9vbE9iaiA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgdGVzdDogL14oPzpbVHRdcnVlfFRSVUV8W0ZmXWFsc2V8RkFMU0UpJC8sXG4gIHJlc29sdmU6IHN0ciA9PiBzdHJbMF0gPT09ICd0JyB8fCBzdHJbMF0gPT09ICdUJyxcbiAgb3B0aW9uczogcmVzb2x2ZVNlcS5ib29sT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHZhbHVlXG4gIH0pID0+IHZhbHVlID8gcmVzb2x2ZVNlcS5ib29sT3B0aW9ucy50cnVlU3RyIDogcmVzb2x2ZVNlcS5ib29sT3B0aW9ucy5mYWxzZVN0clxufTtcbmNvbnN0IG9jdE9iaiA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5JDIodmFsdWUpICYmIHZhbHVlID49IDAsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ09DVCcsXG4gIHRlc3Q6IC9eMG8oWzAtN10rKSQvLFxuICByZXNvbHZlOiAoc3RyLCBvY3QpID0+IGludFJlc29sdmUkMShzdHIsIG9jdCwgOCksXG4gIG9wdGlvbnM6IHJlc29sdmVTZXEuaW50T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeSQxKG5vZGUsIDgsICcwbycpXG59O1xuY29uc3QgaW50T2JqID0ge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnkkMixcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgdGVzdDogL15bLStdP1swLTldKyQvLFxuICByZXNvbHZlOiBzdHIgPT4gaW50UmVzb2x2ZSQxKHN0ciwgc3RyLCAxMCksXG4gIG9wdGlvbnM6IHJlc29sdmVTZXEuaW50T3B0aW9ucyxcbiAgc3RyaW5naWZ5OiByZXNvbHZlU2VxLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGhleE9iaiA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5JDIodmFsdWUpICYmIHZhbHVlID49IDAsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ0hFWCcsXG4gIHRlc3Q6IC9eMHgoWzAtOWEtZkEtRl0rKSQvLFxuICByZXNvbHZlOiAoc3RyLCBoZXgpID0+IGludFJlc29sdmUkMShzdHIsIGhleCwgMTYpLFxuICBvcHRpb25zOiByZXNvbHZlU2VxLmludE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkkMShub2RlLCAxNiwgJzB4Jylcbn07XG5jb25zdCBuYW5PYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eKD86Wy0rXT9cXC5pbmZ8KFxcLm5hbikpJC9pLFxuICByZXNvbHZlOiAoc3RyLCBuYW4pID0+IG5hbiA/IE5hTiA6IHN0clswXSA9PT0gJy0nID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICBzdHJpbmdpZnk6IHJlc29sdmVTZXEuc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgZXhwT2JqID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICBmb3JtYXQ6ICdFWFAnLFxuICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldKyg/OlxcLlswLTldKik/KVtlRV1bLStdP1swLTldKyQvLFxuICByZXNvbHZlOiBzdHIgPT4gcGFyc2VGbG9hdChzdHIpLFxuICBzdHJpbmdpZnk6ICh7XG4gICAgdmFsdWVcbiAgfSkgPT4gTnVtYmVyKHZhbHVlKS50b0V4cG9uZW50aWFsKClcbn07XG5jb25zdCBmbG9hdE9iaiA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgdGVzdDogL15bLStdPyg/OlxcLihbMC05XSspfFswLTldK1xcLihbMC05XSopKSQvLFxuXG4gIHJlc29sdmUoc3RyLCBmcmFjMSwgZnJhYzIpIHtcbiAgICBjb25zdCBmcmFjID0gZnJhYzEgfHwgZnJhYzI7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyByZXNvbHZlU2VxLlNjYWxhcihwYXJzZUZsb2F0KHN0cikpO1xuICAgIGlmIChmcmFjICYmIGZyYWNbZnJhYy5sZW5ndGggLSAxXSA9PT0gJzAnKSBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gZnJhYy5sZW5ndGg7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgc3RyaW5naWZ5OiByZXNvbHZlU2VxLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGNvcmUgPSBmYWlsc2FmZS5jb25jYXQoW251bGxPYmosIGJvb2xPYmosIG9jdE9iaiwgaW50T2JqLCBoZXhPYmosIG5hbk9iaiwgZXhwT2JqLCBmbG9hdE9ial0pO1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbmNvbnN0IGludElkZW50aWZ5JDEgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuXG5jb25zdCBzdHJpbmdpZnlKU09OID0gKHtcbiAgdmFsdWVcbn0pID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblxuY29uc3QganNvbiA9IFttYXAsIHNlcSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVNlcS5yZXNvbHZlU3RyaW5nLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbn0sIHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gIGNyZWF0ZU5vZGU6IChzY2hlbWEsIHZhbHVlLCBjdHgpID0+IGN0eC53cmFwU2NhbGFycyA/IG5ldyByZXNvbHZlU2VxLlNjYWxhcihudWxsKSA6IG51bGwsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICB0ZXN0OiAvXm51bGwkLyxcbiAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gIHRlc3Q6IC9edHJ1ZXxmYWxzZSQvLFxuICByZXNvbHZlOiBzdHIgPT4gc3RyID09PSAndHJ1ZScsXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnkkMSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopJC8sXG4gIHJlc29sdmU6IHN0ciA9PiByZXNvbHZlU2VxLmludE9wdGlvbnMuYXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ciwgMTApLFxuICBzdHJpbmdpZnk6ICh7XG4gICAgdmFsdWVcbiAgfSkgPT4gaW50SWRlbnRpZnkkMSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSg/OlxcLlswLTldKik/KD86W2VFXVstK10/WzAtOV0rKT8kLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG59XTtcblxuanNvbi5zY2FsYXJGYWxsYmFjayA9IHN0ciA9PiB7XG4gIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5yZXNvbHZlZCBwbGFpbiBzY2FsYXIgJHtKU09OLnN0cmluZ2lmeShzdHIpfWApO1xufTtcblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG5jb25zdCBib29sU3RyaW5naWZ5ID0gKHtcbiAgdmFsdWVcbn0pID0+IHZhbHVlID8gcmVzb2x2ZVNlcS5ib29sT3B0aW9ucy50cnVlU3RyIDogcmVzb2x2ZVNlcS5ib29sT3B0aW9ucy5mYWxzZVN0cjtcblxuY29uc3QgaW50SWRlbnRpZnkgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuXG5mdW5jdGlvbiBpbnRSZXNvbHZlKHNpZ24sIHNyYywgcmFkaXgpIHtcbiAgbGV0IHN0ciA9IHNyYy5yZXBsYWNlKC9fL2csICcnKTtcblxuICBpZiAocmVzb2x2ZVNlcS5pbnRPcHRpb25zLmFzQmlnSW50KSB7XG4gICAgc3dpdGNoIChyYWRpeCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzdHIgPSBgMGIke3N0cn1gO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA4OlxuICAgICAgICBzdHIgPSBgMG8ke3N0cn1gO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxNjpcbiAgICAgICAgc3RyID0gYDB4JHtzdHJ9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgbiA9IEJpZ0ludChzdHIpO1xuICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogbiA6IG47XG4gIH1cblxuICBjb25zdCBuID0gcGFyc2VJbnQoc3RyLCByYWRpeCk7XG4gIHJldHVybiBzaWduID09PSAnLScgPyAtMSAqIG4gOiBuO1xufVxuXG5mdW5jdGlvbiBpbnRTdHJpbmdpZnkobm9kZSwgcmFkaXgsIHByZWZpeCkge1xuICBjb25zdCB7XG4gICAgdmFsdWVcbiAgfSA9IG5vZGU7XG5cbiAgaWYgKGludElkZW50aWZ5KHZhbHVlKSkge1xuICAgIGNvbnN0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICByZXR1cm4gdmFsdWUgPCAwID8gJy0nICsgcHJlZml4ICsgc3RyLnN1YnN0cigxKSA6IHByZWZpeCArIHN0cjtcbiAgfVxuXG4gIHJldHVybiByZXNvbHZlU2VxLnN0cmluZ2lmeU51bWJlcihub2RlKTtcbn1cblxuY29uc3QgeWFtbDExID0gZmFpbHNhZmUuY29uY2F0KFt7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICBjcmVhdGVOb2RlOiAoc2NoZW1hLCB2YWx1ZSwgY3R4KSA9PiBjdHgud3JhcFNjYWxhcnMgPyBuZXcgcmVzb2x2ZVNlcS5TY2FsYXIobnVsbCkgOiBudWxsLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgdGVzdDogL14oPzp+fFtObl11bGx8TlVMTCk/JC8sXG4gIHJlc29sdmU6ICgpID0+IG51bGwsXG4gIG9wdGlvbnM6IHJlc29sdmVTZXEubnVsbE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogKCkgPT4gcmVzb2x2ZVNlcS5udWxsT3B0aW9ucy5udWxsU3RyXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gIHRlc3Q6IC9eKD86WXx5fFtZeV1lc3xZRVN8W1R0XXJ1ZXxUUlVFfFtPb11ufE9OKSQvLFxuICByZXNvbHZlOiAoKSA9PiB0cnVlLFxuICBvcHRpb25zOiByZXNvbHZlU2VxLmJvb2xPcHRpb25zLFxuICBzdHJpbmdpZnk6IGJvb2xTdHJpbmdpZnlcbn0sIHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgdGVzdDogL14oPzpOfG58W05uXW98Tk98W0ZmXWFsc2V8RkFMU0V8W09vXWZmfE9GRikkL2ksXG4gIHJlc29sdmU6ICgpID0+IGZhbHNlLFxuICBvcHRpb25zOiByZXNvbHZlU2VxLmJvb2xPcHRpb25zLFxuICBzdHJpbmdpZnk6IGJvb2xTdHJpbmdpZnlcbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdCSU4nLFxuICB0ZXN0OiAvXihbLStdPykwYihbMC0xX10rKSQvLFxuICByZXNvbHZlOiAoc3RyLCBzaWduLCBiaW4pID0+IGludFJlc29sdmUoc2lnbiwgYmluLCAyKSxcbiAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAyLCAnMGInKVxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ09DVCcsXG4gIHRlc3Q6IC9eKFstK10/KTAoWzAtN19dKykkLyxcbiAgcmVzb2x2ZTogKHN0ciwgc2lnbiwgb2N0KSA9PiBpbnRSZXNvbHZlKHNpZ24sIG9jdCwgOCksXG4gIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgOCwgJzAnKVxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIHRlc3Q6IC9eKFstK10/KShbMC05XVswLTlfXSopJC8sXG4gIHJlc29sdmU6IChzdHIsIHNpZ24sIGFicykgPT4gaW50UmVzb2x2ZShzaWduLCBhYnMsIDEwKSxcbiAgc3RyaW5naWZ5OiByZXNvbHZlU2VxLnN0cmluZ2lmeU51bWJlclxufSwge1xuICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ0hFWCcsXG4gIHRlc3Q6IC9eKFstK10/KTB4KFswLTlhLWZBLUZfXSspJC8sXG4gIHJlc29sdmU6IChzdHIsIHNpZ24sIGhleCkgPT4gaW50UmVzb2x2ZShzaWduLCBoZXgsIDE2KSxcbiAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn0sIHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgdGVzdDogL14oPzpbLStdP1xcLmluZnwoXFwubmFuKSkkL2ksXG4gIHJlc29sdmU6IChzdHIsIG5hbikgPT4gbmFuID8gTmFOIDogc3RyWzBdID09PSAnLScgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gIHN0cmluZ2lmeTogcmVzb2x2ZVNlcS5zdHJpbmdpZnlOdW1iZXJcbn0sIHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgZm9ybWF0OiAnRVhQJyxcbiAgdGVzdDogL15bLStdPyhbMC05XVswLTlfXSopPyhcXC5bMC05X10qKT9bZUVdWy0rXT9bMC05XSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKSxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHZhbHVlXG4gIH0pID0+IE51bWJlcih2YWx1ZSkudG9FeHBvbmVudGlhbCgpXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eWy0rXT8oPzpbMC05XVswLTlfXSopP1xcLihbMC05X10qKSQvLFxuXG4gIHJlc29sdmUoc3RyLCBmcmFjKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyByZXNvbHZlU2VxLlNjYWxhcihwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csICcnKSkpO1xuXG4gICAgaWYgKGZyYWMpIHtcbiAgICAgIGNvbnN0IGYgPSBmcmFjLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgaWYgKGZbZi5sZW5ndGggLSAxXSA9PT0gJzAnKSBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gZi5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgc3RyaW5naWZ5OiByZXNvbHZlU2VxLnN0cmluZ2lmeU51bWJlclxufV0sIHdhcm5pbmdzLmJpbmFyeSwgd2FybmluZ3Mub21hcCwgd2FybmluZ3MucGFpcnMsIHdhcm5pbmdzLnNldCwgd2FybmluZ3MuaW50VGltZSwgd2FybmluZ3MuZmxvYXRUaW1lLCB3YXJuaW5ncy50aW1lc3RhbXApO1xuXG5jb25zdCBzY2hlbWFzID0ge1xuICBjb3JlLFxuICBmYWlsc2FmZSxcbiAganNvbixcbiAgeWFtbDExXG59O1xuY29uc3QgdGFncyA9IHtcbiAgYmluYXJ5OiB3YXJuaW5ncy5iaW5hcnksXG4gIGJvb2w6IGJvb2xPYmosXG4gIGZsb2F0OiBmbG9hdE9iaixcbiAgZmxvYXRFeHA6IGV4cE9iaixcbiAgZmxvYXROYU46IG5hbk9iaixcbiAgZmxvYXRUaW1lOiB3YXJuaW5ncy5mbG9hdFRpbWUsXG4gIGludDogaW50T2JqLFxuICBpbnRIZXg6IGhleE9iaixcbiAgaW50T2N0OiBvY3RPYmosXG4gIGludFRpbWU6IHdhcm5pbmdzLmludFRpbWUsXG4gIG1hcCxcbiAgbnVsbDogbnVsbE9iaixcbiAgb21hcDogd2FybmluZ3Mub21hcCxcbiAgcGFpcnM6IHdhcm5pbmdzLnBhaXJzLFxuICBzZXEsXG4gIHNldDogd2FybmluZ3Muc2V0LFxuICB0aW1lc3RhbXA6IHdhcm5pbmdzLnRpbWVzdGFtcFxufTtcblxuZnVuY3Rpb24gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgdGFncykge1xuICBpZiAodGFnTmFtZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LnRhZyA9PT0gdGFnTmFtZSk7XG4gICAgY29uc3QgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCkgfHwgbWF0Y2hbMF07XG4gICAgaWYgKCF0YWdPYmopIHRocm93IG5ldyBFcnJvcihgVGFnICR7dGFnTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgcmV0dXJuIHRhZ09iajtcbiAgfSAvLyBUT0RPOiBkZXByZWNhdGUvcmVtb3ZlIGNsYXNzIGNoZWNrXG5cblxuICByZXR1cm4gdGFncy5maW5kKHQgPT4gKHQuaWRlbnRpZnkgJiYgdC5pZGVudGlmeSh2YWx1ZSkgfHwgdC5jbGFzcyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHQuY2xhc3MpICYmICF0LmZvcm1hdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGN0eCkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiByZXNvbHZlU2VxLk5vZGUpIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRQcmVmaXgsXG4gICAgb25UYWdPYmosXG4gICAgcHJldk9iamVjdHMsXG4gICAgc2NoZW1hLFxuICAgIHdyYXBTY2FsYXJzXG4gIH0gPSBjdHg7XG4gIGlmICh0YWdOYW1lICYmIHRhZ05hbWUuc3RhcnRzV2l0aCgnISEnKSkgdGFnTmFtZSA9IGRlZmF1bHRQcmVmaXggKyB0YWdOYW1lLnNsaWNlKDIpO1xuICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuXG4gIGlmICghdGFnT2JqKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHZhbHVlID0gdmFsdWUudG9KU09OKCk7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSByZXR1cm4gd3JhcFNjYWxhcnMgPyBuZXcgcmVzb2x2ZVNlcS5TY2FsYXIodmFsdWUpIDogdmFsdWU7XG4gICAgdGFnT2JqID0gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBtYXAgOiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID8gc2VxIDogbWFwO1xuICB9XG5cbiAgaWYgKG9uVGFnT2JqKSB7XG4gICAgb25UYWdPYmoodGFnT2JqKTtcbiAgICBkZWxldGUgY3R4Lm9uVGFnT2JqO1xuICB9IC8vIERldGVjdCBkdXBsaWNhdGUgcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBvYmplY3QgJiB1c2UgQWxpYXMgbm9kZXMgZm9yIGFsbFxuICAvLyBhZnRlciBmaXJzdC4gVGhlIGBvYmpgIHdyYXBwZXIgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG5cblxuICBjb25zdCBvYmogPSB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBub2RlOiB1bmRlZmluZWRcbiAgfTtcblxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBwcmV2T2JqZWN0cykge1xuICAgIGNvbnN0IHByZXYgPSBwcmV2T2JqZWN0cy5nZXQodmFsdWUpO1xuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGNvbnN0IGFsaWFzID0gbmV3IHJlc29sdmVTZXEuQWxpYXMocHJldik7IC8vIGxlYXZlcyBzb3VyY2UgZGlydHk7IG11c3QgYmUgY2xlYW5lZCBieSBjYWxsZXJcblxuICAgICAgY3R4LmFsaWFzTm9kZXMucHVzaChhbGlhcyk7IC8vIGRlZmluZWQgYWxvbmcgd2l0aCBwcmV2T2JqZWN0c1xuXG4gICAgICByZXR1cm4gYWxpYXM7XG4gICAgfVxuXG4gICAgb2JqLnZhbHVlID0gdmFsdWU7XG4gICAgcHJldk9iamVjdHMuc2V0KHZhbHVlLCBvYmopO1xuICB9XG5cbiAgb2JqLm5vZGUgPSB0YWdPYmouY3JlYXRlTm9kZSA/IHRhZ09iai5jcmVhdGVOb2RlKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpIDogd3JhcFNjYWxhcnMgPyBuZXcgcmVzb2x2ZVNlcS5TY2FsYXIodmFsdWUpIDogdmFsdWU7XG4gIGlmICh0YWdOYW1lICYmIG9iai5ub2RlIGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5Ob2RlKSBvYmoubm9kZS50YWcgPSB0YWdOYW1lO1xuICByZXR1cm4gb2JqLm5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldFNjaGVtYVRhZ3Moc2NoZW1hcywga25vd25UYWdzLCBjdXN0b21UYWdzLCBzY2hlbWFJZCkge1xuICBsZXQgdGFncyA9IHNjaGVtYXNbc2NoZW1hSWQucmVwbGFjZSgvXFxXL2csICcnKV07IC8vICd5YW1sLTEuMScgLT4gJ3lhbWwxMSdcblxuICBpZiAoIXRhZ3MpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hcykubWFwKGtleSA9PiBKU09OLnN0cmluZ2lmeShrZXkpKS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2hlbWEgXCIke3NjaGVtYUlkfVwiOyB1c2Ugb25lIG9mICR7a2V5c31gKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgY3VzdG9tVGFncykgdGFncyA9IHRhZ3MuY29uY2F0KHRhZyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGN1c3RvbVRhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0YWdzID0gY3VzdG9tVGFncyh0YWdzLnNsaWNlKCkpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgdGFnID0gdGFnc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdGFnT2JqID0ga25vd25UYWdzW3RhZ107XG5cbiAgICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhrbm93blRhZ3MpLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSkuam9pbignLCAnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGN1c3RvbSB0YWcgXCIke3RhZ31cIjsgdXNlIG9uZSBvZiAke2tleXN9YCk7XG4gICAgICB9XG5cbiAgICAgIHRhZ3NbaV0gPSB0YWdPYmo7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmNvbnN0IHNvcnRNYXBFbnRyaWVzQnlLZXkgPSAoYSwgYikgPT4gYS5rZXkgPCBiLmtleSA/IC0xIDogYS5rZXkgPiBiLmtleSA/IDEgOiAwO1xuXG5jbGFzcyBTY2hlbWEge1xuICAvLyBUT0RPOiByZW1vdmUgaW4gdjJcbiAgLy8gVE9ETzogcmVtb3ZlIGluIHYyXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjdXN0b21UYWdzLFxuICAgIG1lcmdlLFxuICAgIHNjaGVtYSxcbiAgICBzb3J0TWFwRW50cmllcyxcbiAgICB0YWdzOiBkZXByZWNhdGVkQ3VzdG9tVGFnc1xuICB9KSB7XG4gICAgdGhpcy5tZXJnZSA9ICEhbWVyZ2U7XG4gICAgdGhpcy5uYW1lID0gc2NoZW1hO1xuICAgIHRoaXMuc29ydE1hcEVudHJpZXMgPSBzb3J0TWFwRW50cmllcyA9PT0gdHJ1ZSA/IHNvcnRNYXBFbnRyaWVzQnlLZXkgOiBzb3J0TWFwRW50cmllcyB8fCBudWxsO1xuICAgIGlmICghY3VzdG9tVGFncyAmJiBkZXByZWNhdGVkQ3VzdG9tVGFncykgd2FybmluZ3Mud2Fybk9wdGlvbkRlcHJlY2F0aW9uKCd0YWdzJywgJ2N1c3RvbVRhZ3MnKTtcbiAgICB0aGlzLnRhZ3MgPSBnZXRTY2hlbWFUYWdzKHNjaGVtYXMsIHRhZ3MsIGN1c3RvbVRhZ3MgfHwgZGVwcmVjYXRlZEN1c3RvbVRhZ3MsIHNjaGVtYSk7XG4gIH1cblxuICBjcmVhdGVOb2RlKHZhbHVlLCB3cmFwU2NhbGFycywgdGFnTmFtZSwgY3R4KSB7XG4gICAgY29uc3QgYmFzZUN0eCA9IHtcbiAgICAgIGRlZmF1bHRQcmVmaXg6IFNjaGVtYS5kZWZhdWx0UHJlZml4LFxuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgd3JhcFNjYWxhcnNcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUN0eCA9IGN0eCA/IE9iamVjdC5hc3NpZ24oY3R4LCBiYXNlQ3R4KSA6IGJhc2VDdHg7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGNyZWF0ZUN0eCk7XG4gIH1cblxuICBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGlmICghY3R4KSBjdHggPSB7XG4gICAgICB3cmFwU2NhbGFyczogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgayA9IHRoaXMuY3JlYXRlTm9kZShrZXksIGN0eC53cmFwU2NhbGFycywgbnVsbCwgY3R4KTtcbiAgICBjb25zdCB2ID0gdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCBjdHgud3JhcFNjYWxhcnMsIG51bGwsIGN0eCk7XG4gICAgcmV0dXJuIG5ldyByZXNvbHZlU2VxLlBhaXIoaywgdik7XG4gIH1cblxufVxuXG5QbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eShTY2hlbWEsIFwiZGVmYXVsdFByZWZpeFwiLCBQbGFpblZhbHVlLmRlZmF1bHRUYWdQcmVmaXgpO1xuXG5QbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eShTY2hlbWEsIFwiZGVmYXVsdFRhZ3NcIiwgUGxhaW5WYWx1ZS5kZWZhdWx0VGFncyk7XG5cbmV4cG9ydHMuU2NoZW1hID0gU2NoZW1hO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZVNlcSA9IHJlcXVpcmUoJy4vcmVzb2x2ZVNlcS1kMDNjYjAzNy5qcycpO1xudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4vU2NoZW1hLTg4ZTMyM2E3LmpzJyk7XG5yZXF1aXJlKCcuL1BsYWluVmFsdWUtZWM4ZTU4OGUuanMnKTtcbnJlcXVpcmUoJy4vd2FybmluZ3MtMTAwMGEzNzIuanMnKTtcblxuXG5cbmV4cG9ydHMuQWxpYXMgPSByZXNvbHZlU2VxLkFsaWFzO1xuZXhwb3J0cy5Db2xsZWN0aW9uID0gcmVzb2x2ZVNlcS5Db2xsZWN0aW9uO1xuZXhwb3J0cy5NZXJnZSA9IHJlc29sdmVTZXEuTWVyZ2U7XG5leHBvcnRzLk5vZGUgPSByZXNvbHZlU2VxLk5vZGU7XG5leHBvcnRzLlBhaXIgPSByZXNvbHZlU2VxLlBhaXI7XG5leHBvcnRzLlNjYWxhciA9IHJlc29sdmVTZXEuU2NhbGFyO1xuZXhwb3J0cy5ZQU1MTWFwID0gcmVzb2x2ZVNlcS5ZQU1MTWFwO1xuZXhwb3J0cy5ZQU1MU2VxID0gcmVzb2x2ZVNlcS5ZQU1MU2VxO1xuZXhwb3J0cy5iaW5hcnlPcHRpb25zID0gcmVzb2x2ZVNlcS5iaW5hcnlPcHRpb25zO1xuZXhwb3J0cy5ib29sT3B0aW9ucyA9IHJlc29sdmVTZXEuYm9vbE9wdGlvbnM7XG5leHBvcnRzLmludE9wdGlvbnMgPSByZXNvbHZlU2VxLmludE9wdGlvbnM7XG5leHBvcnRzLm51bGxPcHRpb25zID0gcmVzb2x2ZVNlcS5udWxsT3B0aW9ucztcbmV4cG9ydHMuc3RyT3B0aW9ucyA9IHJlc29sdmVTZXEuc3RyT3B0aW9ucztcbmV4cG9ydHMuU2NoZW1hID0gU2NoZW1hLlNjaGVtYTtcbiIsImNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi9kaXN0L3R5cGVzJylcblxuZXhwb3J0cy5iaW5hcnlPcHRpb25zID0gdHlwZXMuYmluYXJ5T3B0aW9uc1xuZXhwb3J0cy5ib29sT3B0aW9ucyA9IHR5cGVzLmJvb2xPcHRpb25zXG5leHBvcnRzLmludE9wdGlvbnMgPSB0eXBlcy5pbnRPcHRpb25zXG5leHBvcnRzLm51bGxPcHRpb25zID0gdHlwZXMubnVsbE9wdGlvbnNcbmV4cG9ydHMuc3RyT3B0aW9ucyA9IHR5cGVzLnN0ck9wdGlvbnNcblxuZXhwb3J0cy5TY2hlbWEgPSB0eXBlcy5TY2hlbWFcbmV4cG9ydHMuQWxpYXMgPSB0eXBlcy5BbGlhc1xuZXhwb3J0cy5Db2xsZWN0aW9uID0gdHlwZXMuQ29sbGVjdGlvblxuZXhwb3J0cy5NZXJnZSA9IHR5cGVzLk1lcmdlXG5leHBvcnRzLk5vZGUgPSB0eXBlcy5Ob2RlXG5leHBvcnRzLlBhaXIgPSB0eXBlcy5QYWlyXG5leHBvcnRzLlNjYWxhciA9IHR5cGVzLlNjYWxhclxuZXhwb3J0cy5ZQU1MTWFwID0gdHlwZXMuWUFNTE1hcFxuZXhwb3J0cy5ZQU1MU2VxID0gdHlwZXMuWUFNTFNlcVxuIiwiaW1wb3J0IHlhbWwgZnJvbSAneWFtbCc7XG5pbXBvcnQgeyBZQU1MTWFwLCBZQU1MU2VxIH0gZnJvbSAneWFtbC90eXBlcyc7XG5pbXBvcnQgb3B0aW9uQVBJIGZyb20gJy4uL2FwaS9vcHRpb24nO1xuXG5mdW5jdGlvbiBnZXRJbihvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh2LCBrKSA9PiAoayBpbiB2ID8gdltrXSA6IHt9KSwgb2JqKTtcbn1cblxuZnVuY3Rpb24gYWRkQ29tbWVudHMoY29udGV4dCwgcGF0aCwgY29tbWVudE5vZGUsIGl0ZXJOb2RlID0gY29tbWVudE5vZGUpIHtcbiAgY29uc3QgeyB0aXRsZSwgZGVzY3JpcHRpb24sIGNvbW1lbnQgfSA9IGdldEluKGNvbnRleHQsIHBhdGgpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuXG4gIGlmIChvcHRpb25BUEkoJ3JlbmRlclRpdGxlJykgJiYgdGl0bGUpIHtcbiAgICBsaW5lcy5wdXNoKGAgJHt0aXRsZX1gLCAnJyk7XG4gIH1cbiAgaWYgKG9wdGlvbkFQSSgncmVuZGVyRGVzY3JpcHRpb24nKSAmJiBkZXNjcmlwdGlvbikge1xuICAgIGxpbmVzLnB1c2goYCAke2Rlc2NyaXB0aW9ufWApO1xuICB9XG4gIGlmIChvcHRpb25BUEkoJ3JlbmRlckNvbW1lbnQnKSAmJiBjb21tZW50KSB7XG4gICAgbGluZXMucHVzaChgICR7Y29tbWVudH1gKTtcbiAgfVxuXG4gIGNvbW1lbnROb2RlLmNvbW1lbnRCZWZvcmUgPSBsaW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoaXRlck5vZGUgaW5zdGFuY2VvZiBZQU1MTWFwKSB7XG4gICAgaXRlck5vZGUuaXRlbXMuZm9yRWFjaChuID0+IHtcbiAgICAgIGFkZENvbW1lbnRzKGNvbnRleHQsIFsuLi5wYXRoLCAnaXRlbXMnLCBuLmtleS52YWx1ZV0sIG4ua2V5LCBuLnZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpdGVyTm9kZSBpbnN0YW5jZW9mIFlBTUxTZXEpIHtcbiAgICBpdGVyTm9kZS5pdGVtcy5mb3JFYWNoKChuLCBpKSA9PiB7XG4gICAgICBhZGRDb21tZW50cyhjb250ZXh0LCBbLi4ucGF0aCwgJ2l0ZW1zJywgaV0sIG4pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiBSZW5kZXIgWUFNTCBzdHJpbmcgZnJvbSB0aGUgZ2VuZXJhdGVkIHZhbHVlIGFuZCBjb250ZXh0XG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVuZGVyWUFNTCh7IHZhbHVlLCBjb250ZXh0IH0pIHtcbiAgY29uc3Qgbm9kZXMgPSB5YW1sLmNyZWF0ZU5vZGUodmFsdWUpO1xuXG4gIGFkZENvbW1lbnRzKGNvbnRleHQsIFtdLCBub2Rlcyk7XG5cbiAgY29uc3QgZG9jID0gbmV3IHlhbWwuRG9jdW1lbnQoKTtcbiAgZG9jLmNvbnRlbnRzID0gbm9kZXM7XG5cbiAgcmV0dXJuIGRvYy50b1N0cmluZygpO1xufVxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJZQU1MO1xuIiwiaW1wb3J0IHJlbmRlckpTIGZyb20gJy4vanMnO1xuaW1wb3J0IHJlbmRlcllBTUwgZnJvbSAnLi95YW1sJztcblxuZXhwb3J0IHtcbiAgcmVuZGVySlMsXG4gIHJlbmRlcllBTUwsXG59O1xuIiwiaW1wb3J0IHsgZ2V0RGVwZW5kZW5jaWVzIH0gZnJvbSAnLi92ZW5kb3InO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2NsYXNzL0NvbnRhaW5lcic7XG5pbXBvcnQgZm9ybWF0IGZyb20gJy4vYXBpL2Zvcm1hdCc7XG5pbXBvcnQgb3B0aW9uIGZyb20gJy4vYXBpL29wdGlvbic7XG5pbXBvcnQgZW52IGZyb20gJy4vY29yZS9jb25zdGFudHMnO1xuaW1wb3J0IHJhbmRvbSBmcm9tICcuL2NvcmUvcmFuZG9tJztcbmltcG9ydCB1dGlscyBmcm9tICcuL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHJ1biBmcm9tICcuL2NvcmUvcnVuJztcbmltcG9ydCB7IHJlbmRlckpTLCByZW5kZXJZQU1MIH0gZnJvbSAnLi9yZW5kZXJlcnMnO1xuXG5jb25zdCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKCk7XG5cbmZ1bmN0aW9uIHNldHVwS2V5d29yZHMoKSB7XG4gIC8vIHNhZmUgYXV0by1pbmNyZW1lbnQgdmFsdWVzXG4gIGNvbnRhaW5lci5kZWZpbmUoJ2F1dG9JbmNyZW1lbnQnLCBmdW5jdGlvbiBhdXRvSW5jcmVtZW50KHZhbHVlLCBzY2hlbWEpIHtcbiAgICBpZiAoIXRoaXMub2Zmc2V0KSB7XG4gICAgICBjb25zdCBtaW4gPSBzY2hlbWEubWluaW11bSB8fCAxO1xuICAgICAgY29uc3QgbWF4ID0gbWluICsgZW52Lk1BWF9OVU1CRVI7XG4gICAgICBjb25zdCBvZmZzZXQgPSB2YWx1ZS5pbml0aWFsT2Zmc2V0IHx8IHNjaGVtYS5pbml0aWFsT2Zmc2V0O1xuXG4gICAgICB0aGlzLm9mZnNldCA9IG9mZnNldCB8fCByYW5kb20ubnVtYmVyKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldCsrOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfSk7XG5cbiAgLy8gc2FmZS1hbmQtc2VxdWVudGlhbCBkYXRlc1xuICBjb250YWluZXIuZGVmaW5lKCdzZXF1ZW50aWFsRGF0ZScsIGZ1bmN0aW9uIHNlcXVlbnRpYWxEYXRlKHZhbHVlLCBzY2hlbWEpIHtcbiAgICBpZiAoIXRoaXMubm93KSB7XG4gICAgICB0aGlzLm5vdyA9IHJhbmRvbS5kYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzY2hlbWEgPSB0aGlzLm5vdy50b0lTT1N0cmluZygpO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdHJ1ZVxuICAgICAgICA/ICdkYXlzJ1xuICAgICAgICA6IHZhbHVlO1xuXG4gICAgICBpZiAoWydzZWNvbmRzJywgJ21pbnV0ZXMnLCAnaG91cnMnLCAnZGF5cycsICd3ZWVrcycsICdtb250aHMnLCAneWVhcnMnXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBpbmNyZW1lbnQgYnkgJHt1dGlscy5zaG9ydCh2YWx1ZSl9YCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubm93LnNldFRpbWUodGhpcy5ub3cuZ2V0VGltZSgpICsgcmFuZG9tLmRhdGUodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVmcyhyZWZzLCBzY2hlbWEpIHtcbiAgbGV0ICRyZWZzID0ge307XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocmVmcykpIHtcbiAgICByZWZzLmZvckVhY2goX3NjaGVtYSA9PiB7XG4gICAgICAkcmVmc1tfc2NoZW1hLiRpZCB8fCBfc2NoZW1hLmlkXSA9IF9zY2hlbWE7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgJHJlZnMgPSByZWZzIHx8IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gd2FsayhvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmouZm9yRWFjaCh3YWxrKTtcblxuICAgIGNvbnN0IF9pZCA9IG9iai4kaWQgfHwgb2JqLmlkO1xuXG4gICAgaWYgKHR5cGVvZiBfaWQgPT09ICdzdHJpbmcnICYmICEkcmVmc1tfaWRdKSB7XG4gICAgICAkcmVmc1tfaWRdID0gb2JqO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgd2FsayhvYmpba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICB3YWxrKHJlZnMpO1xuICB3YWxrKHNjaGVtYSk7XG5cbiAgcmV0dXJuICRyZWZzO1xufVxuXG5jb25zdCBqc2YgPSAoc2NoZW1hLCByZWZzLCBjd2QpID0+IHtcbiAgY29uc29sZS5sb2coJ1tqc29uLXNjaGVtYS1mYWtlcl0gY2FsbGluZyBKc29uU2NoZW1hRmFrZXIoKSBpcyBkZXByZWNhdGVkLCBjYWxsIGVpdGhlciAuZ2VuZXJhdGUoKSBvciAucmVzb2x2ZSgpJyk7XG5cbiAgaWYgKGN3ZCkge1xuICAgIGNvbnNvbGUubG9nKCdbanNvbi1zY2hlbWEtZmFrZXJdIHJlZmVyZW5jZXMgYXJlIG9ubHkgc3VwcG9ydGVkIGJ5IGNhbGxpbmcgLnJlc29sdmUoKScpO1xuICB9XG5cbiAgcmV0dXJuIGpzZi5nZW5lcmF0ZShzY2hlbWEsIHJlZnMpO1xufTtcblxuanNmLmdlbmVyYXRlV2l0aENvbnRleHQgPSAoc2NoZW1hLCByZWZzKSA9PiB7XG4gIGNvbnN0ICRyZWZzID0gZ2V0UmVmcyhyZWZzLCBzY2hlbWEpO1xuXG4gIHJldHVybiBydW4oJHJlZnMsIHNjaGVtYSwgY29udGFpbmVyLCB0cnVlKTtcbn07XG5cbmpzZi5nZW5lcmF0ZSA9IChzY2hlbWEsIHJlZnMpID0+IHJlbmRlckpTKFxuICAgIGpzZi5nZW5lcmF0ZVdpdGhDb250ZXh0KHNjaGVtYSwgcmVmcyksXG4gICk7XG5cbmpzZi5nZW5lcmF0ZVlBTUwgPSAoc2NoZW1hLCByZWZzKSA9PiByZW5kZXJZQU1MKFxuICAgIGpzZi5nZW5lcmF0ZVdpdGhDb250ZXh0KHNjaGVtYSwgcmVmcyksXG4gICk7XG5cbmpzZi5yZXNvbHZlV2l0aENvbnRleHQgPSAoc2NoZW1hLCByZWZzLCBjd2QpID0+IHtcbiAgaWYgKHR5cGVvZiByZWZzID09PSAnc3RyaW5nJykge1xuICAgIGN3ZCA9IHJlZnM7XG4gICAgcmVmcyA9IHt9O1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGJhc2VkaXIgKGJyb3dzZXIgYXdhcmUpXG4gIGN3ZCA9IGN3ZCB8fCAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2Vzcy5jd2QoKSA6ICcnKTtcbiAgY3dkID0gYCR7Y3dkLnJlcGxhY2UoL1xcLyskLywgJycpfS9gO1xuXG4gIGNvbnN0ICRyZWZzID0gZ2V0UmVmcyhyZWZzLCBzY2hlbWEpO1xuXG4gIC8vIGlkZW50aWNhbCBzZXR1cCBhcyBqc29uLXNjaGVtYS1zZXF1ZWxpemVyXG4gIGNvbnN0IGZpeGVkUmVmcyA9IHtcbiAgICBvcmRlcjogMSxcbiAgICBjYW5SZWFkKGZpbGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGZpbGUudXJsLnJlcGxhY2UoJy86JywgJzonKTtcblxuICAgICAgcmV0dXJuICRyZWZzW2tleV0gfHwgJHJlZnNba2V5LnNwbGl0KCcvJykucG9wKCldO1xuICAgIH0sXG4gICAgcmVhZChmaWxlLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcy5jYW5SZWFkKGZpbGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxuICBjb25zdCB7ICRSZWZQYXJzZXIgfSA9IGdldERlcGVuZGVuY2llcygpO1xuXG4gIHJldHVybiAkUmVmUGFyc2VyXG4gICAgLmJ1bmRsZShjd2QsIHNjaGVtYSwge1xuICAgICAgcmVzb2x2ZToge1xuICAgICAgICBmaWxlOiB7IG9yZGVyOiAxMDAgfSxcbiAgICAgICAgaHR0cDogeyBvcmRlcjogMjAwIH0sXG4gICAgICAgIGZpeGVkUmVmcyxcbiAgICAgIH0sXG4gICAgICBkZXJlZmVyZW5jZToge1xuICAgICAgICBjaXJjdWxhcjogJ2lnbm9yZScsXG4gICAgICB9LFxuICAgIH0pLnRoZW4oc3ViID0+IHJ1bigkcmVmcywgc3ViLCBjb250YWluZXIpKVxuICAgIC5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgcmVzb2x2aW5nIHNjaGVtYSAoJHtlLm1lc3NhZ2V9KWApO1xuICAgIH0pO1xufTtcblxuanNmLnJlc29sdmUgPSAoc2NoZW1hLCByZWZzLCBjd2QpID0+IGpzZi5yZXNvbHZlV2l0aENvbnRleHQoc2NoZW1hLCByZWZzLCBjd2QpLnRoZW4ocmVuZGVySlMpO1xuXG5qc2YucmVzb2x2ZVlBTUwgPSAoc2NoZW1hLCByZWZzLCBjd2QpID0+IGpzZi5yZXNvbHZlV2l0aENvbnRleHQoc2NoZW1hLCByZWZzLCBjd2QpLnRoZW4ocmVuZGVyWUFNTCk7XG5cbnNldHVwS2V5d29yZHMoKTtcblxuanNmLmZvcm1hdCA9IGZvcm1hdDtcbmpzZi5vcHRpb24gPSBvcHRpb247XG5qc2YucmFuZG9tID0gcmFuZG9tO1xuXG4vLyByZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmdcbmpzZi5leHRlbmQgPSAobmFtZSwgY2IpID0+IHtcbiAgY29udGFpbmVyLmV4dGVuZChuYW1lLCBjYik7XG4gIHJldHVybiBqc2Y7XG59O1xuXG5qc2YuZGVmaW5lID0gKG5hbWUsIGNiKSA9PiB7XG4gIGNvbnRhaW5lci5kZWZpbmUobmFtZSwgY2IpO1xuICByZXR1cm4ganNmO1xufTtcblxuanNmLnJlc2V0ID0gbmFtZSA9PiB7XG4gIGNvbnRhaW5lci5yZXNldChuYW1lKTtcbiAgc2V0dXBLZXl3b3JkcygpO1xuICByZXR1cm4ganNmO1xufTtcblxuanNmLmxvY2F0ZSA9IG5hbWUgPT4ge1xuICByZXR1cm4gY29udGFpbmVyLmdldChuYW1lKTtcbn07XG5cblxuaWYgKHR5cGVvZiBWRVJTSU9OICE9PSAndW5kZWZpbmVkJykge1xuICBqc2YudmVyc2lvbiA9IFZFUlNJT047XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzZjtcbiIsImltcG9ydCAkUmVmUGFyc2VyIGZyb20gJ2pzb24tc2NoZW1hLXJlZi1wYXJzZXInO1xuaW1wb3J0IHsgSlNPTlBhdGggfSBmcm9tICdqc29ucGF0aC1wbHVzJztcblxuaW1wb3J0IHsgc2V0RGVwZW5kZW5jaWVzIH0gZnJvbSAnLi9saWIvdmVuZG9yJztcblxuc2V0RGVwZW5kZW5jaWVzKHsgJFJlZlBhcnNlciwgSlNPTlBhdGggfSk7XG5cbmV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2xpYic7XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9tYWluLmNqcy5qcyc7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxRQUFBLGlCQUFBLFlBQUE7O1lBQU0sZUFBZTtBQUVkLFlBQU0sa0JBQWtCLE1BQU07QUFDbkMsaUJBQU87O0FBR0YsWUFBTSxtQkFBa0IsQ0FBQSxVQUFTO0FBQ3RDLGlCQUFPLE9BQU8sY0FBYzs7Ozs7QUNKOUIsUUFBQSxtQkFBQSxZQUFBOzs2QkFBZTtVQUNiLGNBQWM7QUFFWixpQkFBSyxPQUFPOztVQU9kLFdBQVcsTUFBTTtBQUNmLGdCQUFJLENBQUMsTUFBTTtBQUNULG1CQUFLLE9BQU87bUJBQ1A7QUFDTCxxQkFBTyxLQUFLLEtBQUs7OztVQU9yQixTQUFTLE1BQU0sVUFBVTtBQUN2QixpQkFBSyxLQUFLLFFBQVE7O1VBTXBCLGFBQWEsU0FBUztBQUNwQixtQkFBTyxLQUFLLFNBQVMsUUFBUSxDQUFBLFNBQVE7QUFDbkMsbUJBQUssS0FBSyxRQUFRLFFBQVE7OztVQU85QixJQUFJLE1BQU07QUFDUixrQkFBTSxTQUFTLEtBQUssS0FBSztBQUV6QixtQkFBTzs7VUFNVCxPQUFPO0FBQ0wsbUJBQU8sS0FBSzs7O0FBSWhCLFlBQU8sbUJBQVE7Ozs7QUN0RGYsUUFBQSxtQkFBQSxZQUFBOztZQUFNLFdBQVc7QUFFakIsWUFBTyxtQkFBUTtBQUVmLGlCQUFTLDRCQUE0QjtBQUNyQyxpQkFBUyxvQkFBb0I7QUFFN0IsaUJBQVMsbUJBQW1CO0FBQzVCLGlCQUFTLG9CQUFvQjtBQUM3QixpQkFBUyxxQkFBcUI7QUFDOUIsaUJBQVMsc0JBQXNCO0FBRS9CLGlCQUFTLHNCQUFzQjtBQUMvQixpQkFBUyx1QkFBdUI7QUFDaEMsaUJBQVMscUJBQXFCO0FBQzlCLGlCQUFTLG1CQUFtQjtBQUM1QixpQkFBUyxrQkFBa0I7QUFDM0IsaUJBQVMsZUFBZTtBQUV4QixpQkFBUyxXQUFXO0FBQ3BCLGlCQUFTLFdBQVc7QUFDcEIsaUJBQVMsWUFBWTtBQUNyQixpQkFBUyxZQUFZO0FBRXJCLGlCQUFTLGtCQUFrQjtBQUMzQixpQkFBUyxrQkFBa0I7QUFDM0IsaUJBQVMsaUJBQWlCO0FBQzFCLGlCQUFTLDRCQUE0QjtBQUVyQyxpQkFBUyxTQUFTLEtBQUs7QUFFdkIsaUJBQVMsY0FBYztBQUN2QixpQkFBUyxvQkFBb0I7QUFDN0IsaUJBQVMsZ0JBQWdCOzs7O0FDakN6QixRQUFBLHlCQUFBLFlBQUE7O1lBQUEsV0FBQTtBQUNBLFlBQUEsV0FBQTtBQUtBLFlBQUEsaUJBQUEsY0FBNkIsU0FBUztVQUNwQyxjQUFjO0FBQ1o7QUFDQSxpQkFBSyxPQUFPLGVBQUEsSUFBSztBQUNqQixpQkFBSyxZQUFZOztjQUdmLFdBQVc7QUFDYixtQkFBTyxlQUFBLElBQUssS0FBSzs7O0FBSXJCLFlBQU8seUJBQVE7Ozs7QUNsQmYsUUFBQSxpQkFBQSxZQUFBOztZQUFBLGlCQUFBO0FBR0EsWUFBTSxXQUFXLElBQUk7QUFRckIsMkJBQW1CLGlCQUFpQixlQUFlO0FBQ2pELGNBQUksT0FBTyxvQkFBb0IsVUFBVTtBQUN2QyxnQkFBSSxPQUFPLGtCQUFrQixhQUFhO0FBQ3hDLHFCQUFPLFNBQVMsU0FBUyxpQkFBaUI7O0FBRzVDLG1CQUFPLFNBQVMsSUFBSTs7QUFHdEIsaUJBQU8sU0FBUyxhQUFhOztBQUcvQixrQkFBVSxjQUFjLE1BQU0sU0FBUztBQUV2QyxZQUFPLGlCQUFROzs7O0FDekJmLFFBQUEsb0JBQUEsWUFBQTs7WUFBTSxnQkFBZ0IsQ0FBQyxXQUFXLFVBQVUsVUFBVTtBQUN0RCxZQUFNLGVBQWUsY0FBYyxPQUFPLENBQUM7QUFDM0MsWUFBTSxZQUFZLENBQUMsU0FBUyxVQUFVLE9BQU87QUFFN0MsWUFBTSxxQkFBcUI7QUFFM0IsWUFBTSxjQUFjO0FBQ3BCLFlBQU0sY0FBYztBQUVwQixZQUFNLGFBQWE7QUFDbkIsWUFBTSxhQUFhO0FBRW5CLFlBQU8sb0JBQVE7VUFDYjtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOzs7OztBQ3BCRixRQUFBLGdCQUFBLFlBQUE7TUFBQSxnQ0FBQSxVQUFBLFNBQUE7QUFBQSxnQkFBTyxVQUFVO1VBQ2YsTUFBYTtVQUNiLE9BQWE7VUFDYixVQUFhO1VBQ2IsS0FBYTtVQUNiLE9BQWE7VUFDYixZQUFhO1VBQ2IsV0FBYTtVQUNiLE1BQWE7Ozs7QUNSZixRQUFBLGVBQUEsWUFBQTtNQUFBLCtCQUFBLFVBQUE7QUFBQSxZQUFNLFFBQVE7QUFFZCxZQUFNLE9BQU8sTUFBTSxDQUFDLEVBQUUsTUFBTSxNQUFNLE9BQVEsTUFBTSxJQUFJLElBQUk7QUFFeEQsWUFBTSxRQUFRLE1BQU07QUFDbEIsaUJBQU87WUFDTCxFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU87WUFDM0IsRUFBRSxNQUFNLE1BQU0sT0FBTyxNQUFNLElBQUksSUFBSTtZQUNuQyxFQUFFLE1BQU0sTUFBTSxPQUFPLE1BQU0sSUFBSSxJQUFJO1lBQ25DLE9BQU87O0FBR1gsWUFBTSxhQUFhLE1BQU07QUFDdkIsaUJBQU87WUFDTCxFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU87WUFDM0IsRUFBRSxNQUFNLE1BQU0sTUFBTSxPQUFPO1lBQzNCLEVBQUUsTUFBTSxNQUFNLE1BQU0sT0FBTztZQUMzQixFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU87WUFDM0IsRUFBRSxNQUFNLE1BQU0sTUFBTSxPQUFPO1lBQzNCLEVBQUUsTUFBTSxNQUFNLE1BQU0sT0FBTztZQUMzQixFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU87WUFDM0IsRUFBRSxNQUFNLE1BQU0sTUFBTSxPQUFPO1lBQzNCLEVBQUUsTUFBTSxNQUFNLE9BQU8sTUFBTSxNQUFNLElBQUk7WUFDckMsRUFBRSxNQUFNLE1BQU0sTUFBTSxPQUFPO1lBQzNCLEVBQUUsTUFBTSxNQUFNLE1BQU0sT0FBTztZQUMzQixFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU87WUFDM0IsRUFBRSxNQUFNLE1BQU0sTUFBTSxPQUFPO1lBQzNCLEVBQUUsTUFBTSxNQUFNLE1BQU0sT0FBTztZQUMzQixFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU87OztBQUkvQixZQUFNLGFBQWEsTUFBTTtBQUN2QixpQkFBTztZQUNMLEVBQUUsTUFBTSxNQUFNLE1BQU0sT0FBTztZQUMzQixFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU87WUFDM0IsRUFBRSxNQUFNLE1BQU0sTUFBTSxPQUFPO1lBQzNCLEVBQUUsTUFBTSxNQUFNLE1BQU0sT0FBTzs7O0FBSy9CLGlCQUFRLFFBQVEsTUFBTyxHQUFFLE1BQU0sTUFBTSxLQUFLLEtBQUssU0FBUyxLQUFLO0FBQzdELGlCQUFRLFdBQVcsTUFBTyxHQUFFLE1BQU0sTUFBTSxLQUFLLEtBQUssU0FBUyxLQUFLO0FBQ2hFLGlCQUFRLE9BQU8sTUFBTyxHQUFFLE1BQU0sTUFBTSxLQUFLLEtBQUssUUFBUSxLQUFLO0FBQzNELGlCQUFRLFVBQVUsTUFBTyxHQUFFLE1BQU0sTUFBTSxLQUFLLEtBQUssUUFBUSxLQUFLO0FBQzlELGlCQUFRLGFBQWEsTUFBTyxHQUFFLE1BQU0sTUFBTSxLQUFLLEtBQUssY0FBYyxLQUFLO0FBQ3ZFLGlCQUFRLGdCQUFnQixNQUFPLEdBQUUsTUFBTSxNQUFNLEtBQUssS0FBSyxjQUFjLEtBQUs7QUFDMUUsaUJBQVEsVUFBVSxNQUFPLEdBQUUsTUFBTSxNQUFNLEtBQUssS0FBSyxjQUFjLEtBQUs7OztBQ2hEcEUsUUFBQSxlQUFBLFlBQUE7TUFBQSwrQkFBQSxVQUFBO0FBQUEsWUFBTSxRQUFRO0FBQ2QsWUFBTSxPQUFRO0FBR2QsWUFBTSxPQUFPO0FBQ2IsWUFBTSxPQUFPLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLO0FBUy9ELGlCQUFRLGFBQWEsU0FBUyxLQUFLO0FBRWpDLGNBQUksY0FBYztBQUNsQixnQkFBTSxJQUFJLFFBQVEsYUFBYSxTQUFTLEdBQUcsR0FBRyxLQUFLLEtBQUssS0FBSyxJQUFJLE9BQU8sT0FBTztBQUM3RSxnQkFBSSxLQUFLO0FBQ1AscUJBQU87O0FBR1QsZ0JBQUksT0FBTyxJQUFJLElBQ2IsTUFBUSxTQUFTLEtBQUssTUFDdEIsTUFBUSxTQUFTLEtBQUssTUFDdEIsS0FBUSxTQUFTLElBQU0sS0FDdkIsUUFBUSxLQUFLLFFBQVEsU0FDckIsS0FBSztBQUVQLGdCQUFJLElBQUksT0FBTyxhQUFhO0FBRzVCLGdCQUFJLG1CQUFtQixLQUFLLElBQUk7QUFDOUIsa0JBQUksT0FBTzs7QUFHYixtQkFBTzs7QUFHVCxpQkFBTzs7QUFZVCxpQkFBUSxnQkFBZ0IsQ0FBQyxLQUFLLGNBQWM7QUFFMUMsY0FBSSxTQUFTO0FBQ2IsY0FBSSxTQUFTO0FBQ2IsY0FBSSxJQUFJO0FBR1IsaUJBQVEsTUFBSyxPQUFPLEtBQUssU0FBUyxNQUFNO0FBQ3RDLGdCQUFJLEdBQUcsSUFBSTtBQUNULHFCQUFPLEtBQUssS0FBSzt1QkFFUixHQUFHLElBQUk7QUFDaEIscUJBQU8sS0FBSyxLQUFLO3VCQUVSLEdBQUcsSUFBSTtBQUNoQixxQkFBTyxLQUFLLEtBQUs7dUJBRVIsR0FBRyxJQUFJO0FBQ2hCLHFCQUFPLEtBQUssS0FBSzt1QkFFUixHQUFHLElBQUk7QUFDaEIscUJBQU8sS0FBSyxLQUFLO3VCQUVSLEdBQUcsSUFBSTtBQUNoQixxQkFBTyxLQUFLLEtBQUs7dUJBRVIsR0FBRyxJQUFJO0FBQ2hCLHFCQUFPLEtBQUs7Z0JBQ1YsTUFBTSxNQUFNO2dCQUNaLE1BQU8sSUFBRyxNQUFNLEdBQUcsSUFBSSxXQUFXO2dCQUNsQyxJQUFJLEdBQUcsSUFBSSxXQUFXOzt1QkFHZCxJQUFJLEdBQUcsS0FBTTtBQUN2QixxQkFBTyxLQUFLO2dCQUNWLE1BQU0sTUFBTTtnQkFDWixPQUFPLEVBQUUsV0FBVzs7bUJBR2pCO0FBQ0wscUJBQU8sQ0FBQyxRQUFRLE9BQU87OztBQUkzQixtQkFBUSxNQUFNLFdBQVc7O0FBVTNCLGlCQUFRLFFBQVEsQ0FBQyxRQUFRLFFBQVE7QUFDL0IsZ0JBQU0sSUFBSSxZQUFZLGtDQUFrQyxTQUFTLFFBQVE7Ozs7QUMxRzNFLFFBQUEsb0JBQUEsWUFBQTtNQUFBLG9DQUFBLFVBQUE7QUFBQSxZQUFNLFFBQVE7QUFDZCxpQkFBUSxlQUFlLE1BQU8sR0FBRSxNQUFNLE1BQU0sVUFBVSxPQUFPO0FBQzdELGlCQUFRLGtCQUFrQixNQUFPLEdBQUUsTUFBTSxNQUFNLFVBQVUsT0FBTztBQUNoRSxpQkFBUSxRQUFRLE1BQU8sR0FBRSxNQUFNLE1BQU0sVUFBVSxPQUFPO0FBQ3RELGlCQUFRLE1BQU0sTUFBTyxHQUFFLE1BQU0sTUFBTSxVQUFVLE9BQU87OztBQ0pwRCxRQUFBLGNBQUEsWUFBQTtNQUFBLGdDQUFBLFVBQUEsU0FBQTtBQUFBLFlBQU0sT0FBWTtBQUNsQixZQUFNLFFBQVk7QUFDbEIsWUFBTSxPQUFZO0FBQ2xCLFlBQU0sWUFBWTtBQUdsQixnQkFBTyxVQUFVLENBQUMsY0FBYztBQUM5QixjQUFJLElBQUksR0FBRyxHQUFHLEdBQ1osUUFBUSxFQUFFLE1BQU0sTUFBTSxNQUFNLE9BQU8sTUFHbkMsWUFBWSxPQUNaLE9BQU8sTUFBTSxPQUNiLGFBQWE7QUFHZixjQUFJLFlBQVksQ0FBQyxPQUFNO0FBQ3JCLGlCQUFLLE1BQU0sV0FBVywrQkFBK0IsS0FBSTs7QUFJM0QsY0FBSSxNQUFNLEtBQUssV0FBVztBQUMxQixjQUFJLElBQUk7QUFHUixpQkFBTyxJQUFJLEdBQUc7QUFDWixnQkFBSSxJQUFJO0FBRVIsb0JBQVE7bUJBRUQ7QUFDSCxvQkFBSSxJQUFJO0FBRVIsd0JBQVE7dUJBQ0Q7QUFDSCx5QkFBSyxLQUFLLFVBQVU7QUFDcEI7dUJBRUc7QUFDSCx5QkFBSyxLQUFLLFVBQVU7QUFDcEI7dUJBRUc7QUFDSCx5QkFBSyxLQUFLLEtBQUs7QUFDZjt1QkFFRztBQUNILHlCQUFLLEtBQUssS0FBSztBQUNmO3VCQUVHO0FBQ0gseUJBQUssS0FBSyxLQUFLO0FBQ2Y7dUJBRUc7QUFDSCx5QkFBSyxLQUFLLEtBQUs7QUFDZjt1QkFFRztBQUNILHlCQUFLLEtBQUssS0FBSztBQUNmO3VCQUVHO0FBQ0gseUJBQUssS0FBSyxLQUFLO0FBQ2Y7O0FBS0Esd0JBQUksS0FBSyxLQUFLLElBQUk7QUFDaEIsMkJBQUssS0FBSyxFQUFFLE1BQU0sTUFBTSxXQUFXLE9BQU8sU0FBUyxHQUFHOzJCQUdqRDtBQUNMLDJCQUFLLEtBQUssRUFBRSxNQUFNLE1BQU0sTUFBTSxPQUFPLEVBQUUsV0FBVzs7O0FBSXhEO21CQUlHO0FBQ0gscUJBQUssS0FBSyxVQUFVO0FBQ3BCO21CQUVHO0FBQ0gscUJBQUssS0FBSyxVQUFVO0FBQ3BCO21CQUlHO0FBRUgsb0JBQUk7QUFDSixvQkFBSSxJQUFJLE9BQU8sS0FBSztBQUNsQix3QkFBTTtBQUNOO3VCQUNLO0FBQ0wsd0JBQU07O0FBSVIsb0JBQUksY0FBYyxLQUFLLGNBQWMsSUFBSSxNQUFNLElBQUk7QUFHbkQscUJBQUssWUFBWTtBQUNqQixxQkFBSyxLQUFLO2tCQUNSLE1BQU0sTUFBTTtrQkFDWixLQUFLLFlBQVk7a0JBQ2pCOztBQUdGO21CQUlHO0FBQ0gscUJBQUssS0FBSyxLQUFLO0FBQ2Y7bUJBSUc7QUFFSCxvQkFBSSxRQUFRO2tCQUNWLE1BQU0sTUFBTTtrQkFDWixPQUFPO2tCQUNQLFVBQVU7O0FBR1osb0JBQUksSUFBSTtBQUdSLG9CQUFJLE1BQU0sS0FBSztBQUNiLHNCQUFJLElBQUksSUFBSTtBQUNaLHVCQUFLO0FBR0wsc0JBQUksTUFBTSxLQUFLO0FBQ2IsMEJBQU0sYUFBYTs2QkFHVixNQUFNLEtBQUs7QUFDcEIsMEJBQU0sZ0JBQWdCOzZCQUViLE1BQU0sS0FBSztBQUNwQix5QkFBSyxNQUFNLFdBQ1QsNkJBQTZCLDBCQUNMLElBQUk7O0FBR2hDLHdCQUFNLFdBQVc7O0FBSW5CLHFCQUFLLEtBQUs7QUFHViwyQkFBVyxLQUFLO0FBR2hCLDRCQUFZO0FBQ1osdUJBQU8sTUFBTTtBQUNiO21CQUlHO0FBQ0gsb0JBQUksV0FBVyxXQUFXLEdBQUc7QUFDM0IsdUJBQUssTUFBTSxXQUFXLHlCQUF5QixJQUFJOztBQUVyRCw0QkFBWSxXQUFXO0FBSXZCLHVCQUFPLFVBQVUsVUFDZixVQUFVLFFBQVEsVUFBVSxRQUFRLFNBQVMsS0FBSyxVQUFVO0FBQzlEO21CQUlHO0FBR0gsb0JBQUksQ0FBQyxVQUFVLFNBQVM7QUFDdEIsNEJBQVUsVUFBVSxDQUFDLFVBQVU7QUFDL0IseUJBQU8sVUFBVTs7QUFJbkIsb0JBQUksUUFBUTtBQUNaLDBCQUFVLFFBQVEsS0FBSztBQUN2Qix1QkFBTztBQUNQO21CQVFHO0FBQ0gsb0JBQUksS0FBSyxxQkFBcUIsS0FBSyxJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQ3ZELG9CQUFJLE9BQU8sTUFBTTtBQUNmLHNCQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLDhCQUFVOztBQUVaLHdCQUFNLFNBQVMsR0FBRyxJQUFJO0FBQ3RCLHdCQUFNLEdBQUcsS0FBSyxHQUFHLEtBQUssU0FBUyxHQUFHLElBQUksTUFBTSxXQUFXO0FBQ3ZELHVCQUFLLEdBQUcsR0FBRztBQUVYLHVCQUFLLEtBQUs7b0JBQ1IsTUFBTSxNQUFNO29CQUNaO29CQUNBO29CQUNBLE9BQU8sS0FBSzs7dUJBRVQ7QUFDTCx1QkFBSyxLQUFLO29CQUNSLE1BQU0sTUFBTTtvQkFDWixPQUFPOzs7QUFHWDttQkFFRztBQUNILG9CQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLDRCQUFVOztBQUVaLHFCQUFLLEtBQUs7a0JBQ1IsTUFBTSxNQUFNO2tCQUNaLEtBQUs7a0JBQ0wsS0FBSztrQkFDTCxPQUFPLEtBQUs7O0FBRWQ7bUJBRUc7QUFDSCxvQkFBSSxLQUFLLFdBQVcsR0FBRztBQUNyQiw0QkFBVTs7QUFFWixxQkFBSyxLQUFLO2tCQUNSLE1BQU0sTUFBTTtrQkFDWixLQUFLO2tCQUNMLEtBQUs7a0JBQ0wsT0FBTyxLQUFLOztBQUVkO21CQUVHO0FBQ0gsb0JBQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsNEJBQVU7O0FBRVoscUJBQUssS0FBSztrQkFDUixNQUFNLE1BQU07a0JBQ1osS0FBSztrQkFDTCxLQUFLO2tCQUNMLE9BQU8sS0FBSzs7QUFFZDs7QUFLQSxxQkFBSyxLQUFLO2tCQUNSLE1BQU0sTUFBTTtrQkFDWixPQUFPLEVBQUUsV0FBVzs7OztBQU81QixjQUFJLFdBQVcsV0FBVyxHQUFHO0FBQzNCLGlCQUFLLE1BQU0sV0FBVzs7QUFHeEIsaUJBQU87O0FBR1QsZ0JBQU8sUUFBUSxRQUFROzs7QUN6UnZCLFFBQUEsZUFBQSxZQUFBO01BQUEsbUNBQUEsVUFBQSxTQUFBO0FBQUE7QUFLQSxZQUFBLFdBQUEsTUFBZTtVQUNYLFlBQVksS0FBSyxNQUFNO0FBQ25CLGlCQUFLLE1BQU07QUFDWCxpQkFBSyxPQUFPO0FBQ1osaUJBQUssU0FBUyxJQUFJLE9BQU87O1VBRzdCLFNBQVMsT0FBTztBQUNaLG1CQUFPLENBQUUsTUFBSyxPQUFPLE1BQU0sT0FBTyxLQUFLLE1BQU0sTUFBTTs7VUFHdkQsUUFBUSxPQUFPO0FBQ1gsbUJBQU8sQ0FBRSxNQUFLLE9BQU8sSUFBSSxNQUFNLE9BQU8sS0FBSyxNQUFNLElBQUksTUFBTTs7VUFJL0QsSUFBSSxPQUFPO0FBQ1AsbUJBQU8sSUFBSSxTQUNQLEtBQUssSUFBSSxLQUFLLEtBQUssTUFBTSxNQUN6QixLQUFLLElBQUksS0FBSyxNQUFNLE1BQU07O1VBTWxDLFNBQVMsT0FBTztBQUNaLGdCQUFJLE1BQU0sT0FBTyxLQUFLLE9BQU8sTUFBTSxRQUFRLEtBQUssTUFBTTtBQUNsRCxxQkFBTzt1QkFDQSxNQUFNLE1BQU0sS0FBSyxPQUFPLE1BQU0sT0FBTyxLQUFLLE1BQU07QUFDdkQscUJBQU87Z0JBQ0gsSUFBSSxTQUFTLEtBQUssS0FBSyxNQUFNLE1BQU07Z0JBQ25DLElBQUksU0FBUyxNQUFNLE9BQU8sR0FBRyxLQUFLOzt1QkFFL0IsTUFBTSxPQUFPLEtBQUssS0FBSztBQUM5QixxQkFBTyxDQUFDLElBQUksU0FBUyxNQUFNLE9BQU8sR0FBRyxLQUFLO21CQUN2QztBQUNILHFCQUFPLENBQUMsSUFBSSxTQUFTLEtBQUssS0FBSyxNQUFNLE1BQU07OztVQUluRCxXQUFXO0FBQ1AsbUJBQU8sS0FBSyxPQUFPLEtBQUssT0FDcEIsS0FBSyxJQUFJLGFBQWEsS0FBSyxNQUFNLE1BQU0sS0FBSzs7O0FBS3hELFlBQUEsU0FBQSxNQUFhO1VBQ1QsWUFBWSxHQUFHLEdBQUc7QUFDZCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUssU0FBUztBQUNkLGdCQUFJLEtBQUs7QUFBTSxtQkFBSyxJQUFJLEdBQUc7O1VBRy9CLGlCQUFpQjtBQUNiLGlCQUFLLFNBQVMsS0FBSyxPQUFPLE9BQU8sQ0FBQyxVQUFVLFVBQVU7QUFDbEQscUJBQU8sV0FBVyxNQUFNO2VBQ3pCOztVQUdQLElBQUksR0FBRyxHQUFHO0FBQ04sZ0JBQUksT0FBTyxDQUFDLGFBQWE7QUFDckIsa0JBQUksSUFBSTtBQUNSLHFCQUFPLElBQUksS0FBSyxPQUFPLFVBQVUsQ0FBQyxTQUFTLFFBQVEsS0FBSyxPQUFPLEtBQUs7QUFDaEU7O0FBRUosa0JBQUksWUFBWSxLQUFLLE9BQU8sTUFBTSxHQUFHO0FBQ3JDLHFCQUFPLElBQUksS0FBSyxPQUFPLFVBQVUsU0FBUyxRQUFRLEtBQUssT0FBTyxLQUFLO0FBQy9ELDJCQUFXLFNBQVMsSUFBSSxLQUFLLE9BQU87QUFDcEM7O0FBRUosd0JBQVUsS0FBSztBQUNmLG1CQUFLLFNBQVMsVUFBVSxPQUFPLEtBQUssT0FBTyxNQUFNO0FBQ2pELG1CQUFLOztBQUdULGdCQUFJLGFBQWEsUUFBUTtBQUNyQixnQkFBRSxPQUFPLFFBQVE7bUJBQ2Q7QUFDSCxrQkFBSSxLQUFLO0FBQU0sb0JBQUk7QUFDbkIsbUJBQUssSUFBSSxTQUFTLEdBQUc7O0FBRXpCLG1CQUFPOztVQUdYLFNBQVMsR0FBRyxHQUFHO0FBQ1gsZ0JBQUksWUFBWSxDQUFDLGFBQWE7QUFDMUIsa0JBQUksSUFBSTtBQUNSLHFCQUFPLElBQUksS0FBSyxPQUFPLFVBQVUsQ0FBQyxTQUFTLFNBQVMsS0FBSyxPQUFPLEtBQUs7QUFDakU7O0FBRUosa0JBQUksWUFBWSxLQUFLLE9BQU8sTUFBTSxHQUFHO0FBQ3JDLHFCQUFPLElBQUksS0FBSyxPQUFPLFVBQVUsU0FBUyxTQUFTLEtBQUssT0FBTyxLQUFLO0FBQ2hFLDRCQUFZLFVBQVUsT0FBTyxLQUFLLE9BQU8sR0FBRyxTQUFTO0FBQ3JEOztBQUVKLG1CQUFLLFNBQVMsVUFBVSxPQUFPLEtBQUssT0FBTyxNQUFNO0FBQ2pELG1CQUFLOztBQUdULGdCQUFJLGFBQWEsUUFBUTtBQUNyQixnQkFBRSxPQUFPLFFBQVE7bUJBQ2Q7QUFDSCxrQkFBSSxLQUFLO0FBQU0sb0JBQUk7QUFDbkIsd0JBQVUsSUFBSSxTQUFTLEdBQUc7O0FBRTlCLG1CQUFPOztVQUdYLFVBQVUsR0FBRyxHQUFHO0FBQ1osZ0JBQUksWUFBWTtBQUNoQixnQkFBSSxhQUFhLENBQUMsYUFBYTtBQUMzQixrQkFBSSxJQUFJO0FBQ1IscUJBQU8sSUFBSSxLQUFLLE9BQU8sVUFBVSxDQUFDLFNBQVMsU0FBUyxLQUFLLE9BQU8sS0FBSztBQUNqRTs7QUFFSixxQkFBTyxJQUFJLEtBQUssT0FBTyxVQUFVLFNBQVMsU0FBUyxLQUFLLE9BQU8sS0FBSztBQUNoRSxvQkFBSSxNQUFNLEtBQUssSUFBSSxLQUFLLE9BQU8sR0FBRyxLQUFLLFNBQVM7QUFDaEQsb0JBQUksT0FBTyxLQUFLLElBQUksS0FBSyxPQUFPLEdBQUcsTUFBTSxTQUFTO0FBQ2xELDBCQUFVLEtBQUssSUFBSSxTQUFTLEtBQUs7QUFDakM7OztBQUlSLGdCQUFJLGFBQWEsUUFBUTtBQUNyQixnQkFBRSxPQUFPLFFBQVE7bUJBQ2Q7QUFDSCxrQkFBSSxLQUFLO0FBQU0sb0JBQUk7QUFDbkIseUJBQVcsSUFBSSxTQUFTLEdBQUc7O0FBRS9CLGlCQUFLLFNBQVM7QUFDZCxpQkFBSztBQUNMLG1CQUFPOztVQUdYLE1BQU0sT0FBTztBQUNULGdCQUFJLElBQUk7QUFDUixtQkFBTyxJQUFJLEtBQUssT0FBTyxVQUFVLEtBQUssT0FBTyxHQUFHLFVBQVUsT0FBTztBQUM3RCx1QkFBUyxLQUFLLE9BQU8sR0FBRztBQUN4Qjs7QUFFSixtQkFBTyxLQUFLLE9BQU8sR0FBRyxNQUFNOztVQUdoQyxXQUFXO0FBQ1AsbUJBQU8sT0FBTyxLQUFLLE9BQU8sS0FBSyxRQUFROztVQUczQyxRQUFRO0FBQ0osbUJBQU8sSUFBSSxPQUFPOztVQUd0QixVQUFVO0FBQ04sbUJBQU8sS0FBSyxPQUFPLE9BQU8sQ0FBQyxRQUFRLGFBQWE7QUFDNUMsa0JBQUksSUFBSSxTQUFTO0FBQ2pCLHFCQUFPLEtBQUssU0FBUyxNQUFNO0FBQ3ZCLHVCQUFPLEtBQUs7QUFDWjs7QUFFSixxQkFBTztlQUNSOztVQUdQLFlBQVk7QUFDUixtQkFBTyxLQUFLLE9BQU8sSUFBSSxDQUFDLGFBQWM7Y0FDbEMsS0FBSyxTQUFTO2NBQ2QsTUFBTSxTQUFTO2NBQ2YsUUFBUSxJQUFJLFNBQVMsT0FBTyxTQUFTOzs7O0FBS2pELGdCQUFPLFVBQVU7OztBQ2pMakIsUUFBQSxrQkFBQSxZQUFBO01BQUEsc0NBQUEsVUFBQSxTQUFBO0FBQUEsWUFBTSxNQUFTO0FBQ2YsWUFBTSxTQUFTO0FBQ2YsWUFBTSxRQUFTLElBQUk7QUFHbkIsZ0JBQU8sVUFBVSxjQUFjO1VBTTdCLFlBQVksUUFBUSxHQUFHO0FBQ3JCLGlCQUFLLGFBQWE7QUFDbEIsZ0JBQUksa0JBQWtCLFFBQVE7QUFDNUIsbUJBQUssYUFBYSxPQUFPO0FBQ3pCLG1CQUFLLFlBQVksT0FBTztBQUN4Qix1QkFBUyxPQUFPO3VCQUVQLE9BQU8sV0FBVyxVQUFVO0FBQ3JDLG1CQUFLLGFBQWEsS0FBSyxFQUFFLFFBQVEsU0FBUztBQUMxQyxtQkFBSyxZQUFZLEtBQUssRUFBRSxRQUFRLFNBQVM7bUJBQ3BDO0FBQ0wsb0JBQU0sSUFBSSxNQUFNOztBQUdsQixpQkFBSyxTQUFTLElBQUk7O1VBVXBCLGFBQWEsUUFBUTtBQUluQixpQkFBSyxNQUFNLE9BQU8sT0FBTyxPQUFPLE9BQU8sTUFDckMsUUFBUSxVQUFVLE9BQU8sT0FBTyxRQUFRLFVBQVUsTUFBTTtBQUkxRCxpQkFBSyxlQUFlLE9BQU8sZUFDekIsT0FBTyxlQUFlLEtBQUssYUFBYTtBQUUxQyxnQkFBSSxPQUFPLFNBQVM7QUFDbEIsbUJBQUssVUFBVSxPQUFPOzs7VUFVMUIsTUFBTTtBQUNKLG1CQUFPLEtBQUssS0FBSyxLQUFLLFFBQVE7O1VBV2hDLEtBQUssT0FBTyxRQUFRO0FBQ2xCLGdCQUFJLE9BQU8sS0FBSyxHQUFHLEdBQUc7QUFFdEIsb0JBQVEsTUFBTTttQkFDUCxNQUFNO21CQUNOLE1BQU07QUFFVCxvQkFBSSxNQUFNLGNBQWMsTUFBTSxlQUFlO0FBQUUseUJBQU87O0FBR3RELG9CQUFJLE1BQU0sWUFBWSxNQUFNLGdCQUFnQixRQUFXO0FBQ3JELHdCQUFNLGNBQWMsT0FBTyxLQUFLLFFBQVE7O0FBRzFDLHdCQUFRLE1BQU0sVUFDWixLQUFLLFlBQVksTUFBTSxXQUFXLE1BQU07QUFFMUMsc0JBQU07QUFDTixxQkFBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDeEMseUJBQU8sS0FBSyxLQUFLLE1BQU0sSUFBSTs7QUFHN0Isb0JBQUksTUFBTSxVQUFVO0FBQ2xCLHlCQUFPLE1BQU0sZUFBZTs7QUFFOUIsdUJBQU87bUJBRUosTUFBTTtBQUVULHVCQUFPO21CQUVKLE1BQU07QUFDVCxvQkFBSSxjQUFjLEtBQUssUUFBUTtBQUMvQixvQkFBSSxDQUFDLFlBQVksUUFBUTtBQUFFLHlCQUFPOztBQUNsQyx1QkFBTyxPQUFPLGFBQWEsS0FBSyxZQUFZO21CQUV6QyxNQUFNO0FBRVQsb0JBQUksS0FBSyxRQUFRLE1BQU0sS0FDckIsTUFBTSxRQUFRLFdBQVcsTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNO0FBRXhELHNCQUFNO0FBQ04scUJBQUssSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBQ3RCLHlCQUFPLEtBQUssS0FBSyxNQUFNLE9BQU87O0FBR2hDLHVCQUFPO21CQUVKLE1BQU07QUFDVCx1QkFBTyxPQUFPLE1BQU0sUUFBUSxNQUFNO21CQUUvQixNQUFNO0FBQ1Qsb0JBQUksT0FBTyxLQUFLLGNBQWMsS0FBSyxjQUNqQyxLQUFLLGFBQWEsTUFBTSxTQUFTLE1BQU07QUFDekMsdUJBQU8sT0FBTyxhQUFhOzs7VUFZakMsYUFBYSxNQUFNO0FBQ2pCLG1CQUFPLE9BQVEsT0FBTSxRQUFRLFFBQVEsTUFBTSxNQUN6QyxNQUFNLFFBQVEsUUFBUSxLQUFPLEtBQUs7O1VBU3RDLFlBQVk7QUFDVixtQkFBTyxDQUFDLEtBQUssUUFBUSxHQUFHOztVQVUxQixZQUFZLEtBQUs7QUFDZixnQkFBSSxlQUFlLFFBQVE7QUFDekIscUJBQU8sSUFBSSxNQUFNLEtBQUssUUFBUSxHQUFHLElBQUksU0FBUzs7QUFFaEQsbUJBQU8sSUFBSSxLQUFLLFFBQVEsR0FBRyxJQUFJLFNBQVM7O1VBVzFDLFFBQVEsT0FBTztBQUNiLGdCQUFJLE1BQU0sU0FBUyxJQUFJLE1BQU0sTUFBTTtBQUNqQyxxQkFBTyxJQUFJLE9BQU8sTUFBTTt1QkFDZixNQUFNLFNBQVMsSUFBSSxNQUFNLE9BQU87QUFDekMscUJBQU8sSUFBSSxPQUFPLE1BQU0sTUFBTSxNQUFNO21CQUMvQjtBQUNMLGtCQUFJLFNBQVMsSUFBSTtBQUNqQix1QkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLElBQUksUUFBUSxLQUFLO0FBQ3pDLG9CQUFJLFdBQVcsS0FBSyxRQUFRLE1BQU0sSUFBSTtBQUN0Qyx1QkFBTyxJQUFJO0FBQ1gsb0JBQUksS0FBSyxZQUFZO0FBQ25CLDJCQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQ3hDLHdCQUFJLE9BQU8sU0FBUyxNQUFNO0FBQzFCLHdCQUFJLGdCQUFnQixLQUFLLGFBQWE7QUFDdEMsd0JBQUksU0FBUyxlQUFlO0FBQzFCLDZCQUFPLElBQUk7Ozs7O0FBS25CLGtCQUFJLE1BQU0sS0FBSztBQUNiLHVCQUFPLEtBQUssYUFBYSxRQUFRLFNBQVM7cUJBQ3JDO0FBQ0wsdUJBQU8sS0FBSyxhQUFhLFFBQVEsVUFBVTs7OztVQWFqRCxRQUFRLEdBQUcsR0FBRztBQUNaLG1CQUFPLElBQUksS0FBSyxNQUFNLEtBQUssV0FBWSxLQUFJLElBQUk7O2NBTzdDLGVBQWU7QUFDakIsbUJBQU8sS0FBSyxTQUFTLEtBQUssVUFBVSxJQUFJLE9BQU8sSUFBSTs7Y0FHakQsYUFBYSxPQUFPO0FBQ3RCLGlCQUFLLFNBQVM7O2lCQVlULFFBQVEsUUFBUSxHQUFHO0FBQ3hCLGdCQUFJO0FBQ0osZ0JBQUcsT0FBTyxXQUFXLFVBQVU7QUFDN0IsdUJBQVMsSUFBSSxPQUFPLFFBQVE7O0FBRzlCLGdCQUFJLE9BQU8sYUFBYSxRQUFXO0FBQ2pDLHdCQUFVLElBQUksUUFBUSxRQUFRO0FBQzlCLHFCQUFPLFdBQVc7bUJBQ2I7QUFDTCx3QkFBVSxPQUFPO0FBQ2pCLHNCQUFRLGFBQWE7O0FBRXZCLG1CQUFPLFFBQVE7O2lCQU9WLFFBQVE7QUFFYixtQkFBTyxVQUFVLE1BQU0sV0FBVztBQUNoQyxxQkFBTyxRQUFRLFFBQVE7Ozs7OztBQ2pRN0IsUUFBQSxpQkFBQSxZQUFBOztZQUFBLFVBQUE7QUFFQSxZQUFBLFlBQUE7QUFDQSxZQUFBLE1BQUE7QUFFQSxrQ0FBMEIsS0FBSyxLQUFLO0FBQ2xDLGdCQUFNLE9BQU8sUUFBUSxjQUFjLElBQUksY0FBYztBQUNyRCxnQkFBTSxPQUFPLFFBQVEsY0FBYyxJQUFJLGNBQWM7QUFFckQsaUJBQU8sS0FBSyxNQUFNLFVBQVUsY0FBZ0IsT0FBTSxNQUFPLE1BQU07O0FBR2pFLDBCQUFrQixPQUFPO0FBRXZCLGtCQUFRLFVBQVUsTUFBTSxVQUFVO0FBR2xDLGtCQUFRLFVBQVUsVUFBVSxDQUFDLEdBQUcsTUFBTSxJQUFJLEtBQUssTUFBTSxVQUFVLGNBQWUsS0FBSyxLQUFJO0FBRXZGLGdCQUFNLEtBQUssSUFBSSxRQUFRO0FBRXZCLGlCQUFPLEdBQUc7O0FBU1osc0JBQWMsWUFBWTtBQUN4QixpQkFBTyxXQUFXLEtBQUssTUFBTSxVQUFVLGNBQWMsV0FBVzs7QUFTbEUseUJBQWlCLFlBQVk7QUFDM0IsY0FBSTtBQUNKLGNBQUk7QUFDSixjQUFJLFNBQVMsV0FBVztBQUV4QixnQkFBTSxPQUFPLFdBQVc7QUFFeEIsaUJBQU8sU0FBUyxLQUFJO0FBQ2xCLGtCQUFNLEtBQUssTUFBTSxVQUFVLGNBQWM7QUFFekMsc0JBQVU7QUFDVixrQkFBTSxLQUFLO0FBQ1gsaUJBQUssVUFBVSxLQUFLO0FBQ3BCLGlCQUFLLE9BQU87O0FBR2QsaUJBQU87O0FBU1QsMkJBQW1CLEtBQUssS0FBSztBQUMzQixpQkFBUSxVQUFVLGNBQWUsT0FBTSxPQUFROztBQWFqRCx3QkFBZ0IsS0FBSyxLQUFLLFFBQVEsUUFBUSxlQUFlLE9BQU87QUFDOUQsbUJBQVMsT0FBTyxXQUFXLGNBQWMsSUFBSSxhQUFhO0FBQzFELG1CQUFTLE9BQU8sV0FBVyxjQUFjLElBQUksYUFBYTtBQUUxRCxnQkFBTSxPQUFPLFFBQVEsY0FBYyxTQUFTO0FBQzVDLGdCQUFNLE9BQU8sUUFBUSxjQUFjLFNBQVM7QUFFNUMsY0FBSSxNQUFNLEtBQUs7QUFDYixtQkFBTzs7QUFHVCxjQUFJLGNBQWM7QUFDaEIsbUJBQU8sVUFBVSxLQUFLOztBQUd4QixpQkFBTyxpQkFBaUIsS0FBSzs7QUFHL0Isb0JBQVksTUFBTTtBQUNoQixrQkFBUTtpQkFDRDtBQUNILHFCQUFPLE9BQU8sR0FBRyxNQUFNO2lCQUVwQjtBQUNILHFCQUFPLE9BQU8sSUFBSSxNQUFNO2lCQUVyQjtBQUNILHFCQUFPLE9BQU8sSUFBSSxNQUFNO2lCQUVyQjtBQUNILHFCQUFPLE9BQU8sR0FBRyxNQUFNO2lCQUVwQjtBQUNILHFCQUFPLE9BQU8sR0FBRyxNQUFNO2lCQUVwQjtBQUNILHFCQUFPLE9BQU8sR0FBRyxNQUFNO2lCQUVwQjtBQUNILHFCQUFPLE9BQU8sR0FBRyxNQUFNOztBQUVoQjs7O0FBSWIsc0JBQWMsTUFBTTtBQUNsQixjQUFJLE1BQU07QUFDUixtQkFBTyxHQUFHOztBQUdaLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBTSxPQUFPLE9BQU8sTUFBTyxJQUFJO0FBRS9CLGNBQUksUUFBUSxJQUFJLFlBQVk7QUFFNUIsaUJBQU87O0FBR1QsWUFBTyxpQkFBUTtVQUNiO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsU0FBUzs7Ozs7QUM5SVgsUUFBQSxnQkFBQSxZQUFBOztZQUFBLFlBQUE7QUFDQSxZQUFBLE1BQUE7QUFDQSxZQUFBLFNBQUE7QUFFQSw2QkFBcUIsS0FBSyxNQUFNLE1BQU07QUFDcEMsZ0JBQU0sY0FBYyxLQUFLLFFBQVEsTUFBTSxLQUFLLE1BQU07QUFFbEQsY0FBSSxTQUFTLElBQUksUUFBUSxPQUFPLEtBQUssSUFBSSxRQUFRO0FBQ2pELGNBQUksUUFBUSxLQUFLLFNBQVMsU0FBUyxLQUFLLFlBQVksS0FBSztBQUN2RCxxQkFBUyxLQUFLLFlBQVk7O0FBRzVCLGNBQUksQ0FBQyxZQUFZO0FBQUksd0JBQVk7QUFFakMsaUJBQU8sVUFBVSxZQUFZLFNBQVMsR0FBRztBQUN2QyxrQkFBTSxPQUFPLFlBQVk7QUFFekIsZ0JBQUksQ0FBQyxPQUFPLE9BQU87QUFDakIsb0JBQU0sSUFBSSxNQUFNLG1CQUFtQixTQUFTOztBQUc5QyxxQkFBUyxPQUFPOztBQUVsQixpQkFBTzs7QUFVVCwrQkFBdUIsUUFBUSxZQUFZO0FBQ3pDLGlCQUFPLFdBQVcsT0FBTyxDQUFBLFFBQU87QUFDOUIsbUJBQU8sT0FBTyxJQUFJLFNBQVM7YUFDMUIsU0FBUzs7QUFVZCwyQkFBbUIsT0FBTztBQUN4QixjQUFJLE1BQU0sU0FBUyxNQUFNO0FBQ3ZCLG1CQUFPLElBQUksS0FBSyxPQUFPLGNBQWMsT0FBTyxHQUFHOztBQUdqRCxjQUFJLENBQUMsTUFBTSxPQUFPLE9BQU8sTUFBTSxNQUFNLEtBQUssR0FBRyxNQUFNO0FBRW5ELGtCQUFRLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJO0FBQ2pDLGdCQUFNLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJO0FBRS9CLGlCQUFPLEdBQUcsUUFBUSxTQUFTOztBQWE3QiwwQkFBa0IsTUFBTSxRQUFRLFVBQVU7QUFDeEMsZ0JBQU0sU0FBUztBQUdmLGtCQUFRLFFBQVEsT0FBTztpQkFDaEI7aUJBQ0E7QUFDSCxrQkFBSSxPQUFPLE9BQU8sWUFBWSxhQUFhO0FBQ3pDLHVCQUFPLFVBQVUsT0FBTzs7QUFHMUIsa0JBQUksT0FBTyxPQUFPLFlBQVksYUFBYTtBQUN6Qyx1QkFBTyxVQUFVLE9BQU87O0FBRzFCLGtCQUFJLE9BQU8sTUFBTTtBQUNmLG9CQUFJLE1BQU0sS0FBSyxJQUFJLE9BQU8sV0FBVyxHQUFHO0FBQ3hDLG9CQUFJLE1BQU0sS0FBSyxJQUFJLE9BQU8sV0FBVyxVQUFVO0FBRS9DLG9CQUFJLE9BQU8sb0JBQW9CLFFBQVEsT0FBTyxTQUFTO0FBQ3JELHlCQUFPLE9BQU8sY0FBYzs7QUFHOUIsb0JBQUksT0FBTyxvQkFBb0IsUUFBUSxPQUFPLFNBQVM7QUFDckQseUJBQU8sT0FBTyxjQUFjOztBQUk5QixvQkFBSSxPQUFPLFFBQVEsVUFBVTtBQUMzQix5QkFBTyxPQUFPLE9BQU8sS0FBSyxPQUFPLENBQUEsTUFBSztBQUNwQyx3QkFBSSxLQUFLLE9BQU8sS0FBSyxLQUFLO0FBQ3hCLDZCQUFPOztBQUdULDJCQUFPOzs7O0FBS2I7aUJBRUcsVUFBVTtBQUNiLHFCQUFPLFlBQVksVUFBVSxnQkFBZ0I7QUFDN0MscUJBQU8sWUFBWSxVQUFVLGdCQUFnQixPQUFPO0FBRXBELGtCQUFJLE9BQU8sT0FBTyxjQUFjLGFBQWE7QUFDM0MsdUJBQU8sWUFBWSxLQUFLLElBQUksT0FBTyxXQUFXLE9BQU87O0FBR3ZELGtCQUFJLE9BQU8sT0FBTyxjQUFjLGFBQWE7QUFDM0MsdUJBQU8sWUFBWSxLQUFLLElBQUksT0FBTyxXQUFXLE9BQU87O0FBR3ZEOzs7QUFHTzs7QUFJWCxjQUFJLFFBQVEsU0FBUztBQUdyQixjQUFJLFVBQVUsUUFBUSxVQUFVLFFBQVc7QUFDekMsbUJBQU87O0FBSVQsa0JBQVEsUUFBUSxPQUFPO2lCQUNoQjtBQUNILHNCQUFRLFdBQVc7QUFDbkI7aUJBRUc7QUFDSCxzQkFBUSxTQUFTLE9BQU87QUFDeEI7aUJBRUc7QUFDSCxzQkFBUSxDQUFDLENBQUM7QUFDVjtpQkFFRyxVQUFVO0FBQ2Isc0JBQVEsT0FBTztBQUVmLG9CQUFNLE1BQU0sS0FBSyxJQUFJLE9BQU8sYUFBYSxHQUFHO0FBQzVDLG9CQUFNLE1BQU0sS0FBSyxJQUFJLE9BQU8sYUFBYSxVQUFVO0FBRW5ELGtCQUFJO0FBQ0osa0JBQUksZ0JBQWdCO0FBRXBCLHFCQUFPLE1BQU0sU0FBUyxLQUFLO0FBQ3pCLHVCQUFPO0FBRVAsb0JBQUksQ0FBQyxPQUFPLFNBQVM7QUFDbkIsMkJBQVMsR0FBRyxPQUFPLEtBQUssQ0FBQyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFFBQVE7dUJBQy9EO0FBQ0wsMkJBQVMsT0FBTyxRQUFRLE9BQU87O0FBS2pDLG9CQUFJLFVBQVUsTUFBTTtBQUNsQixtQ0FBaUI7QUFDakIsc0JBQUksa0JBQWtCLEdBQUc7QUFDdkI7O3VCQUVHO0FBQ0wsa0NBQWdCOzs7QUFJcEIsa0JBQUksTUFBTSxTQUFTLEtBQUs7QUFDdEIsd0JBQVEsTUFBTSxPQUFPLEdBQUc7O0FBRzFCLHNCQUFRLE9BQU87cUJBQ1I7cUJBQ0E7QUFDSCwwQkFBUSxJQUFJLEtBQUssVUFBVSxRQUFRLGNBQWMsUUFBUSxlQUFlO0FBQ3hFO3FCQUVHO3FCQUNBO0FBQ0gsMEJBQVEsSUFBSSxLQUFLLFVBQVUsUUFBUSxjQUFjLE9BQU8sR0FBRztBQUMzRDtxQkFFRztBQUNILDBCQUFRLElBQUksS0FBSyxjQUFjLFNBQVMsY0FBYyxPQUFPO0FBQzdEOztBQUdBOztBQUVKOzs7QUFHTzs7QUFHWCxpQkFBTzs7QUFHVCx1QkFBZSxHQUFHLEdBQUc7QUFDbkIsaUJBQU8sS0FBSyxHQUFHLFFBQVEsQ0FBQSxRQUFPO0FBQzVCLGdCQUFJLE9BQU8sRUFBRSxTQUFTLFlBQVksRUFBRSxTQUFTLE1BQU07QUFDakQsZ0JBQUUsT0FBTyxFQUFFO3VCQUNGLE1BQU0sUUFBUSxFQUFFLE9BQU87QUFDaEMsZ0JBQUUsT0FBTyxFQUFFLFFBQVE7QUFFbkIsZ0JBQUUsS0FBSyxRQUFRLENBQUEsVUFBUztBQUN0QixvQkFBSSxNQUFNLFFBQVEsRUFBRSxTQUFTLEVBQUUsS0FBSyxRQUFRLFdBQVcsSUFBSTtBQUN6RCxvQkFBRSxLQUFLLEtBQUs7Ozt1QkFHUCxPQUFPLEVBQUUsU0FBUyxZQUFZLEVBQUUsU0FBUyxRQUFRLE1BQU0sUUFBUSxFQUFFLE9BQU87QUFDakYsZ0JBQUUsT0FBTyxNQUFNLElBQUksRUFBRTttQkFDaEI7QUFDTCxnQkFBRSxPQUFPLE1BQU0sRUFBRSxNQUFNLEVBQUU7OztBQUk3QixpQkFBTzs7QUFHVCx1QkFBZSxLQUFLLFFBQVEsSUFBSSxPQUFPO0FBQ3JDLGNBQUksQ0FBQyxPQUFPLE9BQU8sUUFBUSxVQUFVO0FBQ25DLG1CQUFPOztBQUdULGNBQUksTUFBTSxJQUFJLE1BQU07QUFDbEIsbUJBQU8sTUFBTSxJQUFJOztBQUduQixjQUFJLE1BQU0sUUFBUSxNQUFNO0FBQ3RCLGtCQUFNLE1BQU07QUFDWixrQkFBTSxJQUFJLEtBQUs7QUFFZixnQkFBSSxLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUEsTUFBSyxNQUFNLEdBQUc7QUFDbEMsbUJBQU87O0FBR1QsZ0JBQU0sWUFBWTtBQUNsQixnQkFBTSxJQUFJLEtBQUs7QUFFZixpQkFBTyxPQUFPLEtBQUssS0FBSyxPQUFPLENBQUMsTUFBTSxRQUFRO0FBQzVDLGlCQUFLLE9BQU8sTUFBTSxJQUFJLE1BQU07QUFDNUIsbUJBQU87YUFDTjs7QUFHTCx1QkFBZSxRQUFRO0FBQ3JCLGdCQUFNLElBQUksS0FBSyxVQUFVO0FBQ3pCLGdCQUFNLElBQUksS0FBSyxVQUFVLFFBQVEsTUFBTTtBQUV2QyxpQkFBTyxFQUFFLFNBQVMsTUFBTSxHQUFHLEVBQUUsT0FBTyxHQUFHLFlBQVk7O0FBR3JELDRCQUFvQjtBQUNsQixpQkFBTyxPQUFPLEtBQUs7WUFDakI7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBLEtBQUs7WUFDTDtZQUNBO1lBQ0E7WUFDQTtZQUVBLEtBQUs7WUFDTCxLQUFLLFNBQVMsU0FBUyxJQUFJLE9BQU87OztBQUl0QywwQkFBa0IsUUFBUSxRQUFRO0FBQ2hDLGdCQUFNLE9BQU8sTUFBTSxJQUFJO0FBRXZCLGNBQUksT0FBTyxPQUFPLFlBQVksYUFBYTtBQUN6QyxpQkFBSyxVQUFVLE9BQU87QUFDdEIsaUJBQUssbUJBQW1COztBQUcxQixjQUFJLE9BQU8sT0FBTyxZQUFZLGFBQWE7QUFDekMsaUJBQUssVUFBVSxPQUFPLFVBQVUsS0FBSyxVQUFVLElBQUksT0FBTztBQUMxRCxpQkFBSyxtQkFBbUI7O0FBRzFCLGNBQUksT0FBTyxPQUFPLGNBQWMsYUFBYTtBQUMzQyxpQkFBSyxZQUFZLE9BQU87O0FBRzFCLGNBQUksT0FBTyxPQUFPLGNBQWMsYUFBYTtBQUMzQyxpQkFBSyxZQUFZLE9BQU8sWUFBWSxLQUFLLFlBQVksSUFBSSxPQUFPOztBQUdsRSxjQUFJLE9BQU8sTUFBTTtBQUNmLGlCQUFLLE9BQU8sT0FBTyxLQUFLLElBQUksYUFBYSxPQUFPLENBQUEsTUFBSztBQUNuRCxvQkFBTSxRQUFRLE1BQU0sUUFBUSxPQUFPLFFBQVEsT0FBTyxPQUFPLENBQUMsT0FBTztBQUVqRSxxQkFBTyxNQUFNLE1BQU0sQ0FBQSxTQUFRO0FBRXpCLG9CQUFJLE1BQU0sWUFBWSxNQUFNLFdBQVc7QUFDckMseUJBQU8sU0FBUyxZQUFZLFNBQVM7O0FBR3ZDLHVCQUFPLE1BQU07OztxQkFHUixPQUFPLE1BQU07QUFDdEIsZ0JBQUk7QUFFSixlQUFHO0FBQ0Qsc0JBQVE7cUJBQ0QsT0FBTyxLQUFLLFFBQVEsV0FBVztBQUV4QyxpQkFBSyxPQUFPLENBQUM7O0FBR2YsY0FBSSxPQUFPLFlBQVksS0FBSyxZQUFZO0FBQ3RDLG1CQUFPLFNBQVMsUUFBUSxDQUFBLFNBQVE7QUFDOUIscUJBQU8sS0FBSyxXQUFXOzs7QUFNM0IsaUJBQU87O0FBR1Qsd0NBQWdDLE9BQU8sUUFBUTtBQUM3QyxnQkFBTSxlQUFlLE9BQU8sWUFBWTtBQUN4QyxnQkFBTSxlQUFlLE9BQU8sWUFBWTtBQUV4QyxpQkFDRyxpQkFBZ0IsaUJBQ2IsRUFBQyxnQkFBZ0IsU0FBUyxPQUFPLFlBQ2pDLEVBQUMsZ0JBQWdCLFNBQVMsT0FBTzs7QUFLekMsMEJBQWtCLE9BQU8sU0FBUztBQUNoQyxpQkFBTyxDQUFDLFFBQVEsTUFBTSxDQUFBLFdBQVUsdUJBQXVCLE9BQU87O0FBR2hFLHVDQUErQixPQUFPLE9BQU87QUFDM0MsZ0JBQU0sYUFBYSxNQUFNLE9BQU8sQ0FBQyxPQUFPLFdBQVksUUFBVSx3QkFBdUIsT0FBTyxVQUFXLElBQUksSUFBSztBQUNoSCxpQkFBTyxlQUFlOztBQUd4Qix1QkFBZSxNQUFNO0FBQ25CLGlCQUFPLENBQUMsUUFBUSxTQUFTLFdBQVcsWUFBWSxZQUFZLGVBQWUsU0FBUyxjQUFjLFNBQVM7O0FBRzdHLDJCQUFtQixLQUFLLE9BQU87QUFDN0IsaUJBQU8sT0FBTyxLQUFLLEtBQ2hCLE9BQU8sQ0FBQSxRQUFPLENBQUMsTUFBTSxTQUFTLE1BQzlCLE9BQU8sQ0FBQyxNQUFNLE1BQU07QUFDbkIsZ0JBQUksTUFBTSxRQUFRLElBQUksS0FBSztBQUN6QixtQkFBSyxLQUFLLElBQUksR0FBRzttQkFDWjtBQUNMLG1CQUFLLEtBQUssSUFBSSxjQUFjLFNBQ3hCLE1BQU0sSUFBSSxJQUFJLE1BQ2QsSUFBSTs7QUFHVixtQkFBTzthQUNOOztBQUdQLDBCQUFrQixPQUFPLFFBQVE7QUFDL0IsY0FBSSxNQUFNLFFBQVEsUUFBUTtBQUN4QixtQkFBTyxNQUFNLElBQUksQ0FBQSxNQUFLLFNBQVMsR0FBRzs7QUFHcEMsY0FBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixvQkFBUSxNQUFNLFFBQVEsbUJBQW1CLENBQUMsR0FBRyxPQUFPLE9BQU87O0FBRzdELGlCQUFPOztBQVNULHlCQUFpQixPQUFPO0FBQ3RCLGlCQUFPLE9BQU8sVUFBVSxTQUFTLEtBQUssV0FBVyxxQkFBcUIsQ0FBQyxPQUFPLEtBQUssT0FBTzs7QUFVNUYsNkJBQXFCLEtBQUssUUFBUTtBQUNoQyxnQkFBTSxhQUFhLE1BQU0sUUFBUSxPQUFPLGFBQWEsT0FBTyxTQUFTLFNBQVM7QUFDOUUsZ0JBQU0sYUFBYSxPQUFPLE9BQU8sVUFBVSxjQUFlLE9BQU8sd0JBQXdCLE9BQU8sT0FBTyxxQkFBcUIsVUFBVTtBQUV0SSxpQkFBTyxDQUFDLGNBQWMsQ0FBQzs7QUFZekIsdUJBQWUsS0FBSyxRQUFRLFVBQVUsT0FBTztBQUMzQyxjQUFJLENBQUMsT0FBTyxPQUFPLFFBQVEsVUFBVTtBQUNuQyxtQkFBTzs7QUFHVCxjQUFJLE1BQU0sUUFBUSxNQUFNO0FBQ3RCLG1CQUFPLElBQ0osSUFBSSxDQUFBLFVBQVMsTUFBTSxPQUFPLFFBQVEsT0FDbEMsT0FBTyxDQUFBLFVBQVMsT0FBTyxVQUFVOztBQUd0QyxpQkFBTyxLQUFLLEtBQUssUUFBUSxDQUFBLE1BQUs7QUFDNUIsZ0JBQUksUUFBUSxJQUFJLEtBQUs7QUFDbkIsa0JBQUksWUFBWSxHQUFHLFNBQVM7QUFDMUIsdUJBQU8sSUFBSTs7bUJBRVI7QUFDTCxvQkFBTSxRQUFRLE1BQU0sSUFBSSxJQUFJO0FBRTVCLGtCQUFJLENBQUMsUUFBUSxRQUFRO0FBQ25CLG9CQUFJLEtBQUs7OztBQUdiLGdCQUFJLE9BQU8sSUFBSSxPQUFPLGFBQWE7QUFDakMscUJBQU8sSUFBSTs7O0FBSWYsY0FBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLFVBQVUsU0FBUztBQUN2QyxtQkFBTzs7QUFHVCxpQkFBTzs7QUFHVCxZQUFPLGdCQUFRO1VBQ2I7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOzs7OztBQzlkRixRQUFBLG9CQUFBLFlBQUE7OzJCQUFBLFlBQUE7QUFHQSx1QkFBZSxLQUFLO0FBQ2xCLGlCQUFPLENBQUMsT0FBTyxRQUFRLFVBQVUsZUFBZTtBQUM5QyxnQkFBSSxLQUFLO0FBQ1QsZ0JBQUksT0FBTztBQUdYLGdCQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLG1CQUFLLE9BQU8sS0FBSyxPQUFPO0FBR3hCLGtCQUFJLE1BQU0sUUFBUSxNQUFNLE1BQU07QUFFNUIsdUJBQU8sTUFBTTtxQkFDUjtBQUNMLHFCQUFLLEtBQUssTUFBTTs7O0FBS3BCLGtCQUFNLFFBQVEsR0FBRyxNQUFNO0FBR3ZCLGdCQUFJLE1BQU07QUFFVixtQkFBTyxNQUFNLFNBQVMsR0FBRztBQUN2QixvQkFBTSxJQUFJLE1BQU07O0FBSWxCLG9CQUFRLE9BQU8sUUFBUSxXQUFXLElBQUksTUFBTSxNQUFNO0FBR2xELGdCQUFJLE9BQU8sVUFBVSxZQUFZO0FBQy9CLHNCQUFRLE1BQU0sTUFBTSxLQUFLLEtBQUssSUFBSSxDQUFBLE1BQUssYUFBQSxRQUFLLFNBQVMsR0FBRzs7QUFJMUQsZ0JBQUksT0FBTyxVQUFVLFNBQVMsS0FBSyxXQUFXLG1CQUFtQjtBQUMvRCxxQkFBTyxLQUFLLE9BQU8sUUFBUSxDQUFBLFFBQU87QUFDaEMsb0JBQUksT0FBTyxNQUFNLFNBQVMsWUFBWTtBQUNwQyx3QkFBTSxJQUFJLE1BQU0sNkJBQTZCLGFBQWEsZUFBZTs7OztBQUsvRSxtQkFBTzs7O0FBWVgsWUFBQSxZQUFBLE1BQWdCO1VBQ2QsY0FBYztBQUdaLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssVUFBVTs7VUFPakIsTUFBTSxNQUFNO0FBQ1YsZ0JBQUksQ0FBQyxNQUFNO0FBQ1QsbUJBQUssV0FBVztBQUNoQixtQkFBSyxVQUFVO21CQUNWO0FBQ0wscUJBQU8sS0FBSyxTQUFTO0FBQ3JCLHFCQUFPLEtBQUssUUFBUTs7O1VBU3hCLE9BQU8sTUFBTSxVQUFVO0FBQ3JCLGlCQUFLLFNBQVMsUUFBUSxTQUFTLEtBQUssU0FBUztBQUc3QyxnQkFBSSxDQUFDLEtBQUssUUFBUSxPQUFPO0FBQ3ZCLG1CQUFLLFFBQVEsUUFBUSxNQUFNLE1BQU0sS0FBSyxTQUFTOzs7VUFTbkQsT0FBTyxNQUFNLFVBQVU7QUFDckIsaUJBQUssUUFBUSxRQUFROztVQVF2QixJQUFJLE1BQU07QUFDUixnQkFBSSxPQUFPLEtBQUssU0FBUyxVQUFVLGFBQWE7QUFDOUMsb0JBQU0sSUFBSSxlQUFlLElBQUk7O0FBRS9CLG1CQUFPLEtBQUssU0FBUzs7VUFPdkIsS0FBSyxRQUFRO0FBQ1gsZ0JBQUksQ0FBRSxlQUFjLFNBQVM7QUFDM0Isb0JBQU0sT0FBTyxPQUFPLEtBQUs7QUFDekIsb0JBQU0sVUFBVTtBQUVoQixrQkFBSSxTQUFTLEtBQUs7QUFFbEIscUJBQU8sVUFBVTtBQUNmLHNCQUFNLEtBQUssS0FBSyxRQUFRLFFBQVEsT0FBTztBQUN2QyxzQkFBTSxNQUFNLEtBQUssUUFBUTtBQUV6QixvQkFBSSxPQUFPLFFBQVEsWUFBWTtBQUM3Qix5QkFBTyxlQUFlLFFBQVEsWUFBWTtvQkFDeEMsY0FBYztvQkFDZCxZQUFZO29CQUNaLFVBQVU7b0JBQ1YsT0FBTyxDQUFDLFlBQVksUUFBUSxJQUFJLEtBQUssU0FBUyxPQUFPLEtBQUssVUFBVSxRQUFRLEtBQUssU0FBUyxZQUFZLElBQUk7O0FBRTVHOzs7O0FBSU4sbUJBQU87OztBQUlYLFlBQU8sb0JBQVE7Ozs7QUNuSmYsUUFBQSxpQkFBQSxZQUFBOztZQUFBLFdBQUE7QUFHQSxZQUFNLFdBQVcsSUFBSTtBQVVyQiwyQkFBbUIsaUJBQWlCLFVBQVU7QUFDNUMsY0FBSSxPQUFPLG9CQUFvQixhQUFhO0FBQzFDLG1CQUFPLFNBQVM7O0FBR2xCLGNBQUksT0FBTyxvQkFBb0IsVUFBVTtBQUN2QyxnQkFBSSxPQUFPLGFBQWEsWUFBWTtBQUNsQyx1QkFBUyxTQUFTLGlCQUFpQjt1QkFDMUIsYUFBYSxRQUFRLGFBQWEsT0FBTztBQUNsRCx1QkFBUyxXQUFXO21CQUNmO0FBQ0wscUJBQU8sU0FBUyxJQUFJOztpQkFFakI7QUFDTCxxQkFBUyxhQUFhOzs7QUFJMUIsWUFBTyxpQkFBUTs7OztBQy9CZixRQUFBLGdCQUFBLFlBQUE7O3VDQUF5QixNQUFNO1VBQzdCLFlBQVksU0FBUyxNQUFNO0FBQ3pCO0FBQ0EsZ0JBQUksTUFBTSxtQkFBbUI7QUFDM0Isb0JBQU0sa0JBQWtCLE1BQU0sS0FBSzs7QUFFckMsaUJBQUssT0FBTztBQUNaLGlCQUFLLFVBQVU7QUFDZixpQkFBSyxPQUFPOzs7QUFJaEIsWUFBTyxnQkFBUTs7OztBQ1pmLFFBQUEsZ0JBQUEsWUFBQTs7WUFBTSxxQkFBcUI7VUFDekIsT0FBTztZQUNMO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7O1VBRUYsU0FBUztZQUNQO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7O1VBRUYsUUFBUTtZQUNOO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBOztVQUVGLFFBQVE7WUFDTjtZQUNBO1lBQ0E7WUFDQTs7O0FBSUosMkJBQW1CLFNBQVMsbUJBQW1CO0FBRS9DLFlBQU0sc0JBQXNCO1VBQzFCO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7QUFZRiw2QkFBcUIsS0FBSyxtQkFBbUIsd0JBQXdCO0FBQ25FLGlCQUFPLE9BQU8sS0FBSyxLQUFLLE9BQU8sQ0FBQSxTQUFRO0FBQ3JDLGtCQUFNLGNBQWMsb0JBQW9CLFFBQVEscUJBQXFCO0FBQ3JFLGtCQUFNLHdCQUF3Qix1QkFBdUIsUUFBUSxRQUFRO0FBRXJFLGdCQUFJLHlCQUF5QixDQUFDLGFBQWE7QUFDekMscUJBQU87O0FBR1QsbUJBQU87YUFDTixTQUFTOztBQVNkLDJCQUFtQixLQUFLLFlBQVk7QUFDbEMsZ0JBQU0sT0FBTyxPQUFPLEtBQUs7QUFFekIsbUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUssR0FBRztBQUN2QyxrQkFBTSxXQUFXLEtBQUs7QUFDdEIsa0JBQU0sb0JBQW9CLFdBQVcsV0FBVyxTQUFTO0FBRXpELGdCQUFJLFlBQVksS0FBSyxtQkFBbUIsbUJBQW1CLFlBQVk7QUFDckUscUJBQU87Ozs7QUFLYixZQUFPLGdCQUFROzs7O0FDcEZmLFFBQUEsa0JBQUEsWUFBQTs7WUFBQSxZQUFBO0FBT0Esb0NBQTRCO0FBQzFCLGlCQUFPLFVBQVUsY0FBYzs7QUFHakMsWUFBTyxrQkFBUTs7OztBQ1hmLFFBQUEsbUJBQUEsWUFBQTs7WUFBQSxtQkFBQTtBQUVBLFlBQU0sY0FBYztBQUVwQixZQUFPLGtCQUFROzs7O0FDQ2YsUUFBQSxlQUFBLFlBQUE7O2lDQUF5QjtBQUN2QixpQkFBTzs7QUFHVCxZQUFPLGVBQVE7Ozs7QUNUZixRQUFBLGdCQUFBLFlBQUE7O1lBQUEsZ0JBQUE7QUFFQSxZQUFNLFdBQVc7QUFFakIsWUFBTyxlQUFROzs7O0FDSmYsUUFBQSxnQkFBQSxZQUFBOztZQUFBLFNBQUE7QUFDQSxZQUFBLFFBQUE7QUFDQSxZQUFBLGFBQUE7QUFDQSxZQUFBLFlBQUE7QUFHQSx3QkFBZ0IsTUFBTSxPQUFPLE9BQU8sUUFBUSxTQUFTLGtCQUFrQjtBQUNyRSxnQkFBTSxNQUFNO0FBQ1osZ0JBQU0sT0FBTztBQUViLHdCQUFjLEtBQUs7QUFDakIsa0JBQU0sT0FBTyxLQUFLLFVBQVU7QUFFNUIsZ0JBQUksS0FBSyxRQUFRLFVBQVUsSUFBSTtBQUM3QixtQkFBSyxLQUFLO0FBQ1Ysa0JBQUksS0FBSztBQUVULHFCQUFPOztBQUdULG1CQUFPOztBQUdULGdCQUFNLFFBQVE7QUFHZCxjQUFJLFFBQVE7QUFFWixpQkFBTyxJQUFJLFdBQVcsTUFBTSxRQUFRO0FBQ2xDLGdCQUFJLENBQUMsS0FBSyxpQkFBaUIsTUFBTSxTQUFTLFFBQVEsTUFBTSxXQUFXO0FBQ2pFLHVCQUFTOztBQUdYLGdCQUFJLENBQUMsT0FBTztBQUNWOzs7QUFJSixpQkFBTzs7QUFJVCwyQkFBbUIsT0FBTyxNQUFNLFNBQVMsa0JBQWtCO0FBQ3pELGdCQUFNLFFBQVE7QUFFZCxjQUFJLENBQUUsT0FBTSxTQUFTLE1BQU0sa0JBQWtCO0FBQzNDLGdCQUFJLE1BQU0sY0FBYyxPQUFPLFlBQVksWUFBWSxnQkFBZ0I7QUFDckUsb0JBQU0sSUFBSSxXQUFXLHFCQUFxQixNQUFNLE1BQU0sVUFBVTs7QUFFbEUsbUJBQU87O0FBR1QsY0FBSSxNQUFNLFFBQVEsTUFBTSxRQUFRO0FBQzlCLG1CQUFPLE1BQU0sTUFBTSxJQUFJLENBQUMsTUFBTSxRQUFRO0FBQ3BDLG9CQUFNLGNBQWMsS0FBSyxPQUFPLENBQUMsU0FBUztBQUUxQyxxQkFBTyxpQkFBaUIsTUFBTSxhQUFhOzs7QUFJL0MsY0FBSSxXQUFXLE1BQU07QUFDckIsY0FBSSxXQUFXLE1BQU07QUFFckIsZ0JBQU0sa0JBQWtCLFVBQVU7QUFDbEMsZ0JBQU0sa0JBQWtCLFVBQVU7QUFFbEMsY0FBSSxpQkFBaUI7QUFFbkIsdUJBQVcsT0FBTyxhQUFhLGNBQzNCLGtCQUNBLEtBQUssSUFBSSxpQkFBaUI7O0FBR2hDLGNBQUksaUJBQWlCO0FBQ25CLHVCQUFXLE9BQU8sYUFBYSxjQUMzQixrQkFDQSxLQUFLLElBQUksaUJBQWlCO0FBRzlCLGdCQUFJLFlBQVksV0FBVyxpQkFBaUI7QUFDMUMseUJBQVc7O0FBSWIsZ0JBQUksWUFBWSxXQUFXLGlCQUFpQjtBQUMxQyx5QkFBVzs7O0FBSWYsZ0JBQU0sdUJBQXVCLFVBQVUsMkJBQTJCLE9BQU8sSUFBTSxVQUFVO0FBQ3pGLGdCQUFNLHFCQUFxQixVQUFVLDBCQUEwQixVQUFVLHlCQUF5QjtBQUVsRyxjQUFJLFNBQVMsT0FBTyxPQUFPLFVBQVUsVUFBVSxHQUFHO0FBRWxELGNBQUkseUJBQXlCLE1BQU07QUFDakMscUJBQVMsS0FBSyxJQUFJLHFCQUNkLEtBQUssTUFBTyxhQUFZLFVBQVUsd0JBQ2xDLEtBQUssSUFBSSxPQUFPLE9BQU8sVUFBVSxZQUFZLHVCQUF1QixZQUFZOztBQUl0RixnQkFBTSxTQUFTLE9BQU8sTUFBTSxvQkFBb0IsV0FBVyxNQUFNLGtCQUFrQjtBQUVuRixtQkFBUyxVQUFVLE1BQU0sUUFBUSxVQUFVLFFBQVEsV0FBVyxHQUFHO0FBQy9ELGtCQUFNLGNBQWMsS0FBSyxPQUFPLENBQUMsU0FBUztBQUMxQyxrQkFBTSxVQUFVLGlCQUFpQixNQUFNLFNBQVMsUUFBUSxhQUFhO0FBRXJFLGtCQUFNLEtBQUs7O0FBR2IsY0FBSSxNQUFNLFlBQVksU0FBUyxHQUFHO0FBQ2hDLGtCQUFNLE1BQU0sT0FBTyxPQUFPLEdBQUcsU0FBUztBQUV0QyxrQkFBTSxPQUFPLGlCQUFpQixNQUFNLFVBQVUsS0FBSyxPQUFPLENBQUMsU0FBUyxPQUFPOztBQUc3RSxjQUFJLE1BQU0sYUFBYTtBQUNyQixtQkFBTyxPQUFPLEtBQUssT0FBTyxDQUFDLFdBQVcsT0FBTyxPQUFPLFFBQVEsU0FBUzs7QUFHdkUsaUJBQU87O0FBR1QsWUFBTyxnQkFBUTs7OztBQzNIZixRQUFBLGlCQUFBLFlBQUE7O1lBQUEsU0FBQTtBQUNBLFlBQUEsTUFBQTtBQUVBLDRCQUFvQixPQUFPO0FBQ3pCLGNBQUksTUFBTSxPQUFPLE1BQU0sWUFBWSxjQUFjLElBQUksY0FBYyxNQUFNO0FBQ3pFLGNBQUksTUFBTSxPQUFPLE1BQU0sWUFBWSxjQUFjLElBQUksY0FBYyxNQUFNO0FBRXpFLGdCQUFNLGFBQWEsTUFBTTtBQUV6QixjQUFJLFlBQVk7QUFDZCxrQkFBTSxLQUFLLE1BQU0sTUFBTSxjQUFjO0FBQ3JDLGtCQUFNLEtBQUssS0FBSyxNQUFNLGNBQWM7O0FBR3RDLGNBQUksTUFBTSxvQkFBb0IsUUFBUSxNQUFNLFNBQVM7QUFDbkQsbUJBQU8sY0FBYzs7QUFHdkIsY0FBSSxNQUFNLG9CQUFvQixRQUFRLE1BQU0sU0FBUztBQUNuRCxtQkFBTyxjQUFjOztBQUd2QixjQUFJLE1BQU0sS0FBSztBQUNiLG1CQUFPOztBQUdULGNBQUksWUFBWTtBQUNkLGdCQUFJLE9BQU8sWUFBWSxRQUFRLFNBQVMsSUFBSTtBQUMxQyxrQkFBSSxPQUFPLE9BQU8sT0FBTyxLQUFLLE1BQU0sTUFBTSxhQUFhLEtBQUssTUFBTSxNQUFNLGVBQWU7QUFFdkYscUJBQU8sT0FBTyxLQUFLO0FBQ2pCLHdCQUFRLE1BQU07O0FBR2hCLHFCQUFPOztBQUdULGtCQUFNLFdBQVksT0FBTSxPQUFPO0FBRS9CLGdCQUFJO0FBQ0osZ0JBQUk7QUFFSixlQUFHO0FBQ0Qsb0JBQU0sT0FBTyxPQUFPLEdBQUcsWUFBWTtBQUNuQyxvQkFBTyxNQUFNLGFBQWM7cUJBQ3BCLFFBQVE7QUFJakIsbUJBQU8sTUFBTTs7QUFHZixpQkFBTyxPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVcsUUFBVzs7QUFHdkQsWUFBTyxpQkFBUTs7OztBQ3ZEZixRQUFBLGtCQUFBLFlBQUE7O1lBQUEsU0FBQTtBQU1BLDZCQUFxQixPQUFPO0FBQzFCLGlCQUFPLE9BQU8sZUFBQSxFQUFFLFlBQVksS0FBTTs7QUFHcEMsWUFBTyxrQkFBUTs7OztBQ1ZmLFFBQUEsZ0JBQUEsWUFBQTs7WUFBQSxTQUFBO0FBRUEsWUFBTSxlQUFlOzs7O1NBSVosTUFBTTtBQVFmLGdDQUF3QixRQUFRO0FBQzlCLGdCQUFNLFFBQVEsT0FBTyxRQUFRO0FBRTdCLGlCQUFPLE1BQU0sTUFBTSxHQUFHOztBQUd4QixZQUFPLGdCQUFROzs7O0FDcEJmLFFBQUEsaUJBQUEsWUFBQTs7WUFBQSxZQUFBO0FBQ0EsWUFBQSxTQUFBO0FBQ0EsWUFBQSxRQUFBO0FBQ0EsWUFBQSxRQUFBO0FBQ0EsWUFBQSxZQUFBO0FBR0EsWUFBTSxVQUFVLEVBQUUsTUFBTSxVQUFVO0FBR2xDLDRCQUFvQixPQUFPLE1BQU0sU0FBUyxrQkFBa0I7QUFDMUQsZ0JBQU0sUUFBUTtBQUVkLGdCQUFNLGFBQWEsTUFBTSxjQUFjO0FBQ3ZDLGdCQUFNLG9CQUFvQixNQUFNLHFCQUFxQjtBQUNyRCxnQkFBTSxxQkFBcUIsT0FBTyxNQUFNLGFBQWEsWUFBWSxLQUFNLE9BQU0sWUFBWSxJQUFJO0FBQzdGLGdCQUFNLG1CQUFtQixNQUFNLHlCQUF5QjtBQUV4RCxnQkFBTSxlQUFlLE9BQU8sS0FBSztBQUNqQyxnQkFBTSxzQkFBc0IsT0FBTyxLQUFLO0FBQ3hDLGdCQUFNLHFCQUFxQixhQUFhLE9BQU8scUJBQXFCLE9BQU8sQ0FBQyxXQUFXLFNBQVM7QUFDOUYsZ0JBQUksbUJBQW1CLFFBQVEsVUFBVTtBQUFJLHdCQUFVLEtBQUs7QUFDNUQsbUJBQU87YUFDTjtBQUNILGdCQUFNLGdCQUFnQixtQkFBbUIsT0FBTztBQUVoRCxnQkFBTSx1QkFBdUIsbUJBQ3hCLE1BQU0seUJBQXlCLE9BQU8sVUFBVSxNQUFNLHVCQUN2RCxNQUFNO0FBRVYsY0FBSSxDQUFDLG9CQUNBLGFBQWEsV0FBVyxLQUN4QixvQkFBb0IsV0FBVyxLQUMvQixNQUFNLGNBQWMsT0FBTyxpQkFBaUIsaUJBQWlCLGdCQUFnQixhQUNoRjtBQUVBLG1CQUFPOztBQUdULGNBQUksVUFBVSxvQkFBb0IsTUFBTTtBQUN0QywrQkFBbUIsUUFBUSxDQUFBLFFBQU87QUFDaEMsa0JBQUksV0FBVyxNQUFNO0FBQ25CLHNCQUFNLE9BQU8sV0FBVzs7O0FBSTVCLG1CQUFPLGlCQUFpQixPQUFPLEtBQUssT0FBTyxDQUFDLGdCQUFnQixTQUFTOztBQUd2RSxnQkFBTSx1QkFBdUIsVUFBVSwyQkFBMkIsT0FBTyxJQUFNLFVBQVU7QUFDekYsZ0JBQU0scUJBQXFCLFVBQVUsMEJBQTBCLFVBQVUseUJBQXlCO0FBQ2xHLGdCQUFNLG1CQUFtQixVQUFVLHVCQUF1QjtBQUMxRCxnQkFBTSxhQUFhLFVBQVU7QUFDN0IsZ0JBQU0sWUFBWSxVQUFVO0FBRTVCLGdCQUFNLE1BQU0sTUFBTSxpQkFBa0IsY0FBYyxTQUFVLG9CQUFtQixPQUFPLE9BQU8sR0FBRyxLQUFLO0FBRXJHLGNBQUksTUFBTSxLQUFLLElBQUksTUFBTSxpQkFBaUIsR0FBRyxtQkFBbUI7QUFDaEUsY0FBSSxlQUFlLEtBQUssSUFBSSxHQUFHLGNBQWMsU0FBUztBQUV0RCxjQUFJLGNBQWMsV0FBVyxLQUFLLENBQUMsbUJBQW1CLFFBQVE7QUFDNUQsa0JBQU0sS0FBSyxJQUFJLE9BQU8sT0FBTyxZQUFZLElBQUksR0FBRyxNQUFNOztBQUd4RCxjQUFJLHlCQUF5QixNQUFNO0FBQ2pDLGdCQUFJLHVCQUF1QixNQUFNO0FBQy9CLDZCQUFlLEtBQUssTUFBTyxNQUFNLG1CQUFtQixTQUFXLHVCQUF3QixlQUFjLFNBQVM7bUJBQ3pHO0FBQ0wsNkJBQWUsT0FBTyxPQUFPLE1BQU0sbUJBQW1CLFFBQVEsdUJBQXdCLGVBQWMsU0FBUzs7O0FBSWpILGdCQUFNLDZCQUE2QixPQUFPLFFBQVEsb0JBQW9CLE1BQU0sR0FBRztBQUMvRSxnQkFBTSxrQkFBa0IsbUJBQW1CLE9BQU8sQ0FBQSxVQUFTO0FBQ3pELG1CQUFPLDJCQUEyQixRQUFRLFdBQVc7O0FBSXZELGdCQUFNLFNBQVMseUJBQXlCLFFBQVEsbUJBQW1CLFdBQVcsTUFBTSxNQUFNLE9BQU8sT0FBTyxHQUFHO0FBQzNHLGdCQUFNLFNBQVMsbUJBQW1CLE9BQU8sT0FBTyxRQUFRLGlCQUFpQixNQUFNLEdBQUcsU0FBUyxNQUFNLEdBQUc7QUFDcEcsZ0JBQU0sU0FBUztBQUVmLGNBQUksTUFBTSxjQUFjO0FBQ3RCLG1CQUFPLEtBQUssTUFBTSxjQUFjLFFBQVEsQ0FBQSxTQUFRO0FBQzlDLG9CQUFNLFlBQVksTUFBTSxhQUFhO0FBRXJDLGtCQUFJLE9BQU8sUUFBUSxVQUFVLElBQUk7QUFDL0Isb0JBQUksTUFBTSxRQUFRLFlBQVk7QUFFNUIsNEJBQVUsUUFBUSxDQUFBLFFBQU87QUFDdkIsd0JBQUksT0FBTyxRQUFRLFNBQVMsSUFBSTtBQUM5Qiw2QkFBTyxLQUFLOzs7dUJBR1g7QUFDTCx5QkFBTyxLQUFLOzs7O0FBTWxCLGdCQUFJLE9BQU8sUUFBUTtBQUNqQixxQkFBTyxNQUFNO0FBRWIscUJBQU8saUJBQWlCO2dCQUN0QixPQUFPLE9BQU8sT0FBTztpQkFDcEIsS0FBSyxPQUFPLENBQUMsZ0JBQWdCLFNBQVM7OztBQUk3QyxnQkFBTSxVQUFVO0FBQ2hCLGdCQUFNLFVBQVU7QUFFaEIsaUJBQU8sUUFBUSxDQUFBLFFBQU87QUFDcEIscUJBQVMsSUFBSSxHQUFHLElBQUksaUJBQWlCLFFBQVEsS0FBSyxHQUFHO0FBQ25ELGtCQUFLLGlCQUFpQixjQUFjLFVBQVUsaUJBQWlCLEdBQUcsS0FBSyxRQUNqRSxPQUFPLGlCQUFpQixPQUFPLFlBQVksaUJBQWlCLE9BQU8sT0FDbkUsT0FBTyxpQkFBaUIsT0FBTyxjQUFjLGlCQUFpQixHQUFHLFdBQVcsTUFBTSxNQUFPO0FBQzdGLHdCQUFRLEtBQUs7QUFDYjs7O0FBSUosZ0JBQUkseUJBQXlCLE9BQU87QUFDbEMsa0JBQUksbUJBQW1CLFFBQVEsU0FBUyxJQUFJO0FBQzFDLHNCQUFNLE9BQU8sV0FBVzs7O0FBSTVCLGdCQUFJLFdBQVcsTUFBTTtBQUNuQixvQkFBTSxPQUFPLFdBQVc7O0FBRzFCLGdCQUFJO0FBR0osZ0NBQW9CLFFBQVEsQ0FBQSxTQUFRO0FBQ2xDLGtCQUFJLElBQUksTUFBTSxJQUFJLE9BQU8sUUFBUTtBQUMvQix3QkFBUTtBQUVSLG9CQUFJLE1BQU0sTUFBTTtBQUNkLHdCQUFNLE1BQU0sTUFBTSxNQUFNLGtCQUFrQjt1QkFDckM7QUFDTCx3QkFBTSxPQUFPLFFBQVEsUUFBUSxrQkFBa0I7Ozs7QUFLckQsZ0JBQUksQ0FBQyxPQUFPO0FBRVYsb0JBQU0sWUFBWSxrQkFBa0IsUUFBUTtBQUk1QyxrQkFBSSxhQUFhLHlCQUF5QixPQUFPO0FBRS9DLHNCQUFNLGtCQUFrQixPQUFPLE9BQU8sUUFBUSxPQUFPLE9BQU8sV0FBVyxRQUFRO3FCQUMxRTtBQUNMLHdCQUFRLEtBQUs7Ozs7QUFNbkIsY0FBSSxVQUFVLE9BQU8sS0FBSyxPQUFPLFNBQVUsYUFBWSxJQUFJLFFBQVE7QUFHbkUsZ0JBQU0sT0FBTyxDQUFBLFdBQVUsT0FBTyxRQUFRLG1CQUFtQixTQUFTLFNBQVM7QUFFM0UsdUJBQWEsTUFBTTtBQUNqQixnQkFBSTtBQUVKLGVBQUc7QUFDRCxrQkFBSSxDQUFDLEtBQUs7QUFBUTtBQUNsQixvQkFBTSxLQUFLO3FCQUNKLE1BQU07QUFFZixtQkFBTzs7QUFHVCxjQUFJLFdBQVc7QUFDZixjQUFJLG9CQUFvQixDQUFDLG1CQUFtQixRQUFRO0FBQ2xELHVCQUFXLEtBQUssSUFBSSx5QkFBeUIsUUFBUSx1QkFBdUIsT0FBTyxPQUFPLFlBQVksSUFBSSxHQUFHLE9BQU8sR0FBRzs7QUFHekgsaUJBQU8sV0FBVztBQUNoQixnQkFBSSxDQUFFLHFCQUFvQixVQUFVLG1CQUFtQjtBQUNyRDs7QUFHRixnQkFBSSxXQUFXLFVBQVU7QUFDdkI7O0FBR0YsZ0JBQUksa0JBQWtCO0FBQ3BCLGtCQUFJLGNBQWdCLGFBQWEsU0FBUyxVQUFXLFVBQVc7QUFDOUQsb0JBQUksUUFBUTtBQUNaLG9CQUFJO0FBRUosbUJBQUc7QUFDRCwyQkFBUztBQUdULHNCQUFJLFFBQVEsS0FBTTtBQUNoQjs7QUFHRix3QkFBTSxJQUFJLHVCQUF1QixPQUFPLEtBQUs7eUJBQ3RDLE9BQU8sTUFBTSxTQUFTO0FBRS9CLG9CQUFJLE9BQU8sTUFBTSxTQUFTLGFBQWE7QUFDckMsd0JBQU0sT0FBTyxXQUFXO0FBQ3hCLDZCQUFXOzt5QkFFSixvQkFBb0IsVUFBVSxDQUFDLHNCQUFzQjtBQUM5RCxzQkFBTSxPQUFPLE9BQU8sS0FBSztBQUN6QixzQkFBTSxPQUFPLE9BQU8sUUFBUTtBQUU1QixvQkFBSSxDQUFDLE1BQU0sT0FBTztBQUNoQix3QkFBTSxRQUFRLGtCQUFrQjtBQUNoQyw2QkFBVzs7cUJBRVI7QUFDTCxzQkFBTSxPQUFPLElBQUksdUJBQXdCLE1BQU0sS0FBSztBQUVwRCxvQkFBSSxDQUFDLE1BQU0sT0FBTztBQUNoQix3QkFBTSxRQUFRLHdCQUF3QjtBQUN0Qyw2QkFBVzs7OztBQUtqQixxQkFBUyxJQUFJLEdBQUcsVUFBVSxPQUFPLElBQUksb0JBQW9CLFFBQVEsS0FBSyxHQUFHO0FBQ3ZFLG9CQUFNLE9BQU8sb0JBQW9CO0FBQ2pDLG9CQUFNLE9BQU8sT0FBTyxRQUFRO0FBRzVCLGtCQUFJLENBQUMsTUFBTSxPQUFPO0FBQ2hCLHNCQUFNLFFBQVEsa0JBQWtCO0FBQ2hDLDJCQUFXOzs7O0FBTWpCLGNBQUksbUJBQW1CLFdBQVcsS0FBTSxFQUFDLG9CQUFvQix5QkFBeUIsUUFBUTtBQUM1RixrQkFBTSxVQUFVLE9BQU8sT0FBTyxLQUFLO0FBRW5DLG1CQUFPLFVBQVUsV0FBVTtBQUN6QixvQkFBTSxPQUFPLElBQUk7QUFFakIsa0JBQUksTUFBTTtBQUNSLHNCQUFNLFFBQVEsV0FBVzs7QUFHM0IseUJBQVc7OztBQUlmLGlCQUFPLGlCQUFpQixPQUFPLEtBQUssT0FBTyxDQUFDLGdCQUFnQixTQUFTOztBQUd2RSxZQUFPLGlCQUFROzs7O0FDdFFmLFFBQUEsZ0JBQUEsWUFBQTs7WUFBQSxRQUFBO0FBQ0EsWUFBQSxTQUFBO0FBT0EsMkJBQW1CO0FBQ2pCLGdCQUFNLFNBQVMsT0FBTyxPQUFPLEdBQUc7QUFFaEMsaUJBQU8sTUFBTSxRQUFRLEtBQUs7O0FBUTVCLGdDQUF3QixNQUFNLEdBQUcsTUFBTSxLQUFLO0FBQzFDLGdCQUFNLE9BQU8sS0FBSyxJQUFJLEdBQUc7QUFDekIsZ0JBQU0sT0FBTyxPQUFPLE9BQU8sTUFBTTtBQUVqQyxjQUFJLFNBQVM7QUFHYixpQkFBTyxPQUFPLFNBQVMsTUFBTTtBQUMzQixzQkFBVTs7QUFJWixjQUFJLE9BQU8sU0FBUyxNQUFNO0FBQ3hCLHFCQUFTLE9BQU8sT0FBTyxHQUFHOztBQUc1QixpQkFBTzs7QUFHVCxZQUFPLGdCQUFROzs7O0FDdENmLFFBQUEsZUFBQSxZQUFBOztZQUFBLFNBQUE7QUFPQSxpQ0FBeUI7QUFDdkIsaUJBQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksTUFBTTtBQUM1QixtQkFBTyxPQUFPLE9BQU8sR0FBRzthQUN2QixLQUFLOztBQUdWLFlBQU8sZUFBUTs7OztBQ2JmLFFBQUEsbUJBQUEsWUFBQTs7WUFBQSxTQUFBO0FBT0EscUNBQTZCO0FBQzNCLGlCQUFPLE9BQU8sT0FBTzs7QUFHdkIsWUFBTyxtQkFBUTs7OztBQ1hmLFFBQUEsZUFBQSxZQUFBOztZQUFBLG9CQUFBO0FBT0EsaUNBQXlCO0FBQ3ZCLGlCQUFPLG9CQUFvQixNQUFNLEdBQUc7O0FBR3RDLFlBQU8sZUFBUTs7OztBQ1hmLFFBQUEsZUFBQSxZQUFBOztZQUFBLG9CQUFBO0FBT0EsaUNBQXlCO0FBQ3ZCLGlCQUFPLG9CQUFvQixNQUFNOztBQUduQyxZQUFPLGVBQVE7Ozs7QUNYZixRQUFBLHFCQUFBLFlBQUE7O1lBQUEsU0FBQTtBQUVBLFlBQU0sV0FBVztBQUNqQixZQUFNLGNBQWMseUJBQXlCO0FBQzdDLFlBQU0sZ0JBQWdCO0FBTXRCLFlBQU0sVUFBVTtVQUNkLE9BQU87VUFDUCxVQUFVO1VBQ1YsTUFBTTtVQUNOLEtBQUs7VUFDTCxNQUFNO1VBR04saUJBQWlCLEdBQUcsY0FBYztVQUNsQyxnQkFBZ0IsWUFBWSxRQUFRLE9BQU87VUFDM0MsZ0JBQWdCLFFBQVEsU0FBUyxRQUFRLE1BQU07VUFHL0MsTUFBTTs7QUFHUixnQkFBUSxNQUFNLFFBQVE7QUFDdEIsZ0JBQVEsbUJBQW1CLFFBQVE7QUFFbkMsZ0JBQVEsZUFBZSxRQUFRO0FBQy9CLGdCQUFRLGtCQUFrQixRQUFRO0FBRWxDLFlBQU0sa0JBQWtCLElBQUksT0FBTyxPQUFPLE9BQU8sS0FBSyxTQUFTLEtBQUs7QUFRcEUscUNBQTZCLFlBQVk7QUFDdkMsaUJBQU8sT0FBTyxRQUFRLFFBQVEsYUFBYSxRQUFRLGlCQUFpQixDQUFDLE9BQU8sUUFBUTtBQUNsRixtQkFBTyxPQUFPLFFBQVEsUUFBUTs7O0FBSWxDLFlBQU8scUJBQVE7Ozs7QUM5Q2YsUUFBQSxpQkFBQSxZQUFBOztZQUFBLFFBQUE7QUFDQSxZQUFBLE9BQUE7QUFDQSxZQUFBLFdBQUE7QUFDQSxZQUFBLE9BQUE7QUFDQSxZQUFBLE9BQUE7QUFDQSxZQUFBLGFBQUE7QUFDQSxZQUFBLFlBQUE7QUFDQSxZQUFBLFNBQUE7QUFDQSxZQUFBLFNBQUE7QUFDQSxZQUFBLFFBQUE7QUFFQSxnQ0FBd0IsT0FBTyxTQUFTO0FBQ3RDLGdCQUFNLFdBQVcsT0FBTyxNQUFNO0FBRTlCLGNBQUksT0FBTyxhQUFhLFlBQVk7QUFDbEMsbUJBQU8sU0FBUzs7QUFHbEIsa0JBQVEsTUFBTTtpQkFDUDtpQkFDQTtBQUNILHFCQUFPO2lCQUNKO0FBQ0gscUJBQU87aUJBQ0o7QUFDSCxxQkFBTztpQkFDSjtBQUNILHFCQUFPO2lCQUNKO0FBRUgscUJBQU87aUJBQ0o7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7QUFDSCxxQkFBTyxXQUFXLE1BQU07O0FBRXhCLGtCQUFJLE9BQU8sYUFBYSxhQUFhO0FBQ25DLG9CQUFJLFVBQVUsd0JBQXdCO0FBQ3BDLHdCQUFNLElBQUksTUFBTSx3QkFBd0IsTUFBTSxNQUFNLE1BQU07dUJBQ3JEO0FBQ0wseUJBQU87OztBQUlYLG9CQUFNLElBQUksTUFBTSx1QkFBdUIsTUFBTTs7O0FBSW5ELDRCQUFvQixPQUFPO0FBRXpCLGdCQUFNLFNBQVMsTUFBTSxTQUFTLFVBQVUsT0FBTyxDQUFBLFNBQVE7QUFDckQsZ0JBQUksTUFBTSxRQUFRO0FBQ2hCLHFCQUFPLGVBQWUsT0FBTyxNQUFNLE1BQU0sS0FBSyxXQUFXLEtBQUs7O0FBR2hFLGdCQUFJLE1BQU0sU0FBUztBQUNqQixxQkFBTyxPQUFPLFFBQVEsTUFBTTs7QUFHOUIsbUJBQU8sTUFBTSxLQUFLLFdBQVcsS0FBSzs7QUFHcEMsaUJBQU87O0FBR1QsWUFBTyxpQkFBUTs7OztBQzNFZixRQUFBLGlCQUFBLFlBQUE7O1lBQUEsV0FBQTtBQUNBLFlBQUEsUUFBQTtBQUNBLFlBQUEsU0FBQTtBQUNBLFlBQUEsV0FBQTtBQUNBLFlBQUEsVUFBQTtBQUNBLFlBQUEsVUFBQTtBQUNBLFlBQUEsVUFBQTtBQUVBLFlBQU0sVUFBVTtVQUNkLFNBQVM7VUFDVCxNQUFNO1VBQ04sT0FBTztVQUNQLFNBQVM7VUFDVCxRQUFRO1VBQ1IsUUFBUTtVQUNSLFFBQVE7O0FBR1YsWUFBTyxnQkFBUTs7OztBQ2xCZixRQUFBLG1CQUFBLFlBQUE7O1lBQUEsUUFBQTtBQUNBLFlBQUEsU0FBQTtBQUNBLFlBQUEsYUFBQTtBQUNBLFlBQUEsWUFBQTtBQUNBLFlBQUEsUUFBQTtBQUNBLFlBQUEsWUFBQTtBQUVBLHlCQUFpQixFQUFFLFVBQVUsU0FBUyxPQUFPLGVBQWU7QUFDMUQsaUJBQU8sT0FBTyxRQUFRLEVBQUUsU0FBUyxPQUFPLGVBQ25DLE9BQU8sQ0FBQyxDQUFDLEVBQUUsV0FBVyxPQUN0QixPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsT0FBTztBQUN4QixpQkFBSyxLQUFLO0FBQ1YsbUJBQU87YUFDTjs7QUFJVCwwQkFBa0IsUUFBUSxNQUFNLFNBQVMsWUFBWTtBQUNuRCxtQkFBUyxRQUFRLFFBQVEsTUFBTTtBQUUvQixjQUFJLFVBQVcsUUFBTyxTQUFTLE9BQU8sU0FBUyxPQUFPLFFBQVE7QUFDNUQscUJBQVMsUUFBUSxRQUFRLE1BQU07O0FBR2pDLGNBQUksQ0FBQyxRQUFRO0FBQ1g7O0FBR0YsZ0JBQU0sVUFBVSxRQUFRO0FBR3hCLGNBQUksS0FBSyxLQUFLLFNBQVMsT0FBTyxjQUFjO0FBRTFDLGdCQUFJLFVBQVUsdUJBQXVCLE1BQU0sUUFBUSxPQUFPLFdBQVc7QUFFbkUsb0JBQU0sZ0JBQWdCLE9BQU8sU0FDMUIsT0FBTyxhQUFhLFNBQVMsQ0FBQyxPQUFPLFdBQVc7QUFFbkQscUJBQU8sRUFBRSxPQUFPLE1BQU0sU0FBUyxNQUFNLFFBQVEsTUFBTSxPQUFPLEtBQUssaUJBQWlCOztBQUdsRixnQkFBSSxVQUFVLHNCQUFzQixhQUFhLFFBQVE7QUFDdkQsa0JBQUksT0FBTyxZQUFZLE1BQU0sQ0FBQyxVQUFVLDhCQUE4QjtBQUNwRSx1QkFBTyxFQUFFLE9BQU8sT0FBTyxTQUFTOzs7QUFJcEMsZ0JBQUksY0FBYyxRQUFRO0FBQ3hCLHFCQUFPLEVBQUUsT0FBTyxNQUFNLFNBQVMsT0FBTyxVQUFVLGFBQWE7O0FBRy9ELGdCQUFJLFdBQVcsUUFBUTtBQUNyQixxQkFBTyxFQUFFLE9BQU8sT0FBTyxPQUFPOzs7QUFJbEMsY0FBSSxPQUFPLE9BQU8sT0FBTyxPQUFPLFFBQVEsVUFBVTtBQUNoRCxxQkFBUyxNQUFNLFNBQVMsT0FBTyxLQUFLLE1BQU0sVUFBVSxRQUFRLENBQUM7QUFHN0QsZ0JBQUksT0FBTyxRQUFRLE9BQU8sU0FBUyxVQUFVO0FBQzNDLG9CQUFNLEVBQUUsT0FBTyxTQUFTLGlCQUFpQixTQUFTLFFBQVEsS0FBSyxPQUFPLENBQUMsU0FBUyxTQUFTO0FBQ3pGLHFCQUFPLEVBQUUsT0FBTyxNQUFNLE1BQU0sT0FBTyxRQUFRLFFBQVEsU0FBUyxjQUFBLGVBQUEsSUFBSyxVQUFMLEVBQWMsT0FBTzs7O0FBS3JGLGNBQUksT0FBTyxPQUFPLFVBQVUsWUFBWTtBQUV0QyxrQkFBTSxFQUFFLE9BQU8sU0FBUyxpQkFBaUIsU0FBUyxPQUFPLE1BQU0sYUFBYSxNQUFNO0FBQ2xGLG1CQUFPLEVBQUUsT0FBTyxTQUFTLGNBQUEsZUFBQSxJQUFLLFVBQUwsRUFBYyxPQUFPOztBQUdoRCxjQUFJLE9BQU8sT0FBTyxhQUFhLFlBQVk7QUFDekMsa0JBQU0sU0FBUyxNQUFNLFNBQVMsTUFBTSxRQUFRLE1BQU0sT0FBTyxTQUFTLFlBQVk7QUFDOUUsa0JBQU0sUUFBTyxXQUFXLE9BQU8sU0FBUyxPQUFPO0FBQy9DLGdCQUFJLFVBQVMsT0FBTyxRQUNkLE1BQU0sUUFBUSxPQUFPLFNBQVMsT0FBTyxLQUFLLFNBQVMsVUFDbkQsVUFBUyxZQUFZLE9BQU8sU0FBUyxhQUNyQyxNQUFNLFFBQVEsV0FBVyxPQUFPLFNBQVMsU0FBVTtBQUN2RCxxQkFBTyxFQUFFLE9BQU8sUUFBUTs7O0FBSTVCLGNBQUksT0FBTyxPQUFPLFlBQVksVUFBVTtBQUN0QyxtQkFBTyxFQUFFLE9BQU8sTUFBTSxTQUFTLFVBQVUsUUFBUSxNQUFNLE9BQU8sUUFBUSxPQUFPLFdBQVc7O0FBRzFGLGNBQUksTUFBTSxRQUFRLE9BQU8sT0FBTztBQUM5QixtQkFBTyxFQUFFLE9BQU8sTUFBTSxTQUFTLE1BQU0sUUFBUSxNQUFNLE9BQU8sS0FBSyxPQUFPLFFBQVE7O0FBSWhGLGNBQUksT0FBTyxVQUFVO0FBQ25CLG1CQUFPLEVBQUUsT0FBTyxRQUFROztBQUkxQixjQUFJLE9BQU8sT0FBTztBQUVsQixjQUFJLE1BQU0sUUFBUSxPQUFPO0FBQ3ZCLG1CQUFPLE9BQU8sS0FBSztxQkFDVixPQUFPLFNBQVMsYUFBYTtBQUV0QyxtQkFBTyxVQUFVLFFBQVEsU0FBUztBQUVsQyxnQkFBSSxNQUFNO0FBQ1IscUJBQU8sT0FBTzs7O0FBSWxCLGNBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsZ0JBQUksQ0FBQyxNQUFNLE9BQU87QUFDaEIsa0JBQUksVUFBVSx1QkFBdUI7QUFDbkMsc0JBQU0sSUFBSSxXQUFXLHFCQUFxQixNQUFNLE1BQU0sU0FBUyxLQUFLLE9BQU8sQ0FBQztxQkFDdkU7QUFDTCxzQkFBTSxRQUFRLFVBQVU7QUFFeEIsb0JBQUksT0FBTyxVQUFVLFlBQVksTUFBTSxRQUFRO0FBQzdDLHlCQUFPLEVBQUUsT0FBTyxNQUFNLE9BQU8sUUFBUSxNQUFNLFNBQVMsV0FBVzs7QUFHakUsdUJBQU8sRUFBRSxPQUFPOzttQkFFYjtBQUNMLGtCQUFJO0FBQ0Ysc0JBQU0sY0FBYyxNQUFNLE1BQU0sUUFBUSxNQUFNLFNBQVM7QUFDdkQsb0JBQUksU0FBUyxTQUFTO0FBQ3BCLHlCQUFPO29CQUNMLE9BQU8sWUFBWSxJQUFJLENBQUMsRUFBRSxZQUFZO29CQUN0QyxTQUFTLGNBQUEsZUFBQSxJQUNKLFVBREk7c0JBRVAsT0FBTyxZQUFZLElBQUksQ0FBQyxFQUFFLFNBQVMsUUFBUTs7OztBQUcvQyxvQkFBSSxTQUFTLFVBQVU7QUFDdkIseUJBQU8sRUFBRSxPQUFPLFlBQVksT0FBTyxTQUFTLGNBQUEsZUFBQSxJQUFLLFVBQUwsRUFBYyxPQUFPLFlBQVk7O0FBRS9FLHVCQUFPLEVBQUUsT0FBTyxhQUFhO3VCQUN0QjtBQUNQLG9CQUFJLE9BQU8sRUFBRSxTQUFTLGFBQWE7QUFDakMsd0JBQU0sSUFBSSxXQUFXLEVBQUUsT0FBTzs7QUFFaEMsc0JBQU07Ozs7QUFLWixjQUFJLFlBQVk7QUFDaEIsY0FBSSxjQUFjLGVBQUEsSUFBSztBQUV2QixjQUFJLE1BQU0sUUFBUSxTQUFTO0FBQ3pCLHdCQUFZOztBQUdkLGlCQUFPLEtBQUssUUFBUSxRQUFRLENBQUEsU0FBUTtBQUNsQyxnQkFBSSxPQUFPLE9BQU8sVUFBVSxZQUFZLFNBQVMsZUFBZTtBQUM5RCxvQkFBTSxFQUFFLE9BQU8sU0FBUyxpQkFBaUIsU0FBUyxPQUFPLE9BQU8sS0FBSyxPQUFPLENBQUMsUUFBUSxTQUFTO0FBQzlGLHdCQUFVLFFBQVEsTUFBTSxNQUFNLE9BQU8sT0FBTyxPQUFPO0FBQ25ELDBCQUFZLFFBQVE7bUJBQ2Y7QUFDTCx3QkFBVSxRQUFRLE9BQU87OztBQUk3QixpQkFBTyxFQUFFLE9BQU8sV0FBVyxTQUFTOztBQUd0QyxZQUFPLG1CQUFROzs7O0FDeEtmLFFBQUEsNkJBQUEsWUFBQTs7WUFBQSxZQUFBO0FBQ0EsWUFBQSxTQUFBO0FBQ0EsWUFBQSxRQUFBO0FBRUEsWUFBTSxxQkFBcUIsQ0FBQztVQUMxQjtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7Y0FDSTtBQUNKLGdCQUFNLGdCQUFnQjtBQUN0QixnQkFBTSxXQUFXO0FBRWpCLGNBQUksUUFBUTtBQUNaLGNBQUk7QUFDSixjQUFJO0FBRUosd0JBQWMsZ0JBQWdCLENBQUMsS0FBSyxPQUFPLGFBQWE7QUFFdEQsZ0JBQUksUUFBUSxRQUFRLFFBQVEsUUFBVztBQUNyQyxxQkFBTzs7QUFHVCxnQkFBSSxPQUFPLElBQUksYUFBYSxZQUFZO0FBQ3RDLHFCQUFPOztBQUlULGtCQUFNLE1BQU0sSUFBSSxPQUFPLElBQUk7QUFFM0IsZ0JBQUksT0FBTyxRQUFRLFVBQVU7QUFDM0IscUJBQU8sSUFBSTtBQUNYLHFCQUFPLElBQUk7QUFDWCxxQkFBTyxJQUFJOztBQUdiLGdCQUFJLE9BQU8sSUFBSSxTQUFTLFVBQVU7QUFDaEMsb0JBQU0sV0FBVyxLQUFLLElBQUksYUFBYSxlQUFlO0FBR3RELGtCQUFJLElBQUksU0FBUyxPQUFPLFNBQVMsSUFBSSxRQUFRLEtBQU0sWUFBWSxJQUFJLFFBQVEsRUFBRSxRQUFRLFVBQVc7QUFDOUYsb0JBQUksSUFBSSxTQUFTLE9BQU8sWUFBWSxTQUFTLFdBQVcsU0FBUyxRQUFRO0FBQ3ZFLHlCQUFPLE1BQU0sWUFBWSxRQUFRLElBQUksTUFBTSxlQUFlOztBQUU1RCx1QkFBTyxJQUFJO0FBQ1gsdUJBQU87O0FBR1Qsa0JBQUksT0FBTyxTQUFTLElBQUksVUFBVSxhQUFhO0FBQzdDLHlCQUFTLElBQUksUUFBUSxPQUFPLE9BQU8sYUFBYSxlQUFlOztBQUdqRSx5QkFBVztBQUNYLHdCQUFVLElBQUk7QUFFZCxrQkFBSTtBQUVKLGtCQUFJLElBQUksS0FBSyxRQUFRLFVBQVUsSUFBSTtBQUNqQyxzQkFBTSxLQUFLLElBQUksU0FBUztxQkFDbkI7QUFDTCxzQkFBTSxNQUFNLFlBQVksUUFBUSxJQUFJLE1BQU0sZUFBZSxTQUFTOztBQUdwRSxrQkFBSSxPQUFPLFFBQVEsYUFBYTtBQUM5QixvQkFBSSxDQUFDLE9BQU8sVUFBVSx5QkFBeUIsTUFBTTtBQUNuRCx3QkFBTSxJQUFJLE1BQU0sd0JBQXdCLElBQUk7O0FBRzlDLHlCQUFTLElBQUksU0FBUztBQUN0QixzQkFBTSxNQUFNLEtBQUssT0FBTzs7QUFJMUIscUJBQU8sSUFBSTtBQUNYLHFCQUFPOztBQUdULGdCQUFJLE1BQU0sUUFBUSxJQUFJLFFBQVE7QUFDNUIsb0JBQU0sVUFBVSxJQUFJO0FBRXBCLHFCQUFPLElBQUk7QUFJWCxzQkFBUSxRQUFRLENBQUEsY0FBYTtBQUMzQixzQkFBTSxPQUFPLGNBQWMsY0FBYyxXQUFXLE1BQU07QUFHMUQsc0JBQU0sTUFBTSxLQUFLLE9BQU8sS0FBSyxVQUFVLGFBQ25DLEtBQUssTUFBTSxPQUNYO0FBQ0osb0JBQUksTUFBTSxRQUFRLElBQUksUUFBUTtBQUM1QixnQ0FBYyxjQUFjLEtBQUssT0FBTzs7OztBQUs5QyxnQkFBSSxNQUFNLFFBQVEsSUFBSSxTQUFTLElBQUksUUFBUTtBQUN6QyxvQkFBTSxNQUFNLElBQUksU0FBUyxJQUFJO0FBSTdCLGtCQUFJLElBQUksUUFBUSxJQUFJLE9BQU87QUFDekIsb0JBQUksT0FBTyxJQUFJLEtBQUssT0FBTyxDQUFBLE1BQUssTUFBTSxTQUFTLEdBQUc7O0FBR3BELHFCQUFPO2dCQUNMLE1BQU0sWUFBWTtBQUNoQix3QkFBTSxPQUFPLE1BQU0sVUFBVSxLQUFLLENBQUMsU0FBUztBQUM1Qyx3QkFBTSxRQUFRLE9BQU8sS0FBSztBQUUxQix3QkFBTSxNQUFNLE1BQU07QUFHbEIsc0JBQUksUUFBUSxDQUFBLFNBQVE7QUFDbEIsd0JBQUksS0FBSyxZQUFZLFNBQVMsT0FBTztBQUNuQywyQkFBSyxTQUFTLFFBQVEsQ0FBQSxRQUFPO0FBQzNCLDhCQUFNLGNBQWMsS0FBSyxZQUFZLEtBQUssU0FBUyxTQUFTO0FBQzVELDRCQUFJLEtBQUssY0FBYyxDQUFDLGFBQWE7QUFDbkMsaUNBQU8sS0FBSyxXQUFXOztBQUd6Qiw0QkFBSSxjQUFjLFdBQVcsWUFBWTtBQUN2QyxpQ0FBTyxXQUFXLFdBQVc7Ozs7O0FBTXJDLHlCQUFPOzs7O0FBS2IsbUJBQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQSxTQUFRO0FBQy9CLGtCQUFLLE9BQU0sUUFBUSxJQUFJLFVBQVUsT0FBTyxJQUFJLFVBQVUsYUFBYSxDQUFDLE1BQU0sTUFBTSxPQUFPO0FBQ3JGLG9CQUFJLFFBQVEsY0FBYyxjQUFjLElBQUksT0FBTyxNQUFNLFNBQVMsT0FBTzs7O0FBSzdFLGdCQUFJLFVBQVU7QUFDWixvQkFBTSxXQUFXLFNBQVMsU0FBUyxTQUFTO0FBRTVDLGtCQUFJLGFBQWEsZ0JBQWdCLGFBQWEsU0FBUztBQUNyRCx1QkFBTzs7O0FBSVgsbUJBQU8sVUFBVSxLQUFLOztBQUd4QixpQkFBTzs7QUFHVCxZQUFPLDZCQUFROzs7O0FDN0pmLFFBQUEsY0FBQSxZQUFBOztZQUFBLEVBQUEsb0JBQUE7QUFDQSxZQUFBLFlBQUE7QUFDQSxZQUFBLFdBQUE7QUFDQSxZQUFBLFNBQUE7QUFDQSxZQUFBLFFBQUE7QUFDQSxZQUFBLHFCQUFBO0FBRUEsc0JBQWMsTUFBTTtBQUNsQixpQkFBTyxNQUFNLFFBQVEsUUFDakIsT0FBTyxLQUFLLFFBQ1o7O0FBR04sdUJBQWUsTUFBTSxTQUFTO0FBQzVCLGNBQUksQ0FBQyxNQUFNLFFBQVEsT0FBTztBQUN4QixtQkFBTzs7QUFHVCxnQkFBTSxRQUFRLFVBQ1YsS0FBSyxRQUNMLEtBQUs7QUFFVCxjQUFJLFNBQVM7QUFDWCxpQkFBSyxRQUFRO2lCQUNSO0FBQ0wsaUJBQUssS0FBSzs7QUFHWixpQkFBTzs7QUFHVCx5QkFBaUIsS0FBSyxNQUFNLFFBQVEsVUFBVTtBQUM1QyxjQUFJLENBQUMsT0FBTyxPQUFPLFFBQVEsVUFBVTtBQUNuQyxtQkFBTzs7QUFHVCxjQUFJLENBQUMsUUFBUTtBQUNYLHFCQUFTOztBQUdYLGNBQUksQ0FBQyxNQUFNO0FBQ1QsbUJBQU87O0FBR1QsY0FBSSxNQUFNLFFBQVEsTUFBTTtBQUN0QixtQkFBTyxJQUFJLElBQUksQ0FBQSxNQUFLLFFBQVEsR0FBRyxNQUFNLFFBQVE7O0FBRy9DLGNBQUksSUFBSSxVQUFVO0FBQ2hCLGtCQUFNLEVBQUUsVUFBQSxjQUFhO0FBRXJCLGtCQUFNLFNBQVMsT0FBTyxJQUFJLGFBQWEsV0FDbkMsRUFBRSxNQUFNLElBQUksYUFDWixJQUFJO0FBRVIsbUJBQU8sUUFBUSxJQUFJLFNBQVMsT0FBTyxTQUFTO0FBQzVDLG1CQUFPLFFBQVEsSUFBSSxTQUFTLE9BQU8sU0FBUztBQUM1QyxtQkFBTyxVQUFVLElBQUksV0FBVyxPQUFPLFdBQVc7QUFDbEQsbUJBQU8sUUFBUSxJQUFJLFNBQVMsT0FBTyxTQUFTO0FBRTVDLGtCQUFNLE1BQU0sR0FBRyxPQUFPLFVBQVUsT0FBTztBQUV2QyxnQkFBSSxDQUFDLE9BQU8sTUFBTTtBQUNoQixrQkFBSSxPQUFPLFFBQVEsR0FBRztBQUNwQix1QkFBTyxPQUFPLFVBQVMsT0FBTyxNQUFNLE1BQU0sTUFBTSxHQUFHLE9BQU87cUJBQ3JEO0FBQ0wsdUJBQU8sT0FBTyxVQUFTLE9BQU8sTUFBTTs7O0FBSXhDLGdCQUFJLE9BQU8sU0FBUyxPQUFPLFNBQVM7QUFDbEMscUJBQU8sTUFBTSxPQUFPLE1BQU0sT0FBTzs7QUFHbkMsbUJBQU8sS0FBSyxPQUFPOztBQUdyQixpQkFBTyxLQUFLLEtBQUssUUFBUSxDQUFBLE1BQUs7QUFDNUIsZ0JBQUksS0FBSyxRQUFRLElBQUksSUFBSSxNQUFNLFFBQVE7O0FBR3pDLGlCQUFPOztBQUlULHFCQUFhLE1BQU0sUUFBUSxXQUFXLGFBQWE7QUFDakQsY0FBSSxPQUFPLFVBQVUsU0FBUyxLQUFLLFlBQVksbUJBQW1CO0FBQ2hFLGtCQUFNLElBQUksTUFBTSw2Q0FBNkMsT0FBTzs7QUFHdEUsZ0JBQU0sY0FBYyxVQUFVLGtCQUFrQjtBQUNoRCxnQkFBTSxjQUFjLFVBQVUsa0JBQWtCO0FBRWhELGNBQUk7QUFDRixrQkFBTSxFQUFFLGtCQUFrQixtQkFBbUI7Y0FDM0M7Y0FDQTtjQUNBO2NBQ0E7Y0FDQTtjQUNBOztBQUVGLGtCQUFNLFNBQVMsU0FBUyxNQUFNLE1BQU0sU0FBUyxJQUFJO0FBRWpELGdCQUFJLFVBQVUsb0JBQW9CO0FBQ2hDLHFCQUFPO2dCQUNMLE9BQU8sUUFBUSxPQUFPO2dCQUN0QixTQUFTLE9BQU87OztBQUlwQixtQkFBTzttQkFDQTtBQUNQLGdCQUFJLEVBQUUsTUFBTTtBQUNWLG9CQUFNLElBQUksTUFBTSxHQUFHLEVBQUUsZUFBZSxFQUFFLEtBQUssS0FBSzttQkFDM0M7QUFDTCxvQkFBTTs7OztBQUtaLFlBQU8sY0FBUTs7OztBQ3pIZixRQUFBLGFBQUEsWUFBQTs7MEJBQWtCLEtBQUs7QUFDckIsaUJBQU8sSUFBSTs7QUFHYixZQUFPLGFBQVE7Ozs7QUNKZixRQUFBLDhCQUFBLFlBQUE7TUFBQSxnREFBQSxVQUFBO0FBQUE7QUFFQSxZQUFNLE9BQU87VUFDWCxRQUFRO1VBQ1IsU0FBUztVQUNULEtBQUs7VUFDTCxnQkFBZ0I7VUFDaEIsY0FBYzs7QUFFaEIsWUFBTSxPQUFPO1VBQ1gsT0FBTztVQUNQLFlBQVk7VUFDWixjQUFjO1VBQ2QsZUFBZTtVQUNmLFNBQVM7VUFDVCxXQUFXO1VBQ1gsVUFBVTtVQUNWLFVBQVU7VUFDVixVQUFVO1VBQ1YsS0FBSztVQUNMLFNBQVM7VUFDVCxXQUFXO1VBQ1gsT0FBTztVQUNQLGNBQWM7VUFDZCxjQUFjO1VBQ2QsS0FBSztVQUNMLFVBQVU7O0FBRVosWUFBTSxtQkFBbUI7QUFDekIsWUFBTSxjQUFjO1VBQ2xCLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSzs7QUFHUCxnQ0FBd0IsS0FBSztBQUMzQixnQkFBTSxLQUFLLENBQUM7QUFDWixjQUFJLFNBQVMsSUFBSSxRQUFRO0FBRXpCLGlCQUFPLFdBQVcsSUFBSTtBQUNwQixzQkFBVTtBQUNWLGVBQUcsS0FBSztBQUNSLHFCQUFTLElBQUksUUFBUSxNQUFNOztBQUc3QixpQkFBTzs7QUFHVCw0QkFBb0IsS0FBSztBQUN2QixjQUFJLFlBQVk7QUFFaEIsY0FBSSxPQUFPLFFBQVEsVUFBVTtBQUMzQix5QkFBYSxlQUFlO0FBQzVCLGtCQUFNO2lCQUNEO0FBQ0wsZ0JBQUksTUFBTSxRQUFRO0FBQU0sb0JBQU0sSUFBSTtBQUVsQyxnQkFBSSxPQUFPLElBQUksU0FBUztBQUN0QixrQkFBSSxDQUFDLElBQUk7QUFBWSxvQkFBSSxhQUFhLGVBQWUsSUFBSSxRQUFRO0FBQ2pFLDJCQUFhLElBQUk7QUFDakIsb0JBQU0sSUFBSSxRQUFROzs7QUFJdEIsaUJBQU87WUFDTDtZQUNBOzs7QUF5QkosNEJBQW9CLFFBQVEsS0FBSztBQUMvQixjQUFJLE9BQU8sV0FBVyxZQUFZLFNBQVM7QUFBRyxtQkFBTztBQUNyRCxnQkFBTTtZQUNKO1lBQ0E7Y0FDRSxXQUFXO0FBQ2YsY0FBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLFNBQVMsSUFBSTtBQUFRLG1CQUFPO0FBRXZELG1CQUFTLElBQUksR0FBRyxJQUFJLFdBQVcsUUFBUSxFQUFFLEdBQUc7QUFDMUMsa0JBQU0sUUFBUSxXQUFXO0FBRXpCLGdCQUFJLFNBQVMsT0FBTztBQUNsQixxQkFBTztnQkFDTCxNQUFNO2dCQUNOLEtBQUssU0FBUyxXQUFXLElBQUksS0FBSzs7O0FBSXRDLGdCQUFJLFdBQVc7QUFBTyxxQkFBTztnQkFDM0IsTUFBTSxJQUFJO2dCQUNWLEtBQUs7OztBQUlULGdCQUFNLE9BQU8sV0FBVztBQUN4QixpQkFBTztZQUNMO1lBQ0EsS0FBSyxTQUFTLFdBQVcsT0FBTyxLQUFLOzs7QUFpQnpDLHlCQUFpQixNQUFNLEtBQUs7QUFDMUIsZ0JBQU07WUFDSjtZQUNBO2NBQ0UsV0FBVztBQUNmLGNBQUksQ0FBQyxjQUFjLENBQUUsU0FBUSxNQUFNLE9BQU8sV0FBVztBQUFRLG1CQUFPO0FBQ3BFLGdCQUFNLFFBQVEsV0FBVyxPQUFPO0FBQ2hDLGNBQUksTUFBTSxXQUFXO0FBRXJCLGlCQUFPLE9BQU8sTUFBTSxTQUFTLElBQUksTUFBTSxPQUFPO0FBQU0sY0FBRTtBQUV0RCxpQkFBTyxJQUFJLE1BQU0sT0FBTzs7QUFtQjFCLGtDQUEwQjtVQUN4QjtVQUNBO1dBQ0MsS0FBSyxXQUFXLElBQUk7QUFDckIsY0FBSSxNQUFNLFFBQVEsTUFBTSxNQUFNO0FBQzlCLGNBQUksQ0FBQztBQUFLLG1CQUFPO0FBQ2pCLGNBQUk7WUFDRjtjQUNFO0FBRUosY0FBSSxJQUFJLFNBQVMsVUFBVTtBQUN6QixnQkFBSSxPQUFPLFdBQVcsSUFBSTtBQUN4QixvQkFBTSxJQUFJLE9BQU8sR0FBRyxXQUFXLEtBQUs7bUJBQy9CO0FBQ0wsb0JBQU0sWUFBWSxLQUFLLE1BQU0sV0FBVztBQUN4QyxrQkFBSSxJQUFJLFNBQVMsTUFBTTtBQUFXLHNCQUFNLElBQUksT0FBTyxHQUFHLE1BQU0sWUFBWSxLQUFLO0FBQzdFLHFCQUFPLElBQUksU0FBUztBQUNwQixvQkFBTSxXQUFNLElBQUksT0FBTyxJQUFJOzs7QUFJL0IsY0FBSSxTQUFTO0FBQ2IsY0FBSSxTQUFTO0FBRWIsY0FBSSxLQUFLO0FBQ1AsZ0JBQUksSUFBSSxTQUFTLE1BQU0sUUFBUSxNQUFPLEtBQUksTUFBTSxNQUFNLFFBQVEsV0FBVyxHQUFHO0FBQzFFLHVCQUFTLElBQUksTUFBTSxNQUFNO21CQUNwQjtBQUNMLHVCQUFTLEtBQUssSUFBSSxJQUFJLFNBQVMsR0FBRyxZQUFZO0FBQzlDLHVCQUFTOzs7QUFJYixnQkFBTSxTQUFTLE1BQU0sSUFBSSxJQUFJLE9BQU8sTUFBTSxLQUFLO0FBQy9DLGdCQUFNLE1BQU0sSUFBSSxPQUFPO0FBQ3ZCLGlCQUFPLEdBQUc7RUFBUSxTQUFTLE1BQU07O0FBR25DLFlBQUEsUUFBQSxNQUFZO2lCQUNILEtBQUssTUFBTTtBQUNoQixtQkFBTyxJQUFJLE1BQU0sS0FBSyxPQUFPLEtBQUs7O1VBR3BDLFlBQVksT0FBTyxLQUFLO0FBQ3RCLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxNQUFNLE9BQU87O1VBR3BCLFVBQVU7QUFDUixtQkFBTyxPQUFPLEtBQUssVUFBVSxZQUFZLENBQUMsS0FBSyxPQUFPLEtBQUssT0FBTyxLQUFLOztVQVl6RSxhQUFhLElBQUksUUFBUTtBQUN2QixrQkFBTTtjQUNKO2NBQ0E7Z0JBQ0U7QUFFSixnQkFBSSxHQUFHLFdBQVcsS0FBSyxPQUFPLEdBQUcsSUFBSTtBQUNuQyxtQkFBSyxZQUFZO0FBQ2pCLG1CQUFLLFVBQVU7QUFDZixxQkFBTzs7QUFHVCxnQkFBSSxJQUFJO0FBRVIsbUJBQU8sSUFBSSxHQUFHLFFBQVE7QUFDcEIsa0JBQUksR0FBRyxLQUFLO0FBQU87O0FBQVcsa0JBQUU7O0FBR2xDLGlCQUFLLFlBQVksUUFBUTtBQUN6QixrQkFBTSxhQUFhO0FBRW5CLG1CQUFPLElBQUksR0FBRyxRQUFRO0FBRXBCLGtCQUFJLEdBQUcsTUFBTTtBQUFLOztBQUFXLGtCQUFFOztBQUdqQyxpQkFBSyxVQUFVLE1BQU07QUFDckIsbUJBQU87OztBQU9YLFlBQUEsT0FBQSxNQUFXO2lCQUNGLG9CQUFvQixLQUFLLFFBQVEsS0FBSztBQUMzQyxnQkFBSSxJQUFJLElBQUksU0FBUyxPQUFPO0FBQU0scUJBQU87QUFDekMsa0JBQU0sT0FBTyxLQUFLLGdCQUFnQixLQUFLO0FBQ3ZDLG1CQUFPLFFBQVEsSUFBSSxVQUFVLElBQUksVUFBVSxPQUFPLE1BQU0sT0FBTzs7aUJBSTFELG1CQUFtQixLQUFLLFFBQVEsS0FBSztBQUMxQyxrQkFBTSxNQUFNLElBQUk7QUFDaEIsZ0JBQUksQ0FBQztBQUFLLHFCQUFPO0FBQ2pCLGtCQUFNLE9BQU8sSUFBSSxTQUFTO0FBQzFCLGdCQUFJLFFBQVEsU0FBUztBQUFNLHFCQUFPO0FBRWxDLGdCQUFJLEtBQUs7QUFDUCxrQkFBSSxRQUFRO0FBQUssdUJBQU87bUJBQ25CO0FBQ0wsa0JBQUksUUFBUSxLQUFLLGtCQUFrQixRQUFRLEtBQUs7QUFBYyx1QkFBTzs7QUFHdkUsa0JBQU0sTUFBTSxJQUFJLFNBQVM7QUFDekIsa0JBQU0sTUFBTSxJQUFJLFNBQVM7QUFDekIsZ0JBQUksUUFBUSxPQUFPLFFBQVE7QUFBSyxxQkFBTztBQUN2QyxrQkFBTSxNQUFNLElBQUksU0FBUztBQUN6QixtQkFBTyxDQUFDLE9BQU8sUUFBUSxRQUFRLFFBQVEsT0FBUSxRQUFROztpQkFHbEQsZ0JBQWdCLEtBQUssUUFBUTtBQUNsQyxnQkFBSSxLQUFLLElBQUk7QUFDYixrQkFBTSxhQUFhLE9BQU87QUFDMUIsa0JBQU0sUUFBUSxhQUFhLENBQUMsTUFBTSxLQUFNLEtBQUssT0FBTyxDQUFDLE1BQU0sS0FBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFFMUYsbUJBQU8sTUFBTSxNQUFNLFFBQVEsUUFBUTtBQUFJLG1CQUFLLElBQUksVUFBVTtBQUUxRCxnQkFBSSxjQUFjLE9BQU87QUFBSyx3QkFBVTtBQUN4QyxtQkFBTzs7aUJBR0YsWUFBWSxLQUFLLFFBQVE7QUFDOUIsZ0JBQUksS0FBSyxJQUFJO0FBRWIsbUJBQU8sT0FBTztBQUFLLG1CQUFLLElBQUksVUFBVTtBQUV0QyxtQkFBTzs7aUJBR0YsVUFBVSxLQUFLLFFBQVE7QUFDNUIsZ0JBQUksS0FBSyxJQUFJO0FBRWIsbUJBQU8sTUFBTSxPQUFPO0FBQU0sbUJBQUssSUFBSSxVQUFVO0FBRTdDLG1CQUFPOztpQkFHRixnQkFBZ0IsS0FBSyxRQUFRO0FBQ2xDLGdCQUFJLEtBQUssSUFBSTtBQUViLG1CQUFPLE9BQU8sT0FBUSxPQUFPO0FBQUssbUJBQUssSUFBSSxVQUFVO0FBRXJELG1CQUFPOztpQkFHRixZQUFZLEtBQUssUUFBUTtBQUM5QixnQkFBSSxLQUFLLElBQUksU0FBUztBQUN0QixnQkFBSSxPQUFPO0FBQU0scUJBQU87QUFFeEIsbUJBQU8sTUFBTSxPQUFPO0FBQU0sbUJBQUssSUFBSSxVQUFVO0FBRTdDLG1CQUFPLFNBQVM7O2lCQWFYLGlCQUFpQixLQUFLLFFBQVEsV0FBVztBQUM5QyxrQkFBTSxRQUFRLEtBQUssWUFBWSxLQUFLO0FBRXBDLGdCQUFJLFFBQVEsWUFBWSxRQUFRO0FBQzlCLHFCQUFPO21CQUNGO0FBQ0wsb0JBQU0sUUFBUSxLQUFLLGdCQUFnQixLQUFLO0FBQ3hDLG9CQUFNLEtBQUssSUFBSTtBQUNmLGtCQUFJLENBQUMsTUFBTSxPQUFPO0FBQU0sdUJBQU87O0FBR2pDLG1CQUFPOztpQkFHRixRQUFRLEtBQUssUUFBUSxZQUFZO0FBQ3RDLGtCQUFNLEtBQUssSUFBSTtBQUNmLG1CQUFPLE9BQU8sUUFBUSxPQUFPLE9BQVEsT0FBTyxPQUFPLGNBQWMsQ0FBQzs7aUJBRzdELG1CQUFtQixJQUFJLFlBQVksbUJBQW1CO0FBQzNELGdCQUFJLENBQUMsTUFBTSxhQUFhO0FBQUcscUJBQU87QUFDbEMsZ0JBQUksYUFBYTtBQUFHLHFCQUFPO0FBQzNCLG1CQUFPLHFCQUFxQixPQUFPOztpQkFJOUIsZ0JBQWdCLEtBQUssUUFBUTtBQUNsQyxrQkFBTSxLQUFLLElBQUk7QUFDZixtQkFBTyxDQUFDLEtBQUssU0FBUyxPQUFPLFFBQVEsSUFBSSxTQUFTLE9BQU8sT0FBTyxTQUFTLElBQUksS0FBSyxnQkFBZ0IsS0FBSzs7aUJBS2xHLFlBQVksS0FBSyxRQUFRLFFBQVE7QUFDdEMsZ0JBQUksVUFBVTtBQUNkLGdCQUFJLFFBQVE7QUFDWixnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksS0FBSyxJQUFJLFNBQVM7QUFFdEIsbUJBQU8sT0FBTyxPQUFPLE9BQU8sT0FBUSxPQUFPLE1BQU07QUFDL0Msc0JBQVE7cUJBQ0Q7QUFDSCw0QkFBVTtBQUNWLDRCQUFVO0FBQ1YsMEJBQVE7QUFDUjtxQkFFRztBQUNILHNCQUFJLFdBQVc7QUFBUSw0QkFBUTtBQUMvQiwyQkFBUyxLQUFLLGdCQUFnQixLQUFLLFNBQVMsS0FBSztBQUNqRDtxQkFFRztBQUNILDZCQUFXO0FBQ1gsNEJBQVU7QUFDVjs7QUFHSixtQkFBSyxJQUFJLFNBQVM7O0FBR3BCLGdCQUFJLENBQUM7QUFBTSxxQkFBTztBQUNsQixnQkFBSSxNQUFNLFdBQVc7QUFBUSxzQkFBUTtBQUNyQyxtQkFBTztjQUNMO2NBQ0E7Y0FDQTs7O1VBSUosWUFBWSxNQUFNLE9BQU8sU0FBUztBQUNoQyxtQkFBTyxlQUFlLE1BQU0sV0FBVztjQUNyQyxPQUFPLFdBQVc7Y0FDbEIsVUFBVTs7QUFFWixpQkFBSyxRQUFRO0FBQ2IsaUJBQUssUUFBUTtBQUNiLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssUUFBUSxTQUFTO0FBQ3RCLGlCQUFLLE9BQU87QUFDWixpQkFBSyxRQUFROztVQUdmLGFBQWEsS0FBSyxLQUFLLFNBQVM7QUFDOUIsZ0JBQUksQ0FBQyxLQUFLO0FBQVMscUJBQU87QUFDMUIsa0JBQU07Y0FDSjtnQkFDRSxLQUFLO0FBQ1Qsa0JBQU0sT0FBTyxLQUFLLE1BQU07QUFDeEIsbUJBQU8sUUFBUSxJQUFJLEtBQUssV0FBVyxNQUFNLElBQUksTUFBTSxLQUFLLFFBQVMsV0FBVSxJQUFJLElBQUksS0FBSyxPQUFPOztjQUc3RixTQUFTO0FBQ1gscUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQzFDLG9CQUFNLFNBQVMsS0FBSyxhQUFhLEdBQUcsS0FBSyxRQUFRO0FBQ2pELGtCQUFJLFVBQVU7QUFBTSx1QkFBTzs7QUFHN0IsbUJBQU87O2NBR0wsVUFBVTtBQUNaLGtCQUFNLFdBQVc7QUFFakIscUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQzFDLG9CQUFNLFVBQVUsS0FBSyxhQUFhLEdBQUcsS0FBSyxTQUFTO0FBQ25ELGtCQUFJLFdBQVc7QUFBTSx5QkFBUyxLQUFLOztBQUdyQyxtQkFBTyxTQUFTLFNBQVMsSUFBSSxTQUFTLEtBQUssUUFBUTs7VUFHckQsNkJBQTZCLE9BQU87QUFDbEMsa0JBQU07Y0FDSjtnQkFDRSxLQUFLO0FBQ1QsZ0JBQUksS0FBSyxVQUFVLFVBQVUsS0FBSyxPQUFPO0FBQUsscUJBQU87QUFDckQsZ0JBQUksQ0FBQyxLQUFLO0FBQVkscUJBQU87QUFDN0Isa0JBQU07Y0FDSjtnQkFDRSxLQUFLO0FBQ1QsbUJBQU8sVUFBVSxPQUFPLEtBQUssUUFBUSxLQUFLLE1BQU07O2NBRzlDLGFBQWE7QUFDZixnQkFBSSxLQUFLLFNBQVM7QUFDaEIsb0JBQU07Z0JBQ0o7a0JBQ0UsS0FBSztBQUVULHVCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssTUFBTSxRQUFRLEVBQUUsR0FBRztBQUMxQyxvQkFBSSxJQUFJLEtBQUssTUFBTSxHQUFHLFdBQVcsS0FBSztBQUFTLHlCQUFPOzs7QUFJMUQsbUJBQU87O2NBR0wsV0FBVztBQUNiLGdCQUFJLEtBQUssU0FBUztBQUNoQixvQkFBTTtnQkFDSjtrQkFDRSxLQUFLO0FBRVQsdUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQzFDLG9CQUFJLElBQUksS0FBSyxNQUFNLEdBQUcsV0FBVyxLQUFLO0FBQVMseUJBQU87OztBQUkxRCxtQkFBTzs7Y0FHTCx3QkFBd0I7QUFDMUIsbUJBQU87O2NBR0wsV0FBVztBQUNiLGtCQUFNLGdCQUFnQixDQUFDLEtBQUssVUFBVSxLQUFLLFVBQVUsS0FBSyxjQUFjLEtBQUs7QUFDN0UsbUJBQU8sY0FBYyxRQUFRLEtBQUssVUFBVTs7Y0FHMUMsaUJBQWlCO0FBQ25CLGdCQUFJLENBQUMsS0FBSyxTQUFTLENBQUMsS0FBSztBQUFTLHFCQUFPO0FBQ3pDLGtCQUFNLFFBQVEsV0FBVyxLQUFLLE1BQU0sT0FBTyxLQUFLLFFBQVE7QUFDeEQsZ0JBQUksQ0FBQztBQUFPLHFCQUFPO0FBQ25CLGtCQUFNLE1BQU0sV0FBVyxLQUFLLE1BQU0sS0FBSyxLQUFLLFFBQVE7QUFDcEQsbUJBQU87Y0FDTDtjQUNBOzs7Y0FJQSxXQUFXO0FBQ2IsZ0JBQUksQ0FBQyxLQUFLLGNBQWMsQ0FBQyxLQUFLO0FBQVMscUJBQU87QUFDOUMsa0JBQU07Y0FDSjtjQUNBO2dCQUNFLEtBQUs7QUFDVCxtQkFBTyxLQUFLLFFBQVEsSUFBSSxNQUFNLE9BQU87O2NBR25DLE1BQU07QUFDUixxQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDMUMsb0JBQU0sTUFBTSxLQUFLLGFBQWEsR0FBRyxLQUFLLEtBQUs7QUFFM0Msa0JBQUksT0FBTyxNQUFNO0FBQ2Ysb0JBQUksSUFBSSxPQUFPLEtBQUs7QUFDbEIseUJBQU87b0JBQ0wsVUFBVSxJQUFJLE1BQU0sR0FBRzs7dUJBRXBCO0FBRUwsd0JBQU0sQ0FBQyxHQUFHLFFBQVEsVUFBVSxJQUFJLE1BQU07QUFDdEMseUJBQU87b0JBQ0w7b0JBQ0E7Ozs7O0FBTVIsbUJBQU87O2NBR0wsNEJBQTRCO0FBQzlCLGdCQUFJLENBQUMsS0FBSyxjQUFjLENBQUMsS0FBSztBQUFTLHFCQUFPO0FBQzlDLGtCQUFNO2NBQ0o7Y0FDQTtnQkFDRSxLQUFLO0FBQ1Qsa0JBQU07Y0FDSjtnQkFDRSxLQUFLO0FBRVQscUJBQVMsSUFBSSxPQUFPLElBQUksS0FBSyxFQUFFLEdBQUc7QUFDaEMsa0JBQUksSUFBSSxPQUFPO0FBQU0sdUJBQU87O0FBRzlCLG1CQUFPOztVQUdULGFBQWEsT0FBTztBQUNsQixrQkFBTTtjQUNKO2dCQUNFLEtBQUs7QUFFVCxnQkFBSSxJQUFJLFdBQVcsS0FBSyxTQUFTO0FBQy9CLG9CQUFNLE1BQU0sS0FBSyxVQUFVLEtBQUssUUFBUTtBQUN4QyxvQkFBTSxlQUFlLElBQUksTUFBTSxPQUFPO0FBQ3RDLG1CQUFLLE1BQU0sS0FBSztBQUNoQixxQkFBTzs7QUFHVCxtQkFBTzs7VUFZVCxjQUFjLElBQUksUUFBUTtBQUN4QixnQkFBSSxLQUFLO0FBQU8sdUJBQVMsS0FBSyxNQUFNLGFBQWEsSUFBSTtBQUNyRCxnQkFBSSxLQUFLO0FBQVksbUJBQUssV0FBVyxhQUFhLElBQUk7QUFDdEQsaUJBQUssTUFBTSxRQUFRLENBQUEsU0FBUSxLQUFLLGFBQWEsSUFBSTtBQUNqRCxtQkFBTzs7VUFHVCxXQUFXO0FBQ1Qsa0JBQU07Y0FDSixTQUFTO2dCQUNQOztjQUVGO2NBQ0E7Z0JBQ0U7QUFDSixnQkFBSSxTQUFTO0FBQU0scUJBQU87QUFDMUIsa0JBQU0sTUFBTSxJQUFJLE1BQU0sTUFBTSxPQUFPLE1BQU07QUFDekMsbUJBQU8sS0FBSyxvQkFBb0IsS0FBSyxNQUFNLEtBQUs7OztBQUtwRCxZQUFBLFlBQUEsY0FBd0IsTUFBTTtVQUM1QixZQUFZLE1BQU0sUUFBUSxTQUFTO0FBQ2pDLGdCQUFJLENBQUMsV0FBVyxDQUFFLG1CQUFrQjtBQUFPLG9CQUFNLElBQUksTUFBTSw2QkFBNkI7QUFDeEY7QUFDQSxpQkFBSyxPQUFPO0FBQ1osaUJBQUssVUFBVTtBQUNmLGlCQUFLLFNBQVM7O1VBR2hCLGFBQWE7QUFDWCxnQkFBSSxDQUFDLEtBQUs7QUFBUTtBQUNsQixpQkFBSyxXQUFXLEtBQUssT0FBTztBQUM1QixrQkFBTSxNQUFNLEtBQUssT0FBTyxXQUFXLEtBQUssT0FBTyxRQUFRO0FBRXZELGdCQUFJLE9BQU8sS0FBSyxXQUFXLFVBQVU7QUFDbkMsbUJBQUssUUFBUSxJQUFJLE1BQU0sS0FBSyxRQUFRLEtBQUssU0FBUztBQUNsRCxvQkFBTSxRQUFRLE9BQU8sV0FBVyxLQUFLLFFBQVE7QUFFN0Msa0JBQUksT0FBTztBQUNULHNCQUFNLE1BQU07a0JBQ1YsTUFBTSxNQUFNO2tCQUNaLEtBQUssTUFBTSxNQUFNOztBQUVuQixxQkFBSyxVQUFVO2tCQUNiO2tCQUNBOzs7QUFJSixxQkFBTyxLQUFLO21CQUNQO0FBQ0wsbUJBQUssUUFBUSxLQUFLLE9BQU87QUFDekIsbUJBQUssVUFBVSxLQUFLLE9BQU87O0FBRzdCLGdCQUFJLEtBQUssU0FBUztBQUNoQixvQkFBTTtnQkFDSjtnQkFDQTtrQkFDRSxLQUFLLFFBQVE7QUFDakIsbUJBQUssV0FBVyxZQUFZLGdCQUFnQjtBQUM1QyxvQkFBTSxNQUFNLE9BQU8saUJBQWlCLEtBQUssU0FBUztBQUNsRCxrQkFBSTtBQUFLLHFCQUFLLFdBQVc7O0VBQVE7OztBQUduQyxtQkFBTyxLQUFLOzs7QUFJaEIsWUFBQSxxQkFBQSxjQUFpQyxVQUFVO1VBQ3pDLFlBQVksUUFBUSxTQUFTO0FBQzNCLGtCQUFNLHNCQUFzQixRQUFROzs7QUFJeEMsWUFBQSxvQkFBQSxjQUFnQyxVQUFVO1VBQ3hDLFlBQVksUUFBUSxTQUFTO0FBQzNCLGtCQUFNLHFCQUFxQixRQUFROzs7QUFJdkMsWUFBQSxrQkFBQSxjQUE4QixVQUFVO1VBQ3RDLFlBQVksUUFBUSxTQUFTO0FBQzNCLGtCQUFNLG1CQUFtQixRQUFROzs7QUFJckMsWUFBQSxjQUFBLGNBQTBCLFVBQVU7VUFDbEMsWUFBWSxRQUFRLFNBQVM7QUFDM0Isa0JBQU0sZUFBZSxRQUFROzs7QUFLakMsaUNBQXlCLEtBQUssS0FBSyxPQUFPO0FBQ3hDLGNBQUksT0FBTyxLQUFLO0FBQ2QsbUJBQU8sZUFBZSxLQUFLLEtBQUs7Y0FDOUI7Y0FDQSxZQUFZO2NBQ1osY0FBYztjQUNkLFVBQVU7O2lCQUVQO0FBQ0wsZ0JBQUksT0FBTzs7QUFHYixpQkFBTzs7QUFHVCxZQUFBLGFBQUEsY0FBeUIsS0FBSztpQkFDckIsVUFBVSxLQUFLLE9BQU8sUUFBUTtBQUNuQyxnQkFBSSxLQUFLLElBQUk7QUFDYixnQkFBSSxTQUFTO0FBRWIsbUJBQU8sTUFBTSxPQUFPLE1BQU07QUFDeEIsa0JBQUksVUFBVyxRQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTztBQUFNO0FBQ3BGLG9CQUFNLE9BQU8sSUFBSSxTQUFTO0FBQzFCLGtCQUFJLE9BQU8sT0FBUSxFQUFDLFFBQVEsU0FBUyxRQUFRLFNBQVMsT0FBUSxTQUFTLE9BQU8sVUFBVSxTQUFTO0FBQU07QUFDdkcsa0JBQUssUUFBTyxPQUFPLE9BQU8sUUFBUyxTQUFTO0FBQUs7QUFDakQsd0JBQVU7QUFDVixtQkFBSzs7QUFHUCxtQkFBTzs7Y0FHTCxXQUFXO0FBQ2IsZ0JBQUksQ0FBQyxLQUFLLGNBQWMsQ0FBQyxLQUFLO0FBQVMscUJBQU87QUFDOUMsZ0JBQUk7Y0FDRjtjQUNBO2dCQUNFLEtBQUs7QUFDVCxrQkFBTTtjQUNKO2dCQUNFLEtBQUs7QUFDVCxnQkFBSSxLQUFLLElBQUksTUFBTTtBQUVuQixtQkFBTyxRQUFRLE9BQVEsUUFBTyxRQUFRLE9BQU8sT0FBUSxPQUFPO0FBQU0sbUJBQUssSUFBSSxFQUFFLE1BQU07QUFFbkYsZ0JBQUksTUFBTTtBQUVWLHFCQUFTLElBQUksT0FBTyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQ2hDLG9CQUFNLE1BQUssSUFBSTtBQUVmLGtCQUFJLFFBQU8sTUFBTTtBQUNmLHNCQUFNO2tCQUNKO2tCQUNBO29CQUNFLEtBQUssWUFBWSxLQUFLLEdBQUc7QUFDN0IsdUJBQU87QUFDUCxvQkFBSTt5QkFDSyxRQUFPLE9BQU8sUUFBTyxLQUFNO0FBRXBDLHNCQUFNLFVBQVU7QUFDaEIsb0JBQUksT0FBTyxJQUFJLElBQUk7QUFFbkIsdUJBQU8sSUFBSSxPQUFRLFVBQVMsT0FBTyxTQUFTLE1BQU87QUFDakQsdUJBQUs7QUFDTCx5QkFBTyxJQUFJLElBQUk7O0FBR2pCLG9CQUFJLFNBQVM7QUFBTSx5QkFBTyxJQUFJLFVBQVUsSUFBSSxNQUFNLFNBQVMsSUFBSSxLQUFLO3FCQUMvRDtBQUNMLHVCQUFPOzs7QUFJWCxrQkFBTSxNQUFNLElBQUk7QUFFaEIsb0JBQVE7bUJBQ0QsS0FDSDtBQUNFLHNCQUFNLE1BQU07QUFDWixzQkFBTSxTQUFTLENBQUMsSUFBSSxrQkFBa0IsTUFBTTtBQUM1Qyx1QkFBTztrQkFDTDtrQkFDQTs7O21CQUlEO21CQUNBLEtBQ0g7QUFDRSxzQkFBTSxNQUFNLG9EQUFvRDtBQUNoRSxzQkFBTSxTQUFTLENBQUMsSUFBSSxrQkFBa0IsTUFBTTtBQUM1Qyx1QkFBTztrQkFDTDtrQkFDQTs7OztBQUtKLHVCQUFPOzs7VUFJYixnQkFBZ0IsT0FBTztBQUNyQixrQkFBTTtjQUNKO2NBQ0E7Y0FDQTtnQkFDRSxLQUFLO0FBQ1QsZ0JBQUksU0FBUztBQUNiLGdCQUFJLFdBQVc7QUFFZixxQkFBUyxLQUFLLElBQUksU0FBUyxPQUFPLE1BQU0sS0FBSyxJQUFJLFNBQVM7QUFDeEQsa0JBQUksS0FBSyxtQkFBbUIsS0FBSyxTQUFTO0FBQUk7QUFDOUMsb0JBQU0sTUFBTSxLQUFLLGlCQUFpQixLQUFLLFFBQVEsU0FBUztBQUN4RCxrQkFBSSxRQUFRLFFBQVEsSUFBSSxTQUFTO0FBQUs7QUFFdEMsa0JBQUksSUFBSSxTQUFTLE1BQU07QUFDckIseUJBQVM7cUJBQ0o7QUFDTCwyQkFBVyxXQUFXLFVBQVUsS0FBSyxLQUFLO0FBQzFDLHlCQUFTOzs7QUFJYixnQkFBSSxLQUFLLFdBQVc7QUFBVyxtQkFBSyxXQUFXLFFBQVE7QUFDdkQsaUJBQUssV0FBVyxNQUFNO0FBQ3RCLG1CQUFPOztVQTZCVCxNQUFNLFNBQVMsT0FBTztBQUNwQixpQkFBSyxVQUFVO0FBQ2Ysa0JBQU07Y0FDSjtjQUNBO2dCQUNFO0FBQ0osZ0JBQUksU0FBUztBQUNiLGtCQUFNLEtBQUssSUFBSTtBQUVmLGdCQUFJLE1BQU0sT0FBTyxPQUFPLE9BQU8sTUFBTTtBQUNuQyx1QkFBUyxXQUFXLFVBQVUsS0FBSyxPQUFPOztBQUc1QyxpQkFBSyxhQUFhLElBQUksTUFBTSxPQUFPO0FBQ25DLHFCQUFTLEtBQUssZ0JBQWdCLEtBQUs7QUFDbkMscUJBQVMsS0FBSyxhQUFhO0FBRTNCLGdCQUFJLENBQUMsS0FBSyxjQUFjLEtBQUssV0FBVyxXQUFXO0FBQ2pELHVCQUFTLEtBQUssZ0JBQWdCOztBQUdoQyxtQkFBTzs7O0FBS1gsaUJBQVEsT0FBTztBQUNmLGlCQUFRLE9BQU87QUFDZixpQkFBUSxhQUFhO0FBQ3JCLGlCQUFRLFFBQVE7QUFDaEIsaUJBQVEsT0FBTztBQUNmLGlCQUFRLFlBQVk7QUFDcEIsaUJBQVEscUJBQXFCO0FBQzdCLGlCQUFRLG9CQUFvQjtBQUM1QixpQkFBUSxrQkFBa0I7QUFDMUIsaUJBQVEsY0FBYztBQUN0QixpQkFBUSxrQkFBa0I7QUFDMUIsaUJBQVEsbUJBQW1CO0FBQzNCLGlCQUFRLGNBQWM7OztBQzMyQnRCLFFBQUEsOEJBQUEsWUFBQTtNQUFBLGdEQUFBLFVBQUE7QUFBQTtBQUVBLFlBQUksYUFBYTtBQUVqQixrQ0FBMEIsS0FBSyxRQUFRLFNBQVM7QUFDOUMsY0FBSSxDQUFDO0FBQVMsbUJBQU87QUFDckIsZ0JBQU0sS0FBSyxRQUFRLFFBQVEsYUFBYSxLQUFLO0FBQzdDLGlCQUFPLElBQUk7RUFBTyxTQUFTOztBQUU3Qiw0QkFBb0IsS0FBSyxRQUFRLFNBQVM7QUFDeEMsaUJBQU8sQ0FBQyxVQUFVLE1BQU0sUUFBUSxRQUFRLFVBQVUsS0FBSyxHQUFHLFFBQVEsWUFBWSxHQUFHO0lBQVUsUUFBUSxRQUFRLE9BQU8sR0FBRyxVQUFVOztBQUdqSSxZQUFBLE9BQUEsTUFBVzs7QUFFWCx3QkFBZ0IsT0FBTyxLQUFLLEtBQUs7QUFDL0IsY0FBSSxNQUFNLFFBQVE7QUFBUSxtQkFBTyxNQUFNLElBQUksQ0FBQyxHQUFHLE1BQU0sT0FBTyxHQUFHLE9BQU8sSUFBSTtBQUUxRSxjQUFJLFNBQVMsT0FBTyxNQUFNLFdBQVcsWUFBWTtBQUMvQyxrQkFBTSxTQUFTLE9BQU8sSUFBSSxXQUFXLElBQUksUUFBUSxJQUFJO0FBQ3JELGdCQUFJO0FBQVEsa0JBQUksV0FBVyxDQUFBLFNBQU87QUFDaEMsdUJBQU8sTUFBTTtBQUNiLHVCQUFPLElBQUk7O0FBRWIsa0JBQU0sTUFBTSxNQUFNLE9BQU8sS0FBSztBQUM5QixnQkFBSSxVQUFVLElBQUk7QUFBVSxrQkFBSSxTQUFTO0FBQ3pDLG1CQUFPOztBQUdULGNBQUssRUFBQyxPQUFPLENBQUMsSUFBSSxTQUFTLE9BQU8sVUFBVTtBQUFVLG1CQUFPLE9BQU87QUFDcEUsaUJBQU87O0FBR1QsWUFBQSxTQUFBLGNBQXFCLEtBQUs7VUFDeEIsWUFBWSxPQUFPO0FBQ2pCO0FBQ0EsaUJBQUssUUFBUTs7VUFHZixPQUFPLEtBQUssS0FBSztBQUNmLG1CQUFPLE9BQU8sSUFBSSxPQUFPLEtBQUssUUFBUSxPQUFPLEtBQUssT0FBTyxLQUFLOztVQUdoRSxXQUFXO0FBQ1QsbUJBQU8sT0FBTyxLQUFLOzs7QUFLdkIsb0NBQTRCLFFBQVEsTUFBTSxPQUFPO0FBQy9DLGNBQUksSUFBSTtBQUVSLG1CQUFTLElBQUksS0FBSyxTQUFTLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUN6QyxrQkFBTSxJQUFJLEtBQUs7QUFFZixnQkFBSSxPQUFPLFVBQVUsTUFBTSxLQUFLLEdBQUc7QUFDakMsb0JBQU0sSUFBSTtBQUNWLGdCQUFFLEtBQUs7QUFDUCxrQkFBSTttQkFDQztBQUNMLG9CQUFNLElBQUk7QUFDVixxQkFBTyxlQUFlLEdBQUcsR0FBRztnQkFDMUIsT0FBTztnQkFDUCxVQUFVO2dCQUNWLFlBQVk7Z0JBQ1osY0FBYzs7QUFFaEIsa0JBQUk7OztBQUlSLGlCQUFPLE9BQU8sV0FBVyxHQUFHOztBQUk5QixZQUFNLGNBQWMsQ0FBQSxTQUFRLFFBQVEsUUFBUSxPQUFPLFNBQVMsWUFBWSxLQUFLLE9BQU8sWUFBWSxPQUFPO0FBQ3ZHLFlBQUEsYUFBQSxjQUF5QixLQUFLO1VBQzVCLFlBQVksUUFBUTtBQUNsQjtBQUVBLHVCQUFXLGdCQUFnQixNQUFNLFNBQVM7QUFFMUMsaUJBQUssU0FBUzs7VUFHaEIsTUFBTSxNQUFNLE9BQU87QUFDakIsZ0JBQUksWUFBWTtBQUFPLG1CQUFLLElBQUk7aUJBQVk7QUFDMUMsb0JBQU0sQ0FBQyxRQUFRLFFBQVE7QUFDdkIsb0JBQU0sT0FBTyxLQUFLLElBQUksS0FBSztBQUMzQixrQkFBSSxnQkFBZ0I7QUFBWSxxQkFBSyxNQUFNLE1BQU07dUJBQWdCLFNBQVMsVUFBYSxLQUFLO0FBQVEscUJBQUssSUFBSSxLQUFLLG1CQUFtQixLQUFLLFFBQVEsTUFBTTs7QUFBYSxzQkFBTSxJQUFJLE1BQU0sK0JBQStCLHdCQUF3Qjs7O1VBSWhQLFNBQVMsQ0FBQyxRQUFRLE9BQU87QUFDdkIsZ0JBQUksS0FBSyxXQUFXO0FBQUcscUJBQU8sS0FBSyxPQUFPO0FBQzFDLGtCQUFNLE9BQU8sS0FBSyxJQUFJLEtBQUs7QUFDM0IsZ0JBQUksZ0JBQWdCO0FBQVkscUJBQU8sS0FBSyxTQUFTOztBQUFXLG9CQUFNLElBQUksTUFBTSwrQkFBK0Isd0JBQXdCOztVQUd6SSxNQUFNLENBQUMsUUFBUSxPQUFPLFlBQVk7QUFDaEMsa0JBQU0sT0FBTyxLQUFLLElBQUksS0FBSztBQUMzQixnQkFBSSxLQUFLLFdBQVc7QUFBRyxxQkFBTyxDQUFDLGNBQWMsZ0JBQWdCLFNBQVMsS0FBSyxRQUFROztBQUFVLHFCQUFPLGdCQUFnQixhQUFhLEtBQUssTUFBTSxNQUFNLGNBQWM7O1VBR2xLLG1CQUFtQjtBQUNqQixtQkFBTyxLQUFLLE1BQU0sTUFBTSxDQUFBLFNBQVE7QUFDOUIsa0JBQUksQ0FBQyxRQUFRLEtBQUssU0FBUztBQUFRLHVCQUFPO0FBQzFDLG9CQUFNLElBQUksS0FBSztBQUNmLHFCQUFPLEtBQUssUUFBUSxhQUFhLFVBQVUsRUFBRSxTQUFTLFFBQVEsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLEVBQUUsV0FBVyxDQUFDLEVBQUU7OztVQUl2RyxNQUFNLENBQUMsUUFBUSxPQUFPO0FBQ3BCLGdCQUFJLEtBQUssV0FBVztBQUFHLHFCQUFPLEtBQUssSUFBSTtBQUN2QyxrQkFBTSxPQUFPLEtBQUssSUFBSSxLQUFLO0FBQzNCLG1CQUFPLGdCQUFnQixhQUFhLEtBQUssTUFBTSxRQUFROztVQUd6RCxNQUFNLENBQUMsUUFBUSxPQUFPLE9BQU87QUFDM0IsZ0JBQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsbUJBQUssSUFBSSxLQUFLO21CQUNUO0FBQ0wsb0JBQU0sT0FBTyxLQUFLLElBQUksS0FBSztBQUMzQixrQkFBSSxnQkFBZ0I7QUFBWSxxQkFBSyxNQUFNLE1BQU07dUJBQWdCLFNBQVMsVUFBYSxLQUFLO0FBQVEscUJBQUssSUFBSSxLQUFLLG1CQUFtQixLQUFLLFFBQVEsTUFBTTs7QUFBYSxzQkFBTSxJQUFJLE1BQU0sK0JBQStCLHdCQUF3Qjs7O1VBT2hQLFNBQVM7QUFDUCxtQkFBTzs7VUFHVCxTQUFTLEtBQUs7WUFDWjtZQUNBO1lBQ0E7WUFDQTthQUNDLFdBQVcsYUFBYTtBQUN6QixrQkFBTTtjQUNKO2NBQ0E7Y0FDQTtnQkFDRTtBQUNKLGtCQUFNLFNBQVMsS0FBSyxTQUFTLFdBQVcsS0FBSyxZQUFZLEtBQUssU0FBUyxXQUFXLEtBQUssWUFBWSxJQUFJO0FBQ3ZHLGdCQUFJO0FBQVEsNEJBQWM7QUFDMUIsa0JBQU0sZ0JBQWdCLFNBQVMsS0FBSztBQUNwQyxrQkFBTSxPQUFPLE9BQU8sSUFBSSxLQUFLO2NBQzNCO2NBQ0EsUUFBUTtjQUNSO2NBQ0EsTUFBTTs7QUFFUixnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLHFCQUFxQjtBQUN6QixrQkFBTSxRQUFRLEtBQUssTUFBTSxPQUFPLENBQUMsUUFBTyxNQUFNLE1BQU07QUFDbEQsa0JBQUk7QUFFSixrQkFBSSxNQUFNO0FBQ1Isb0JBQUksQ0FBQyxhQUFhLEtBQUs7QUFBYSx5QkFBTSxLQUFLO29CQUM3QyxNQUFNO29CQUNOLEtBQUs7O0FBRVAsb0JBQUksS0FBSztBQUFlLHVCQUFLLGNBQWMsTUFBTSxVQUFVLFFBQVEsQ0FBQSxTQUFRO0FBQ3pFLDJCQUFNLEtBQUs7c0JBQ1QsTUFBTTtzQkFDTixLQUFLLElBQUk7OztBQUdiLG9CQUFJLEtBQUs7QUFBUyw0QkFBVSxLQUFLO0FBQ2pDLG9CQUFJLFVBQVcsRUFBQyxhQUFhLEtBQUssZUFBZSxLQUFLLGlCQUFpQixLQUFLLFdBQVcsS0FBSyxPQUFRLE1BQUssSUFBSSxpQkFBaUIsS0FBSyxJQUFJLFlBQVksS0FBSyxTQUFVLE1BQUssTUFBTSxpQkFBaUIsS0FBSyxNQUFNO0FBQVcsdUNBQXFCOztBQUczTywwQkFBWTtBQUNaLGtCQUFJLE9BQU0sVUFBVSxNQUFNLEtBQUssTUFBTSxVQUFVLE1BQU0sTUFBTSxZQUFZO0FBQ3ZFLGtCQUFJLFVBQVUsQ0FBQyxzQkFBc0IsS0FBSSxTQUFTO0FBQU8scUNBQXFCO0FBQzlFLGtCQUFJLFVBQVUsSUFBSSxLQUFLLE1BQU0sU0FBUztBQUFHLHdCQUFPO0FBQ2hELHFCQUFNLFdBQVcsTUFBSyxZQUFZO0FBQ2xDLGtCQUFJLGFBQWMsWUFBVztBQUFTLDRCQUFZO0FBQ2xELHFCQUFNLEtBQUs7Z0JBQ1QsTUFBTTtnQkFDTixLQUFBOztBQUVGLHFCQUFPO2VBQ047QUFDSCxnQkFBSTtBQUVKLGdCQUFJLE1BQU0sV0FBVyxHQUFHO0FBQ3RCLG9CQUFNLFVBQVUsUUFBUSxVQUFVO3VCQUN6QixRQUFRO0FBQ2pCLG9CQUFNO2dCQUNKO2dCQUNBO2tCQUNFO0FBQ0osb0JBQU0sVUFBVSxNQUFNLElBQUksQ0FBQSxNQUFLLEVBQUU7QUFFakMsa0JBQUksc0JBQXNCLFFBQVEsT0FBTyxDQUFDLEtBQUssU0FBUSxNQUFNLEtBQUksU0FBUyxHQUFHLEtBQUssV0FBVywrQkFBK0I7QUFDMUgsc0JBQU07QUFFTiwyQkFBVyxLQUFLLFNBQVM7QUFDdkIseUJBQU8sSUFBSTtFQUFLLGFBQWEsU0FBUyxNQUFNOztBQUc5Qyx1QkFBTztFQUFLLFNBQVM7cUJBQ2hCO0FBQ0wsc0JBQU0sR0FBRyxTQUFTLFFBQVEsS0FBSyxRQUFROzttQkFFcEM7QUFDTCxvQkFBTSxVQUFVLE1BQU0sSUFBSTtBQUMxQixvQkFBTSxRQUFRO0FBRWQseUJBQVcsS0FBSztBQUFTLHVCQUFPLElBQUk7RUFBSyxTQUFTLE1BQU07O0FBRzFELGdCQUFJLEtBQUssU0FBUztBQUNoQixxQkFBTyxPQUFPLEtBQUssUUFBUSxRQUFRLE9BQU8sR0FBRztBQUM3QyxrQkFBSTtBQUFXO3VCQUNOLGFBQWE7QUFBYTtBQUVyQyxtQkFBTzs7O0FBS1gsbUJBQVcsZ0JBQWdCLFlBQVksaUNBQWlDO0FBRXhFLDZCQUFxQixLQUFLO0FBQ3hCLGNBQUksTUFBTSxlQUFlLFNBQVMsSUFBSSxRQUFRO0FBQzlDLGNBQUksT0FBTyxPQUFPLFFBQVE7QUFBVSxrQkFBTSxPQUFPO0FBQ2pELGlCQUFPLE9BQU8sVUFBVSxRQUFRLE9BQU8sSUFBSSxNQUFNOztBQUduRCxZQUFBLFVBQUEsY0FBc0IsV0FBVztVQUMvQixJQUFJLE9BQU87QUFDVCxpQkFBSyxNQUFNLEtBQUs7O1VBR2xCLE9BQU8sS0FBSztBQUNWLGtCQUFNLE1BQU0sWUFBWTtBQUN4QixnQkFBSSxPQUFPLFFBQVE7QUFBVSxxQkFBTztBQUNwQyxrQkFBTSxNQUFNLEtBQUssTUFBTSxPQUFPLEtBQUs7QUFDbkMsbUJBQU8sSUFBSSxTQUFTOztVQUd0QixJQUFJLEtBQUssWUFBWTtBQUNuQixrQkFBTSxNQUFNLFlBQVk7QUFDeEIsZ0JBQUksT0FBTyxRQUFRO0FBQVUscUJBQU87QUFDcEMsa0JBQU0sS0FBSyxLQUFLLE1BQU07QUFDdEIsbUJBQU8sQ0FBQyxjQUFjLGNBQWMsU0FBUyxHQUFHLFFBQVE7O1VBRzFELElBQUksS0FBSztBQUNQLGtCQUFNLE1BQU0sWUFBWTtBQUN4QixtQkFBTyxPQUFPLFFBQVEsWUFBWSxNQUFNLEtBQUssTUFBTTs7VUFHckQsSUFBSSxLQUFLLE9BQU87QUFDZCxrQkFBTSxNQUFNLFlBQVk7QUFDeEIsZ0JBQUksT0FBTyxRQUFRO0FBQVUsb0JBQU0sSUFBSSxNQUFNLCtCQUErQjtBQUM1RSxpQkFBSyxNQUFNLE9BQU87O1VBR3BCLE9BQU8sR0FBRyxLQUFLO0FBQ2Isa0JBQU0sTUFBTTtBQUNaLGdCQUFJLE9BQU8sSUFBSTtBQUFVLGtCQUFJLFNBQVM7QUFDdEMsZ0JBQUksSUFBSTtBQUVSLHVCQUFXLFFBQVEsS0FBSztBQUFPLGtCQUFJLEtBQUssT0FBTyxNQUFNLE9BQU8sTUFBTTtBQUVsRSxtQkFBTzs7VUFHVCxTQUFTLEtBQUssV0FBVyxhQUFhO0FBQ3BDLGdCQUFJLENBQUM7QUFBSyxxQkFBTyxLQUFLLFVBQVU7QUFDaEMsbUJBQU8sTUFBTSxTQUFTLEtBQUs7Y0FDekIsV0FBVyxDQUFBLE1BQUssRUFBRSxTQUFTLFlBQVksRUFBRSxNQUFNLEtBQUssRUFBRTtjQUN0RCxXQUFXO2dCQUNULE9BQU87Z0JBQ1AsS0FBSzs7Y0FFUCxPQUFPO2NBQ1AsWUFBYSxLQUFJLFVBQVUsTUFBTTtlQUNoQyxXQUFXOzs7QUFLbEIsWUFBTSxlQUFlLENBQUMsS0FBSyxPQUFPLFFBQVE7QUFDeEMsY0FBSSxVQUFVO0FBQU0sbUJBQU87QUFDM0IsY0FBSSxPQUFPLFVBQVU7QUFBVSxtQkFBTyxPQUFPO0FBQzdDLGNBQUksZUFBZSxRQUFRLE9BQU8sSUFBSTtBQUFLLG1CQUFPLElBQUksU0FBUztjQUM3RCxTQUFTLE9BQU8sT0FBTztjQUN2QixLQUFLLElBQUk7Y0FDVCxRQUFRO2NBQ1IsWUFBWSxJQUFJO2NBQ2hCLFFBQVE7Y0FDUixnQkFBZ0I7Y0FDaEIsV0FBVyxJQUFJOztBQUVqQixpQkFBTyxLQUFLLFVBQVU7O0FBR3hCLFlBQUEsT0FBQSxjQUFtQixLQUFLO1VBQ3RCLFlBQVksS0FBSyxRQUFRLE1BQU07QUFDN0I7QUFDQSxpQkFBSyxNQUFNO0FBQ1gsaUJBQUssUUFBUTtBQUNiLGlCQUFLLE9BQU8sS0FBSyxLQUFLOztjQUdwQixnQkFBZ0I7QUFDbEIsbUJBQU8sS0FBSyxlQUFlLE9BQU8sS0FBSyxJQUFJLGdCQUFnQjs7Y0FHekQsY0FBYyxJQUFJO0FBQ3BCLGdCQUFJLEtBQUssT0FBTztBQUFNLG1CQUFLLE1BQU0sSUFBSSxPQUFPO0FBQzVDLGdCQUFJLEtBQUssZUFBZTtBQUFNLG1CQUFLLElBQUksZ0JBQWdCO2lCQUFRO0FBQzdELG9CQUFNLE1BQU07QUFDWixvQkFBTSxJQUFJLE1BQU07OztVQUlwQixXQUFXLEtBQUssS0FBSztBQUNuQixrQkFBTSxNQUFNLE9BQU8sS0FBSyxLQUFLLElBQUk7QUFFakMsZ0JBQUksZUFBZSxLQUFLO0FBQ3RCLG9CQUFNLFFBQVEsT0FBTyxLQUFLLE9BQU8sS0FBSztBQUN0QyxrQkFBSSxJQUFJLEtBQUs7dUJBQ0osZUFBZSxLQUFLO0FBQzdCLGtCQUFJLElBQUk7bUJBQ0g7QUFDTCxvQkFBTSxZQUFZLGFBQWEsS0FBSyxLQUFLLEtBQUs7QUFDOUMsb0JBQU0sUUFBUSxPQUFPLEtBQUssT0FBTyxXQUFXO0FBQzVDLGtCQUFJLGFBQWE7QUFBSyx1QkFBTyxlQUFlLEtBQUssV0FBVztrQkFDMUQ7a0JBQ0EsVUFBVTtrQkFDVixZQUFZO2tCQUNaLGNBQWM7OztBQUNSLG9CQUFJLGFBQWE7O0FBRzNCLG1CQUFPOztVQUdULE9BQU8sR0FBRyxLQUFLO0FBQ2Isa0JBQU0sT0FBTyxPQUFPLElBQUksV0FBVyxJQUFJLFFBQVE7QUFDL0MsbUJBQU8sS0FBSyxXQUFXLEtBQUs7O1VBRzlCLFNBQVMsS0FBSyxXQUFXLGFBQWE7QUFDcEMsZ0JBQUksQ0FBQyxPQUFPLENBQUMsSUFBSTtBQUFLLHFCQUFPLEtBQUssVUFBVTtBQUM1QyxrQkFBTTtjQUNKLFFBQVE7Y0FDUjtjQUNBO2dCQUNFLElBQUksSUFBSTtBQUNaLGdCQUFJO2NBQ0Y7Y0FDQTtnQkFDRTtBQUNKLGdCQUFJLGFBQWEsZUFBZSxRQUFRLElBQUk7QUFFNUMsZ0JBQUksWUFBWTtBQUNkLGtCQUFJLFlBQVk7QUFDZCxzQkFBTSxJQUFJLE1BQU07O0FBR2xCLGtCQUFJLGVBQWUsWUFBWTtBQUM3QixzQkFBTSxNQUFNO0FBQ1osc0JBQU0sSUFBSSxNQUFNOzs7QUFJcEIsZ0JBQUksY0FBYyxDQUFDLGNBQWUsRUFBQyxPQUFPLGNBQWUsZ0JBQWUsT0FBTyxlQUFlLGNBQWMsSUFBSSxTQUFTLFdBQVcsS0FBSyxnQkFBZ0IsSUFBSSxTQUFTLFdBQVcsS0FBSyxnQkFBZ0IsT0FBTyxRQUFRO0FBQ3JOLGtCQUFNO2NBQ0o7Y0FDQTtjQUNBO2NBQ0E7Z0JBQ0U7QUFDSixrQkFBTSxPQUFPLE9BQU8sSUFBSSxLQUFLO2NBQzNCLGFBQWEsQ0FBQztjQUNkLFFBQVEsU0FBUzs7QUFFbkIsZ0JBQUksWUFBWTtBQUNoQixnQkFBSSxNQUFNLFVBQVUsS0FBSyxLQUFLLE1BQU0sYUFBYSxNQUFNLE1BQU0sWUFBWTtBQUN6RSxrQkFBTSxXQUFXLEtBQUssSUFBSSxRQUFRO0FBRWxDLGdCQUFJLENBQUMsZUFBZSxJQUFJLFNBQVMsTUFBTTtBQUNyQyxrQkFBSTtBQUFZLHNCQUFNLElBQUksTUFBTTtBQUNoQyw0QkFBYzs7QUFHaEIsZ0JBQUksSUFBSSxpQkFBaUIsQ0FBQyxZQUFZO0FBQ3BDLGtCQUFJLEtBQUssU0FBUztBQUNoQixzQkFBTSxXQUFXLEtBQUssSUFBSSxRQUFRLEtBQUs7QUFDdkMsb0JBQUk7QUFBVzt5QkFDTixhQUFhLENBQUMsY0FBYztBQUFhO0FBRXBELHFCQUFPLElBQUksVUFBVSxDQUFDLGNBQWMsTUFBTSxLQUFLOztBQUdqRCxrQkFBTSxjQUFjLEtBQUs7RUFBUSxZQUFZLEdBQUc7QUFFaEQsZ0JBQUksS0FBSyxTQUFTO0FBRWhCLG9CQUFNLFdBQVcsS0FBSyxJQUFJLFFBQVEsS0FBSztBQUN2QyxrQkFBSTtBQUFXOztBQUdqQixnQkFBSSxNQUFNO0FBQ1YsZ0JBQUksZUFBZTtBQUVuQixnQkFBSSxpQkFBaUIsTUFBTTtBQUN6QixrQkFBSSxNQUFNO0FBQWEsc0JBQU07QUFFN0Isa0JBQUksTUFBTSxlQUFlO0FBQ3ZCLHNCQUFNLEtBQUssTUFBTSxjQUFjLFFBQVEsT0FBTyxHQUFHLElBQUk7QUFDckQsdUJBQU87RUFBSzs7QUFHZCw2QkFBZSxNQUFNO3VCQUNaLFNBQVMsT0FBTyxVQUFVLFVBQVU7QUFDN0Msc0JBQVEsSUFBSSxPQUFPLFdBQVcsT0FBTzs7QUFHdkMsZ0JBQUksY0FBYztBQUNsQixnQkFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLFdBQVcsaUJBQWlCO0FBQVEsa0JBQUksZ0JBQWdCLElBQUksU0FBUztBQUMvRix3QkFBWTtBQUVaLGdCQUFJLENBQUMsYUFBYSxjQUFjLEtBQUssQ0FBQyxJQUFJLFVBQVUsQ0FBQyxlQUFlLGlCQUFpQixXQUFXLE1BQU0sU0FBUyxXQUFXLEtBQUssWUFBWSxDQUFDLE1BQU0sT0FBTyxDQUFDLElBQUksUUFBUSxRQUFRLFFBQVE7QUFFcEwsa0JBQUksU0FBUyxJQUFJLE9BQU8sT0FBTzs7QUFHakMsa0JBQU0sV0FBVyxVQUFVLE9BQU8sS0FBSyxNQUFNLGVBQWUsTUFBTSxNQUFNLFlBQVk7QUFDcEYsZ0JBQUksS0FBSztBQUVULGdCQUFJLE9BQU8sS0FBSyxTQUFTO0FBQ3ZCLG1CQUFLLEdBQUc7RUFBUSxJQUFJO3VCQUNYLENBQUMsZUFBZSxpQkFBaUIsWUFBWTtBQUN0RCxvQkFBTSxPQUFPLFNBQVMsT0FBTyxPQUFPLFNBQVMsT0FBTztBQUNwRCxrQkFBSSxDQUFDLFFBQVEsU0FBUyxTQUFTO0FBQU8scUJBQUs7RUFBSyxJQUFJO3VCQUMzQyxTQUFTLE9BQU87QUFBTSxtQkFBSztBQUV0QyxnQkFBSSxhQUFhLENBQUMsZ0JBQWdCO0FBQWE7QUFDL0MsbUJBQU8sV0FBVyxNQUFNLEtBQUssVUFBVSxJQUFJLFFBQVE7OztBQUt2RCxtQkFBVyxnQkFBZ0IsTUFBTSxRQUFRO1VBQ3ZDLE1BQU07VUFDTixZQUFZOztBQUdkLFlBQU0sZ0JBQWdCLENBQUMsTUFBTSxZQUFZO0FBQ3ZDLGNBQUksZ0JBQWdCLE9BQU87QUFDekIsa0JBQU0sU0FBUyxRQUFRLElBQUksS0FBSztBQUNoQyxtQkFBTyxPQUFPLFFBQVEsT0FBTztxQkFDcEIsZ0JBQWdCLFlBQVk7QUFDckMsZ0JBQUksUUFBUTtBQUVaLHVCQUFXLFFBQVEsS0FBSyxPQUFPO0FBQzdCLG9CQUFNLElBQUksY0FBYyxNQUFNO0FBQzlCLGtCQUFJLElBQUk7QUFBTyx3QkFBUTs7QUFHekIsbUJBQU87cUJBQ0UsZ0JBQWdCLE1BQU07QUFDL0Isa0JBQU0sS0FBSyxjQUFjLEtBQUssS0FBSztBQUNuQyxrQkFBTSxLQUFLLGNBQWMsS0FBSyxPQUFPO0FBQ3JDLG1CQUFPLEtBQUssSUFBSSxJQUFJOztBQUd0QixpQkFBTzs7QUFHVCxZQUFBLFFBQUEsY0FBb0IsS0FBSztpQkFDaEIsVUFBVTtZQUNmO1lBQ0E7YUFDQztZQUNEO1lBQ0E7WUFDQTtZQUNBO2FBQ0M7QUFDRCxnQkFBSSxTQUFTLE9BQU8sS0FBSyxTQUFTLEtBQUssQ0FBQSxNQUFLLFFBQVEsT0FBTztBQUMzRCxnQkFBSSxDQUFDLFVBQVU7QUFBZ0IsdUJBQVMsSUFBSSxRQUFRLFFBQVEsV0FBVyxJQUFJLFFBQVE7QUFDbkYsZ0JBQUk7QUFBUSxxQkFBTyxJQUFJLFNBQVMsY0FBYyxNQUFNO0FBQ3BELGtCQUFNLE1BQU0sSUFBSSxRQUFRLFFBQVEsVUFBVSx5Q0FBeUM7QUFDbkYsa0JBQU0sSUFBSSxNQUFNLEdBQUcsUUFBUTs7VUFHN0IsWUFBWSxRQUFRO0FBQ2xCO0FBQ0EsaUJBQUssU0FBUztBQUNkLGlCQUFLLE9BQU8sV0FBVyxLQUFLOztjQUcxQixJQUFJLEdBQUc7QUFDVCxrQkFBTSxJQUFJLE1BQU07O1VBR2xCLE9BQU8sS0FBSyxLQUFLO0FBQ2YsZ0JBQUksQ0FBQztBQUFLLHFCQUFPLE9BQU8sS0FBSyxRQUFRLEtBQUs7QUFDMUMsa0JBQU07Y0FDSjtjQUNBO2dCQUNFO0FBQ0osa0JBQU0sU0FBUyxRQUFRLElBQUksS0FBSztBQUdoQyxnQkFBSSxDQUFDLFVBQVUsT0FBTyxRQUFRLFFBQVc7QUFDdkMsb0JBQU0sTUFBTTtBQUNaLGtCQUFJLEtBQUs7QUFBUyxzQkFBTSxJQUFJLFdBQVcsbUJBQW1CLEtBQUssU0FBUzs7QUFBVSxzQkFBTSxJQUFJLGVBQWU7O0FBRzdHLGdCQUFJLGlCQUFpQixHQUFHO0FBQ3RCLHFCQUFPLFNBQVM7QUFDaEIsa0JBQUksT0FBTyxlQUFlO0FBQUcsdUJBQU8sYUFBYSxjQUFjLEtBQUssUUFBUTtBQUU1RSxrQkFBSSxPQUFPLFFBQVEsT0FBTyxhQUFhLGVBQWU7QUFDcEQsc0JBQU0sTUFBTTtBQUNaLG9CQUFJLEtBQUs7QUFBUyx3QkFBTSxJQUFJLFdBQVcsbUJBQW1CLEtBQUssU0FBUzs7QUFBVSx3QkFBTSxJQUFJLGVBQWU7OztBQUkvRyxtQkFBTyxPQUFPOztVQUtoQixTQUFTLEtBQUs7QUFDWixtQkFBTyxNQUFNLFVBQVUsTUFBTTs7O0FBS2pDLG1CQUFXLGdCQUFnQixPQUFPLFdBQVc7QUFFN0MsMEJBQWtCLE9BQU8sS0FBSztBQUM1QixnQkFBTSxJQUFJLGVBQWUsU0FBUyxJQUFJLFFBQVE7QUFFOUMscUJBQVcsTUFBTSxPQUFPO0FBQ3RCLGdCQUFJLGNBQWMsTUFBTTtBQUN0QixrQkFBSSxHQUFHLFFBQVEsT0FBTyxHQUFHLFFBQVE7QUFBRyx1QkFBTztBQUMzQyxrQkFBSSxHQUFHLE9BQU8sR0FBRyxJQUFJLFVBQVU7QUFBRyx1QkFBTzs7O0FBSTdDLGlCQUFPOztBQUVULFlBQUEsVUFBQSxjQUFzQixXQUFXO1VBQy9CLElBQUksTUFBTSxXQUFXO0FBQ25CLGdCQUFJLENBQUM7QUFBTSxxQkFBTyxJQUFJLEtBQUs7cUJBQWUsQ0FBRSxpQkFBZ0I7QUFBTyxxQkFBTyxJQUFJLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSztBQUMxRyxrQkFBTSxPQUFPLFNBQVMsS0FBSyxPQUFPLEtBQUs7QUFDdkMsa0JBQU0sY0FBYyxLQUFLLFVBQVUsS0FBSyxPQUFPO0FBRS9DLGdCQUFJLE1BQU07QUFDUixrQkFBSTtBQUFXLHFCQUFLLFFBQVEsS0FBSzs7QUFBVyxzQkFBTSxJQUFJLE1BQU0sT0FBTyxLQUFLO3VCQUMvRCxhQUFhO0FBQ3RCLG9CQUFNLElBQUksS0FBSyxNQUFNLFVBQVUsQ0FBQSxTQUFRLFlBQVksTUFBTSxRQUFRO0FBQ2pFLGtCQUFJLE1BQU07QUFBSSxxQkFBSyxNQUFNLEtBQUs7O0FBQVcscUJBQUssTUFBTSxPQUFPLEdBQUcsR0FBRzttQkFDNUQ7QUFDTCxtQkFBSyxNQUFNLEtBQUs7OztVQUlwQixPQUFPLEtBQUs7QUFDVixrQkFBTSxLQUFLLFNBQVMsS0FBSyxPQUFPO0FBQ2hDLGdCQUFJLENBQUM7QUFBSSxxQkFBTztBQUNoQixrQkFBTSxNQUFNLEtBQUssTUFBTSxPQUFPLEtBQUssTUFBTSxRQUFRLEtBQUs7QUFDdEQsbUJBQU8sSUFBSSxTQUFTOztVQUd0QixJQUFJLEtBQUssWUFBWTtBQUNuQixrQkFBTSxLQUFLLFNBQVMsS0FBSyxPQUFPO0FBQ2hDLGtCQUFNLE9BQU8sTUFBTSxHQUFHO0FBQ3RCLG1CQUFPLENBQUMsY0FBYyxnQkFBZ0IsU0FBUyxLQUFLLFFBQVE7O1VBRzlELElBQUksS0FBSztBQUNQLG1CQUFPLENBQUMsQ0FBQyxTQUFTLEtBQUssT0FBTzs7VUFHaEMsSUFBSSxLQUFLLE9BQU87QUFDZCxpQkFBSyxJQUFJLElBQUksS0FBSyxLQUFLLFFBQVE7O1VBVWpDLE9BQU8sR0FBRyxLQUFLLE1BQU07QUFDbkIsa0JBQU0sTUFBTSxPQUFPLElBQUksU0FBUyxPQUFPLElBQUksV0FBVyxJQUFJLFFBQVE7QUFDbEUsZ0JBQUksT0FBTyxJQUFJO0FBQVUsa0JBQUksU0FBUztBQUV0Qyx1QkFBVyxRQUFRLEtBQUs7QUFBTyxtQkFBSyxXQUFXLEtBQUs7QUFFcEQsbUJBQU87O1VBR1QsU0FBUyxLQUFLLFdBQVcsYUFBYTtBQUNwQyxnQkFBSSxDQUFDO0FBQUsscUJBQU8sS0FBSyxVQUFVO0FBRWhDLHVCQUFXLFFBQVEsS0FBSyxPQUFPO0FBQzdCLGtCQUFJLENBQUUsaUJBQWdCO0FBQU8sc0JBQU0sSUFBSSxNQUFNLHNDQUFzQyxLQUFLLFVBQVU7O0FBR3BHLG1CQUFPLE1BQU0sU0FBUyxLQUFLO2NBQ3pCLFdBQVcsQ0FBQSxNQUFLLEVBQUU7Y0FDbEIsV0FBVztnQkFDVCxPQUFPO2dCQUNQLEtBQUs7O2NBRVAsT0FBTztjQUNQLFlBQVksSUFBSSxVQUFVO2VBQ3pCLFdBQVc7OztBQUtsQixZQUFNLFlBQVk7QUFDbEIsWUFBQSxRQUFBLGNBQW9CLEtBQUs7VUFDdkIsWUFBWSxNQUFNO0FBQ2hCLGdCQUFJLGdCQUFnQixNQUFNO0FBQ3hCLGtCQUFJLE1BQU0sS0FBSztBQUVmLGtCQUFJLENBQUUsZ0JBQWUsVUFBVTtBQUM3QixzQkFBTSxJQUFJO0FBQ1Ysb0JBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEIsb0JBQUksUUFBUSxLQUFLLE1BQU07O0FBR3pCLG9CQUFNLEtBQUssS0FBSztBQUNoQixtQkFBSyxRQUFRLEtBQUs7bUJBQ2I7QUFDTCxvQkFBTSxJQUFJLE9BQU8sWUFBWSxJQUFJOztBQUduQyxpQkFBSyxPQUFPLEtBQUssS0FBSzs7VUFVeEIsV0FBVyxLQUFLLEtBQUs7QUFDbkIsdUJBQVc7Y0FDVDtpQkFDRyxLQUFLLE1BQU0sT0FBTztBQUNyQixrQkFBSSxDQUFFLG1CQUFrQjtBQUFVLHNCQUFNLElBQUksTUFBTTtBQUNsRCxvQkFBTSxTQUFTLE9BQU8sT0FBTyxNQUFNLEtBQUs7QUFFeEMseUJBQVcsQ0FBQyxLQUFLLFVBQVUsUUFBUTtBQUNqQyxvQkFBSSxlQUFlLEtBQUs7QUFDdEIsc0JBQUksQ0FBQyxJQUFJLElBQUk7QUFBTSx3QkFBSSxJQUFJLEtBQUs7MkJBQ3ZCLGVBQWUsS0FBSztBQUM3QixzQkFBSSxJQUFJOzJCQUNDLENBQUMsT0FBTyxVQUFVLGVBQWUsS0FBSyxLQUFLLE1BQU07QUFDMUQseUJBQU8sZUFBZSxLQUFLLEtBQUs7b0JBQzlCO29CQUNBLFVBQVU7b0JBQ1YsWUFBWTtvQkFDWixjQUFjOzs7OztBQU10QixtQkFBTzs7VUFHVCxTQUFTLEtBQUssV0FBVztBQUN2QixrQkFBTSxNQUFNLEtBQUs7QUFDakIsZ0JBQUksSUFBSSxNQUFNLFNBQVM7QUFBRyxxQkFBTyxNQUFNLFNBQVMsS0FBSztBQUNyRCxpQkFBSyxRQUFRLElBQUksTUFBTTtBQUN2QixrQkFBTSxNQUFNLE1BQU0sU0FBUyxLQUFLO0FBQ2hDLGlCQUFLLFFBQVE7QUFDYixtQkFBTzs7O0FBS1gsWUFBTSxnQkFBZ0I7VUFDcEIsYUFBYSxXQUFXLEtBQUs7VUFDN0IsV0FBVzs7QUFFYixZQUFNLGNBQWM7VUFDbEIsU0FBUztVQUNULFVBQVU7O0FBRVosWUFBTSxhQUFhO1VBQ2pCLFVBQVU7O0FBRVosWUFBTSxjQUFjO1VBQ2xCLFNBQVM7O0FBRVgsWUFBTSxhQUFhO1VBQ2pCLGFBQWEsV0FBVyxLQUFLO1VBQzdCLGNBQWM7WUFDWixjQUFjO1lBQ2Qsb0JBQW9COztVQUV0QixNQUFNO1lBQ0osV0FBVztZQUNYLGlCQUFpQjs7O0FBSXJCLCtCQUF1QixLQUFLLE1BQU0sZ0JBQWdCO0FBQ2hELHFCQUFXO1lBQ1Q7WUFDQTtZQUNBO2VBQ0csTUFBTTtBQUNULGdCQUFJLE1BQU07QUFDUixvQkFBTSxRQUFRLElBQUksTUFBTTtBQUV4QixrQkFBSSxPQUFPO0FBQ1Qsb0JBQUksTUFBTSxRQUFRLE1BQU0sTUFBTTtBQUM5QixvQkFBSSxDQUFFLGdCQUFlO0FBQVMsd0JBQU0sSUFBSSxPQUFPO0FBQy9DLG9CQUFJO0FBQVEsc0JBQUksU0FBUztBQUN6Qix1QkFBTzs7OztBQUtiLGNBQUk7QUFBZ0Isa0JBQU0sZUFBZTtBQUN6QyxpQkFBTyxJQUFJLE9BQU87O0FBR3BCLFlBQU0sWUFBWTtBQUNsQixZQUFNLGFBQWE7QUFDbkIsWUFBTSxjQUFjO0FBR3BCLFlBQU0sMkJBQTJCLENBQUMsTUFBTSxNQUFNO0FBQzVDLGNBQUksS0FBSyxLQUFLLElBQUk7QUFFbEIsaUJBQU8sT0FBTyxPQUFPLE9BQU8sS0FBTTtBQUNoQyxlQUFHO0FBQ0QsbUJBQUssS0FBSyxLQUFLO3FCQUNSLE1BQU0sT0FBTztBQUV0QixpQkFBSyxLQUFLLElBQUk7O0FBR2hCLGlCQUFPOztBQXdCVCwrQkFBdUIsTUFBTSxRQUFRLE1BQU07VUFDekM7VUFDQSxZQUFZO1VBQ1osa0JBQWtCO1VBQ2xCO1VBQ0E7V0FDQztBQUNELGNBQUksQ0FBQyxhQUFhLFlBQVk7QUFBRyxtQkFBTztBQUN4QyxnQkFBTSxVQUFVLEtBQUssSUFBSSxJQUFJLGlCQUFpQixJQUFJLFlBQVksT0FBTztBQUNyRSxjQUFJLEtBQUssVUFBVTtBQUFTLG1CQUFPO0FBQ25DLGdCQUFNLFFBQVE7QUFDZCxnQkFBTSxlQUFlO0FBQ3JCLGNBQUksTUFBTSxZQUFZLE9BQU87QUFFN0IsY0FBSSxPQUFPLGtCQUFrQixVQUFVO0FBQ3JDLGdCQUFJLGdCQUFnQixZQUFZLEtBQUssSUFBSSxHQUFHO0FBQWtCLG9CQUFNLEtBQUs7O0FBQVEsb0JBQU0sWUFBWTs7QUFHckcsY0FBSSxRQUFRO0FBQ1osY0FBSSxPQUFPO0FBQ1gsY0FBSSxXQUFXO0FBQ2YsY0FBSSxJQUFJO0FBQ1IsY0FBSSxXQUFXO0FBQ2YsY0FBSSxTQUFTO0FBRWIsY0FBSSxTQUFTLFlBQVk7QUFDdkIsZ0JBQUkseUJBQXlCLE1BQU07QUFDbkMsZ0JBQUksTUFBTTtBQUFJLG9CQUFNLElBQUk7O0FBRzFCLG1CQUFTLElBQUksS0FBSyxLQUFLLEtBQUssTUFBSztBQUMvQixnQkFBSSxTQUFTLGVBQWUsT0FBTyxNQUFNO0FBQ3ZDLHlCQUFXO0FBRVgsc0JBQVEsS0FBSyxJQUFJO3FCQUNWO0FBQ0gsdUJBQUs7QUFDTDtxQkFFRztBQUNILHVCQUFLO0FBQ0w7cUJBRUc7QUFDSCx1QkFBSztBQUNMOztBQUdBLHVCQUFLOztBQUdULHVCQUFTOztBQUdYLGdCQUFJLE9BQU8sTUFBTTtBQUNmLGtCQUFJLFNBQVM7QUFBWSxvQkFBSSx5QkFBeUIsTUFBTTtBQUM1RCxvQkFBTSxJQUFJO0FBQ1Ysc0JBQVE7bUJBQ0g7QUFDTCxrQkFBSSxPQUFPLE9BQU8sUUFBUSxTQUFTLE9BQU8sU0FBUyxRQUFRLFNBQVMsS0FBTTtBQUV4RSxzQkFBTSxPQUFPLEtBQUssSUFBSTtBQUN0QixvQkFBSSxRQUFRLFNBQVMsT0FBTyxTQUFTLFFBQVEsU0FBUztBQUFNLDBCQUFROztBQUd0RSxrQkFBSSxLQUFLLEtBQUs7QUFDWixvQkFBSSxPQUFPO0FBQ1Qsd0JBQU0sS0FBSztBQUNYLHdCQUFNLFFBQVE7QUFDZCwwQkFBUTsyQkFDQyxTQUFTLGFBQWE7QUFFL0IseUJBQU8sU0FBUyxPQUFPLFNBQVMsS0FBTTtBQUNwQywyQkFBTztBQUNQLHlCQUFLLEtBQUssS0FBSztBQUNmLCtCQUFXOztBQUliLHdCQUFNLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLFdBQVc7QUFFOUMsc0JBQUksYUFBYTtBQUFJLDJCQUFPO0FBQzVCLHdCQUFNLEtBQUs7QUFDWCwrQkFBYSxLQUFLO0FBQ2xCLHdCQUFNLElBQUk7QUFDViwwQkFBUTt1QkFDSDtBQUNMLDZCQUFXOzs7O0FBS2pCLG1CQUFPOztBQUdULGNBQUksWUFBWTtBQUFZO0FBQzVCLGNBQUksTUFBTSxXQUFXO0FBQUcsbUJBQU87QUFDL0IsY0FBSTtBQUFRO0FBQ1osY0FBSSxNQUFNLEtBQUssTUFBTSxHQUFHLE1BQU07QUFFOUIsbUJBQVMsS0FBSSxHQUFHLEtBQUksTUFBTSxRQUFRLEVBQUUsSUFBRztBQUNyQyxrQkFBTSxPQUFPLE1BQU07QUFDbkIsa0JBQU0sT0FBTSxNQUFNLEtBQUksTUFBTSxLQUFLO0FBQ2pDLGdCQUFJLFNBQVM7QUFBRyxvQkFBTTtFQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUc7aUJBQVk7QUFDNUQsa0JBQUksU0FBUyxlQUFlLGFBQWE7QUFBTyx1QkFBTyxHQUFHLEtBQUs7QUFDL0QscUJBQU87RUFBSyxTQUFTLEtBQUssTUFBTSxPQUFPLEdBQUc7OztBQUk5QyxpQkFBTzs7QUFHVCxZQUFNLGlCQUFpQixDQUFDO1VBQ3RCO2NBQ0ksZ0JBQWdCLE9BQU8sT0FBTztVQUNsQztXQUNDLFdBQVcsUUFBUSxXQUFXO0FBSWpDLFlBQU0seUJBQXlCLENBQUEsUUFBTyxtQkFBbUIsS0FBSztBQUU5RCxxQ0FBNkIsS0FBSyxXQUFXLGNBQWM7QUFDekQsY0FBSSxDQUFDLGFBQWEsWUFBWTtBQUFHLG1CQUFPO0FBQ3hDLGdCQUFNLFFBQVEsWUFBWTtBQUMxQixnQkFBTSxTQUFTLElBQUk7QUFDbkIsY0FBSSxVQUFVO0FBQU8sbUJBQU87QUFFNUIsbUJBQVMsSUFBSSxHQUFHLFFBQVEsR0FBRyxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQzFDLGdCQUFJLElBQUksT0FBTyxNQUFNO0FBQ25CLGtCQUFJLElBQUksUUFBUTtBQUFPLHVCQUFPO0FBQzlCLHNCQUFRLElBQUk7QUFDWixrQkFBSSxTQUFTLFNBQVM7QUFBTyx1QkFBTzs7O0FBSXhDLGlCQUFPOztBQUdULG9DQUE0QixPQUFPLEtBQUs7QUFDdEMsZ0JBQU07WUFDSjtjQUNFO0FBQ0osZ0JBQU07WUFDSjtZQUNBO2NBQ0UsV0FBVztBQUNmLGdCQUFNLE9BQU8sS0FBSyxVQUFVO0FBQzVCLGNBQUk7QUFBYyxtQkFBTztBQUN6QixnQkFBTSxTQUFTLElBQUksVUFBVyx3QkFBdUIsU0FBUyxPQUFPO0FBQ3JFLGNBQUksTUFBTTtBQUNWLGNBQUksUUFBUTtBQUVaLG1CQUFTLElBQUksR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxFQUFFLElBQUk7QUFDaEQsZ0JBQUksT0FBTyxPQUFPLEtBQUssSUFBSSxPQUFPLFFBQVEsS0FBSyxJQUFJLE9BQU8sS0FBSztBQUU3RCxxQkFBTyxLQUFLLE1BQU0sT0FBTyxLQUFLO0FBQzlCLG1CQUFLO0FBQ0wsc0JBQVE7QUFDUixtQkFBSzs7QUFHUCxnQkFBSSxPQUFPO0FBQU0sc0JBQVEsS0FBSyxJQUFJO3FCQUMzQjtBQUNIO0FBQ0UsMkJBQU8sS0FBSyxNQUFNLE9BQU87QUFDekIsMEJBQU0sT0FBTyxLQUFLLE9BQU8sSUFBSSxHQUFHO0FBRWhDLDRCQUFROzJCQUNEO0FBQ0gsK0JBQU87QUFDUDsyQkFFRztBQUNILCtCQUFPO0FBQ1A7MkJBRUc7QUFDSCwrQkFBTztBQUNQOzJCQUVHO0FBQ0gsK0JBQU87QUFDUDsyQkFFRztBQUNILCtCQUFPO0FBQ1A7MkJBRUc7QUFDSCwrQkFBTztBQUNQOzJCQUVHO0FBQ0gsK0JBQU87QUFDUDsyQkFFRztBQUNILCtCQUFPO0FBQ1A7O0FBR0EsNEJBQUksS0FBSyxPQUFPLEdBQUcsT0FBTztBQUFNLGlDQUFPLFFBQVEsS0FBSyxPQUFPOztBQUFRLGlDQUFPLEtBQUssT0FBTyxHQUFHOztBQUc3Rix5QkFBSztBQUNMLDRCQUFRLElBQUk7O0FBRWQ7cUJBRUc7QUFDSCxzQkFBSSxlQUFlLEtBQUssSUFBSSxPQUFPLE9BQU8sS0FBSyxTQUFTLG9CQUFvQjtBQUMxRSx5QkFBSzt5QkFDQTtBQUVMLDJCQUFPLEtBQUssTUFBTSxPQUFPLEtBQUs7QUFFOUIsMkJBQU8sS0FBSyxJQUFJLE9BQU8sUUFBUSxLQUFLLElBQUksT0FBTyxPQUFPLEtBQUssSUFBSSxPQUFPLEtBQUs7QUFDekUsNkJBQU87QUFDUCwyQkFBSzs7QUFHUCwyQkFBTztBQUVQLHdCQUFJLEtBQUssSUFBSSxPQUFPO0FBQUssNkJBQU87QUFDaEMseUJBQUs7QUFDTCw0QkFBUSxJQUFJOztBQUdkOztBQUdBLHVCQUFLOzs7QUFJWCxnQkFBTSxRQUFRLE1BQU0sS0FBSyxNQUFNLFNBQVM7QUFDeEMsaUJBQU8sY0FBYyxNQUFNLGNBQWMsS0FBSyxRQUFRLGFBQWEsZUFBZTs7QUFHcEYsb0NBQTRCLE9BQU8sS0FBSztBQUN0QyxjQUFJLElBQUksYUFBYTtBQUNuQixnQkFBSSxLQUFLLEtBQUs7QUFBUSxxQkFBTyxtQkFBbUIsT0FBTztpQkFDbEQ7QUFFTCxnQkFBSSxrQkFBa0IsS0FBSztBQUFRLHFCQUFPLG1CQUFtQixPQUFPOztBQUd0RSxnQkFBTSxTQUFTLElBQUksVUFBVyx3QkFBdUIsU0FBUyxPQUFPO0FBQ3JFLGdCQUFNLE1BQU0sTUFBTSxNQUFNLFFBQVEsTUFBTSxNQUFNLFFBQVEsUUFBUTtFQUFPLFlBQVk7QUFDL0UsaUJBQU8sSUFBSSxjQUFjLE1BQU0sY0FBYyxLQUFLLFFBQVEsV0FBVyxlQUFlOztBQUd0Riw2QkFBcUI7VUFDbkI7VUFDQTtVQUNBO1dBQ0MsS0FBSyxXQUFXLGFBQWE7QUFHOUIsY0FBSSxZQUFZLEtBQUssVUFBVSxRQUFRLEtBQUssUUFBUTtBQUNsRCxtQkFBTyxtQkFBbUIsT0FBTzs7QUFHbkMsZ0JBQU0sU0FBUyxJQUFJLFVBQVcsS0FBSSxvQkFBb0IsdUJBQXVCLFNBQVMsT0FBTztBQUM3RixnQkFBTSxhQUFhLFNBQVMsTUFBTTtBQUVsQyxnQkFBTSxVQUFVLFNBQVMsV0FBVyxLQUFLLGVBQWUsUUFBUSxTQUFTLFdBQVcsS0FBSyxnQkFBZ0IsT0FBTyxDQUFDLG9CQUFvQixPQUFPLFdBQVcsS0FBSyxXQUFXLE9BQU87QUFDOUssY0FBSSxTQUFTLFVBQVUsTUFBTTtBQUM3QixjQUFJLENBQUM7QUFBTyxtQkFBTyxTQUFTO0FBQzVCLGNBQUksVUFBVTtBQUNkLGNBQUksUUFBUTtBQUNaLGtCQUFRLE1BQU0sUUFBUSxhQUFhLENBQUEsT0FBTTtBQUN2QyxrQkFBTSxJQUFJLEdBQUcsUUFBUTtBQUVyQixnQkFBSSxNQUFNLElBQUk7QUFDWix3QkFBVTt1QkFDRCxVQUFVLE1BQU0sTUFBTSxHQUFHLFNBQVMsR0FBRztBQUM5Qyx3QkFBVTtBQUVWLGtCQUFJO0FBQWE7O0FBR25CLG9CQUFRLEdBQUcsUUFBUSxPQUFPO0FBQzFCLG1CQUFPO2FBQ04sUUFBUSxXQUFXLENBQUEsT0FBTTtBQUMxQixnQkFBSSxHQUFHLFFBQVEsU0FBUztBQUFJLHdCQUFVO0FBQ3RDLGtCQUFNLElBQUksR0FBRyxNQUFNO0FBRW5CLGdCQUFJLEdBQUc7QUFDTCx3QkFBVSxHQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUUsR0FBRztBQUM1QixxQkFBTyxFQUFFO21CQUNKO0FBQ0wsd0JBQVU7QUFDVixxQkFBTzs7O0FBR1gsY0FBSTtBQUFPLG9CQUFRLE1BQU0sUUFBUSxnQkFBZ0IsS0FBSztBQUN0RCxjQUFJO0FBQVMsc0JBQVUsUUFBUSxRQUFRLFFBQVEsS0FBSztBQUVwRCxjQUFJLFNBQVM7QUFDWCxzQkFBVSxPQUFPLFFBQVEsUUFBUSxjQUFjO0FBQy9DLGdCQUFJO0FBQVc7O0FBR2pCLGNBQUksQ0FBQztBQUFPLG1CQUFPLEdBQUcsU0FBUztFQUFlLFNBQVM7QUFFdkQsY0FBSSxTQUFTO0FBQ1gsb0JBQVEsTUFBTSxRQUFRLFFBQVEsS0FBSztBQUNuQyxtQkFBTyxHQUFHO0VBQVcsU0FBUyxVQUFVLFFBQVE7O0FBR2xELGtCQUFRLE1BQU0sUUFBUSxRQUFRLFFBQVEsUUFBUSxrREFBa0QsUUFFL0YsUUFBUSxRQUFRLEtBQUs7QUFDdEIsZ0JBQU0sT0FBTyxjQUFjLEdBQUcsVUFBVSxRQUFRLFNBQVMsUUFBUSxZQUFZLFdBQVc7QUFDeEYsaUJBQU8sR0FBRztFQUFXLFNBQVM7O0FBR2hDLDZCQUFxQixNQUFNLEtBQUssV0FBVyxhQUFhO0FBQ3RELGdCQUFNO1lBQ0o7WUFDQTtZQUNBO2NBQ0U7QUFDSixnQkFBTTtZQUNKO1lBQ0E7WUFDQTtZQUNBO2NBQ0U7QUFFSixjQUFJLGVBQWUsYUFBYSxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssUUFBUTtBQUMvRSxtQkFBTyxtQkFBbUIsT0FBTzs7QUFHbkMsY0FBSSxDQUFDLFNBQVMsb0ZBQW9GLEtBQUssUUFBUTtBQU83RyxtQkFBTyxlQUFlLFVBQVUsTUFBTSxRQUFRLFVBQVUsS0FBSyxNQUFNLFFBQVEsU0FBUyxNQUFNLE1BQU0sUUFBUSxTQUFTLEtBQUssbUJBQW1CLE9BQU8sT0FBTyxtQkFBbUIsT0FBTyxPQUFPLFlBQVksTUFBTSxLQUFLLFdBQVc7O0FBRzVOLGNBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxTQUFTLFdBQVcsS0FBSyxTQUFTLE1BQU0sUUFBUSxVQUFVLElBQUk7QUFFM0YsbUJBQU8sWUFBWSxNQUFNLEtBQUssV0FBVzs7QUFHM0MsY0FBSSxXQUFXLE1BQU0sdUJBQXVCLFFBQVE7QUFDbEQsZ0JBQUksbUJBQW1CO0FBQ3ZCLG1CQUFPLFlBQVksTUFBTSxLQUFLLFdBQVc7O0FBRzNDLGdCQUFNLE1BQU0sTUFBTSxRQUFRLFFBQVE7RUFBTztBQUl6QyxjQUFJLGNBQWM7QUFDaEIsa0JBQU07Y0FDSjtnQkFDRSxJQUFJLElBQUk7QUFDWixrQkFBTSxXQUFXLGNBQWMsS0FBSyxNQUFNLEtBQUssZ0JBQWdCO0FBQy9ELGdCQUFJLE9BQU8sYUFBYTtBQUFVLHFCQUFPLG1CQUFtQixPQUFPOztBQUdyRSxnQkFBTSxPQUFPLGNBQWMsTUFBTSxjQUFjLEtBQUssUUFBUSxXQUFXLGVBQWU7QUFFdEYsY0FBSSxXQUFXLENBQUMsVUFBVyxNQUFLLFFBQVEsVUFBVSxNQUFNLFFBQVEsUUFBUSxVQUFVLEtBQUs7QUFDckYsZ0JBQUk7QUFBVztBQUNmLG1CQUFPLGlCQUFpQixNQUFNLFFBQVE7O0FBR3hDLGlCQUFPOztBQUdULGlDQUF5QixNQUFNLEtBQUssV0FBVyxhQUFhO0FBQzFELGdCQUFNO1lBQ0o7Y0FDRTtBQUNKLGdCQUFNO1lBQ0o7WUFDQTtjQUNFO0FBQ0osY0FBSTtZQUNGO1lBQ0E7Y0FDRTtBQUVKLGNBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0Isb0JBQVEsT0FBTztBQUNmLG1CQUFPLE9BQU8sT0FBTyxJQUFJLE1BQU07Y0FDN0I7OztBQUlKLGdCQUFNLGFBQWEsQ0FBQSxVQUFTO0FBQzFCLG9CQUFRO21CQUNELFdBQVcsS0FBSzttQkFDaEIsV0FBVyxLQUFLO0FBQ25CLHVCQUFPLFlBQVksTUFBTSxLQUFLLFdBQVc7bUJBRXRDLFdBQVcsS0FBSztBQUNuQix1QkFBTyxtQkFBbUIsT0FBTzttQkFFOUIsV0FBVyxLQUFLO0FBQ25CLHVCQUFPLG1CQUFtQixPQUFPO21CQUU5QixXQUFXLEtBQUs7QUFDbkIsdUJBQU8sWUFBWSxNQUFNLEtBQUssV0FBVzs7QUFHekMsdUJBQU87OztBQUliLGNBQUksU0FBUyxXQUFXLEtBQUssZ0JBQWdCLGdDQUFnQyxLQUFLLFFBQVE7QUFFeEYsbUJBQU8sV0FBVyxLQUFLO3FCQUNiLGdCQUFlLFdBQVksVUFBUyxXQUFXLEtBQUssZ0JBQWdCLFNBQVMsV0FBVyxLQUFLLGdCQUFnQjtBQUV2SCxtQkFBTyxXQUFXLEtBQUs7O0FBR3pCLGNBQUksTUFBTSxXQUFXO0FBRXJCLGNBQUksUUFBUSxNQUFNO0FBQ2hCLGtCQUFNLFdBQVc7QUFDakIsZ0JBQUksUUFBUTtBQUFNLG9CQUFNLElBQUksTUFBTSxtQ0FBbUM7O0FBR3ZFLGlCQUFPOztBQUdULGlDQUF5QjtVQUN2QjtVQUNBO1VBQ0E7VUFDQTtXQUNDO0FBQ0QsY0FBSSxPQUFPLFVBQVU7QUFBVSxtQkFBTyxPQUFPO0FBQzdDLGNBQUksQ0FBQyxTQUFTO0FBQVEsbUJBQU8sTUFBTSxTQUFTLFNBQVMsUUFBUSxJQUFJLFVBQVU7QUFDM0UsY0FBSSxJQUFJLEtBQUssVUFBVTtBQUV2QixjQUFJLENBQUMsVUFBVSxxQkFBc0IsRUFBQyxPQUFPLFFBQVEsOEJBQThCLE1BQU0sS0FBSyxJQUFJO0FBQ2hHLGdCQUFJLElBQUksRUFBRSxRQUFRO0FBRWxCLGdCQUFJLElBQUksR0FBRztBQUNULGtCQUFJLEVBQUU7QUFDTixtQkFBSzs7QUFHUCxnQkFBSSxJQUFJLG9CQUFxQixHQUFFLFNBQVMsSUFBSTtBQUU1QyxtQkFBTyxNQUFNO0FBQUcsbUJBQUs7O0FBR3ZCLGlCQUFPOztBQUdULHdDQUFnQyxRQUFRLEtBQUs7QUFDM0MsY0FBSSxNQUFNO0FBRVYsa0JBQVEsSUFBSTtpQkFDTCxXQUFXLEtBQUs7QUFDbkIscUJBQU87QUFDUCxxQkFBTztBQUNQO2lCQUVHLFdBQVcsS0FBSztBQUNuQixxQkFBTztBQUNQLHFCQUFPO0FBQ1A7O0FBR0EscUJBQU8sS0FBSyxJQUFJLFdBQVcsa0JBQWtCLEtBQUs7QUFDbEQ7O0FBR0osY0FBSTtBQUVKLG1CQUFTLElBQUksSUFBSSxNQUFNLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQzlDLGtCQUFNLE9BQU8sSUFBSSxNQUFNO0FBRXZCLGdCQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsV0FBVyxLQUFLLFNBQVM7QUFDbEQseUJBQVc7QUFDWDs7O0FBSUosY0FBSSxZQUFZLFNBQVMsU0FBUyxNQUFNO0FBQ3RDLGtCQUFNLE1BQU0sWUFBWSxvQkFBb0I7QUFDNUMsZ0JBQUk7QUFFSixnQkFBSSxPQUFPLFNBQVMsV0FBVyxVQUFVO0FBQ3ZDLG9CQUFNLElBQUksV0FBVyxrQkFBa0IsS0FBSztBQUM1QyxrQkFBSSxTQUFTLFNBQVMsU0FBUzttQkFDMUI7QUFDTCxvQkFBTSxJQUFJLFdBQVcsa0JBQWtCLFVBQVU7QUFDakQsa0JBQUksU0FBUyxTQUFTLFNBQVMsTUFBTTtBQUFLLG9CQUFJLFNBQVMsU0FBUyxNQUFNLE1BQU0sU0FBUyxNQUFNOztBQUc3RixtQkFBTyxLQUFLOzs7QUFHaEIsdUNBQStCLFFBQVEsU0FBUztBQUM5QyxnQkFBTSxPQUFPLFFBQVEsUUFBUSxJQUFJLFFBQVEsTUFBTSxRQUFRO0FBRXZELGNBQUksU0FBUyxRQUFRLFNBQVMsT0FBUSxTQUFTLEtBQUs7QUFDbEQsa0JBQU0sTUFBTTtBQUNaLG1CQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixTQUFTOzs7QUFHMUQsaUNBQXlCLFFBQVEsS0FBSztBQUNwQyxnQkFBTSxLQUFLLE9BQU87QUFDbEIsZ0JBQU0sSUFBSSxHQUFHLE9BQU8sR0FBRyxLQUFLLFFBQVEsR0FBRyxPQUFPO0FBQzlDLGlCQUFPLElBQUksV0FBVyxrQkFBa0IsUUFBUSxRQUFROztBQUUxRCxpQ0FBeUIsWUFBWSxVQUFVO0FBQzdDLHFCQUFXO1lBQ1Q7WUFDQTtZQUNBO2VBQ0csVUFBVTtBQUNiLGdCQUFJLE9BQU8sV0FBVyxNQUFNO0FBRTVCLGdCQUFJLENBQUMsTUFBTTtBQUNULGtCQUFJLFlBQVksUUFBVztBQUN6QixvQkFBSSxXQUFXO0FBQVMsNkJBQVcsV0FBVyxPQUFPOztBQUFhLDZCQUFXLFVBQVU7O21CQUVwRjtBQUNMLGtCQUFJLFlBQVksS0FBSztBQUFPLHVCQUFPLEtBQUs7QUFFeEMsa0JBQUksWUFBWSxRQUFXO0FBQ3pCLG9CQUFJLFlBQVksQ0FBQyxLQUFLO0FBQWUsdUJBQUssY0FBYztxQkFDbkQ7QUFDTCxvQkFBSSxLQUFLO0FBQWUsdUJBQUssaUJBQWlCLE9BQU87O0FBQWEsdUJBQUssZ0JBQWdCOzs7OztBQU8vRiwrQkFBdUIsS0FBSyxNQUFNO0FBQ2hDLGdCQUFNLE1BQU0sS0FBSztBQUNqQixjQUFJLENBQUM7QUFBSyxtQkFBTztBQUNqQixjQUFJLE9BQU8sUUFBUTtBQUFVLG1CQUFPO0FBQ3BDLGNBQUksT0FBTyxRQUFRLENBQUEsVUFBUztBQUMxQixnQkFBSSxDQUFDLE1BQU07QUFBUSxvQkFBTSxTQUFTO0FBQ2xDLGdCQUFJLE9BQU8sS0FBSzs7QUFFbEIsaUJBQU8sSUFBSTs7QUFHYixrQ0FBMEIsS0FBSyxNQUFNO0FBQ25DLGdCQUFNO1lBQ0o7WUFDQTtjQUNFLEtBQUs7QUFDVCxjQUFJLFNBQVMsSUFBSSxZQUFZLEtBQUssQ0FBQSxNQUFLLEVBQUUsV0FBVztBQUVwRCxjQUFJLENBQUMsUUFBUTtBQUNYLGtCQUFNLE1BQU0sSUFBSSxjQUFjO0FBQzlCLGdCQUFJO0FBQUssdUJBQVMsSUFBSSxLQUFLLENBQUEsTUFBSyxFQUFFLFdBQVc7QUFDN0MsZ0JBQUksQ0FBQztBQUFRLG9CQUFNLElBQUksV0FBVyxrQkFBa0IsTUFBTSxPQUFPOztBQUduRSxjQUFJLENBQUM7QUFBUSxrQkFBTSxJQUFJLFdBQVcsa0JBQWtCLE1BQU0sT0FBTztBQUVqRSxjQUFJLFdBQVcsT0FBUSxLQUFJLFdBQVcsSUFBSSxRQUFRLGFBQWEsT0FBTztBQUNwRSxnQkFBSSxPQUFPLE9BQU8sS0FBSztBQUNyQixrQkFBSSxTQUFTLEtBQUssSUFBSSxXQUFXLFlBQVksTUFBTTtBQUNuRCxxQkFBTzs7QUFHVCxnQkFBSSxPQUFPLEtBQUssU0FBUztBQUV2QixvQkFBTSxRQUFRLE9BQU8sTUFBTTtBQUMzQixxQkFBTyxRQUFRLE9BQU8sTUFBTSxvQkFBb0IsTUFBTSxPQUFPLE9BQU87OztBQUl4RSxpQkFBTyxPQUFPLFNBQVMsbUJBQW1COztBQUc1QyxnQ0FBd0IsS0FBSyxNQUFNO0FBQ2pDLGdCQUFNO1lBQ0o7WUFDQTtjQUNFO0FBQ0osY0FBSSxjQUFjO0FBRWxCLGNBQUksS0FBSztBQUNQLGtCQUFNO2NBQ0o7Y0FDQTtjQUNBO2dCQUNFO0FBRUosZ0JBQUksVUFBVTtBQUNaLGtCQUFJLGFBQWEsT0FBTyxhQUFhO0FBQU0sdUJBQU87QUFDbEQsb0JBQU0sTUFBTSxxQ0FBcUM7QUFDakQsa0JBQUksT0FBTyxLQUFLLElBQUksV0FBVyxrQkFBa0IsTUFBTTt1QkFDOUMsV0FBVyxPQUFPLENBQUMsUUFBUTtBQUNwQyw0QkFBYzttQkFDVDtBQUNMLGtCQUFJO0FBQ0YsdUJBQU8saUJBQWlCLEtBQUs7dUJBQ3RCLE9BRHNCO0FBRTdCLG9CQUFJLE9BQU8sS0FBSzs7OztBQUt0QixrQkFBUTtpQkFDRCxXQUFXLEtBQUs7aUJBQ2hCLFdBQVcsS0FBSztpQkFDaEIsV0FBVyxLQUFLO2lCQUNoQixXQUFXLEtBQUs7QUFDbkIscUJBQU8sV0FBVyxZQUFZO2lCQUUzQixXQUFXLEtBQUs7aUJBQ2hCLFdBQVcsS0FBSztBQUNuQixxQkFBTyxXQUFXLFlBQVk7aUJBRTNCLFdBQVcsS0FBSztpQkFDaEIsV0FBVyxLQUFLO0FBQ25CLHFCQUFPLFdBQVcsWUFBWTtpQkFFM0IsV0FBVyxLQUFLO0FBQ25CLHFCQUFPLGNBQWMsV0FBVyxZQUFZLE1BQU07O0FBR2xELHFCQUFPOzs7QUFJYixrQ0FBMEIsS0FBSyxNQUFNLFNBQVM7QUFDNUMsZ0JBQU07WUFDSjtjQUNFLElBQUk7QUFDUixnQkFBTSxnQkFBZ0I7QUFFdEIscUJBQVcsT0FBTyxNQUFNO0FBQ3RCLGdCQUFJLElBQUksUUFBUSxTQUFTO0FBQ3ZCLGtCQUFJLElBQUk7QUFBTSw4QkFBYyxLQUFLO21CQUFVO0FBQ3pDLHNCQUFNLE1BQU0sSUFBSSxRQUFRLEtBQUs7QUFDN0IsdUJBQU8sZUFBZSxhQUFhLE1BQU0sSUFBSSxPQUFPOzs7O0FBSzFELGdCQUFNLE1BQU0sY0FBYyxLQUFLO0FBQy9CLGNBQUksT0FBTyxRQUFRLFlBQVksY0FBYyxTQUFTO0FBQUcsbUJBQU8sY0FBYyxLQUFLLGVBQWUsS0FBSztBQUN2RyxpQkFBTzs7QUFHVCxvQ0FBNEI7VUFDMUI7V0FDQztBQUNELGtCQUFRO2lCQUNELFdBQVcsS0FBSztpQkFDaEIsV0FBVyxLQUFLO0FBQ25CLHFCQUFPLFdBQVcsWUFBWTtpQkFFM0IsV0FBVyxLQUFLO2lCQUNoQixXQUFXLEtBQUs7QUFDbkIscUJBQU8sV0FBVyxZQUFZOztBQUc5QixxQkFBTyxXQUFXLFlBQVk7OztBQUlwQyw0QkFBb0IsS0FBSyxNQUFNLFNBQVM7QUFDdEMsY0FBSTtBQUNGLGtCQUFNLE1BQU0saUJBQWlCLEtBQUssTUFBTTtBQUV4QyxnQkFBSSxLQUFLO0FBQ1Asa0JBQUksV0FBVyxLQUFLO0FBQUssb0JBQUksTUFBTTtBQUNuQyxxQkFBTzs7bUJBRUYsT0FGRTtBQUlULGdCQUFJLENBQUMsTUFBTTtBQUFRLG9CQUFNLFNBQVM7QUFDbEMsZ0JBQUksT0FBTyxLQUFLO0FBQ2hCLG1CQUFPOztBQUdULGNBQUk7QUFDRixrQkFBTSxXQUFXLG1CQUFtQjtBQUNwQyxnQkFBSSxDQUFDO0FBQVUsb0JBQU0sSUFBSSxNQUFNLFdBQVc7QUFDMUMsa0JBQU0sTUFBTSxXQUFXLDJDQUEyQztBQUNsRSxnQkFBSSxTQUFTLEtBQUssSUFBSSxXQUFXLFlBQVksTUFBTTtBQUNuRCxrQkFBTSxNQUFNLGlCQUFpQixLQUFLLE1BQU07QUFDeEMsZ0JBQUksTUFBTTtBQUNWLG1CQUFPO21CQUNBLE9BREE7QUFFUCxrQkFBTSxXQUFXLElBQUksV0FBVyxtQkFBbUIsTUFBTSxNQUFNO0FBQy9ELHFCQUFTLFFBQVEsTUFBTTtBQUN2QixnQkFBSSxPQUFPLEtBQUs7QUFDaEIsbUJBQU87OztBQUlYLFlBQU0sbUJBQW1CLENBQUEsU0FBUTtBQUMvQixjQUFJLENBQUM7QUFBTSxtQkFBTztBQUNsQixnQkFBTTtZQUNKO2NBQ0U7QUFDSixpQkFBTyxTQUFTLFdBQVcsS0FBSyxXQUFXLFNBQVMsV0FBVyxLQUFLLGFBQWEsU0FBUyxXQUFXLEtBQUs7O0FBRzVHLGtDQUEwQixRQUFRLE1BQU07QUFDdEMsZ0JBQU0sV0FBVztZQUNmLFFBQVE7WUFDUixPQUFPOztBQUVULGNBQUksWUFBWTtBQUNoQixjQUFJLFNBQVM7QUFDYixnQkFBTSxRQUFRLGlCQUFpQixLQUFLLFFBQVEsVUFBVSxLQUFLLFFBQVEsT0FBTyxNQUFNLE9BQU8sS0FBSyxTQUFTLEtBQUs7QUFFMUcscUJBQVc7WUFDVDtZQUNBO2VBQ0csT0FBTztBQUNWLG9CQUFRLEtBQUssUUFBUSxJQUFJO21CQUNsQixXQUFXLEtBQUssU0FDbkI7QUFDRSxvQkFBSSxDQUFDLEtBQUssNkJBQTZCLFFBQVE7QUFDN0Msd0JBQU0sTUFBTTtBQUNaLHlCQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixNQUFNOztBQUdyRCxzQkFBTTtrQkFDSjtrQkFDQTtvQkFDRTtBQUNKLHNCQUFNLEtBQUssY0FBZSxTQUFRLFdBQVcsU0FBUyxVQUFVLFFBQVEsT0FBTyxTQUFTLFNBQVMsUUFBUSxTQUFTO0FBQ2xILG1CQUFHLEtBQUssS0FBSyxRQUFRLElBQUksTUFBTSxRQUFRLEdBQUc7QUFDMUM7O21CQUlDLFdBQVcsS0FBSztBQUNuQixvQkFBSSxXQUFXO0FBQ2Isd0JBQU0sTUFBTTtBQUNaLHlCQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixNQUFNOztBQUdyRCw0QkFBWTtBQUNaO21CQUVHLFdBQVcsS0FBSztBQUNuQixvQkFBSSxRQUFRO0FBQ1Ysd0JBQU0sTUFBTTtBQUNaLHlCQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixNQUFNOztBQUdyRCx5QkFBUztBQUNUOzs7QUFJTixpQkFBTztZQUNMO1lBQ0E7WUFDQTs7O0FBSUosa0NBQTBCLEtBQUssTUFBTTtBQUNuQyxnQkFBTTtZQUNKO1lBQ0E7WUFDQTtjQUNFO0FBRUosY0FBSSxLQUFLLFNBQVMsV0FBVyxLQUFLLE9BQU87QUFDdkMsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLE1BQU0sUUFBUSxRQUFRO0FBRTVCLGdCQUFJLENBQUMsS0FBSztBQUNSLG9CQUFNLE1BQU0sNkJBQTZCO0FBQ3pDLHFCQUFPLEtBQUssSUFBSSxXQUFXLG1CQUFtQixNQUFNO0FBQ3BELHFCQUFPOztBQUlULGtCQUFNLE1BQU0sSUFBSSxNQUFNO0FBRXRCLG9CQUFRLFlBQVksS0FBSztBQUV6QixtQkFBTzs7QUFHVCxnQkFBTSxVQUFVLGVBQWUsS0FBSztBQUNwQyxjQUFJO0FBQVMsbUJBQU8sV0FBVyxLQUFLLE1BQU07QUFFMUMsY0FBSSxLQUFLLFNBQVMsV0FBVyxLQUFLLE9BQU87QUFDdkMsa0JBQU0sTUFBTSxxQkFBcUIsS0FBSztBQUN0QyxtQkFBTyxLQUFLLElBQUksV0FBVyxnQkFBZ0IsTUFBTTtBQUNqRCxtQkFBTzs7QUFHVCxjQUFJO0FBQ0Ysa0JBQU0sTUFBTSxjQUFjLEtBQUs7QUFDL0IsbUJBQU8sY0FBYyxLQUFLLE9BQU8sTUFBTSxPQUFPLEtBQUs7bUJBQzVDLE9BRDRDO0FBRW5ELGdCQUFJLENBQUMsTUFBTTtBQUFRLG9CQUFNLFNBQVM7QUFDbEMsbUJBQU8sS0FBSztBQUNaLG1CQUFPOzs7QUFLWCw2QkFBcUIsS0FBSyxNQUFNO0FBQzlCLGNBQUksQ0FBQztBQUFNLG1CQUFPO0FBQ2xCLGNBQUksS0FBSztBQUFPLGdCQUFJLE9BQU8sS0FBSyxLQUFLO0FBQ3JDLGdCQUFNO1lBQ0o7WUFDQTtZQUNBO2NBQ0UsaUJBQWlCLElBQUksUUFBUTtBQUVqQyxjQUFJLFdBQVc7QUFDYixrQkFBTTtjQUNKO2dCQUNFO0FBQ0osa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLE9BQU8sUUFBUSxRQUFRO0FBRzdCLGdCQUFJO0FBQU0sc0JBQVEsSUFBSSxRQUFRLFFBQVEsU0FBUztBQUkvQyxvQkFBUSxJQUFJLFFBQVE7O0FBR3RCLGNBQUksS0FBSyxTQUFTLFdBQVcsS0FBSyxTQUFVLGNBQWEsU0FBUztBQUNoRSxrQkFBTSxNQUFNO0FBQ1osZ0JBQUksT0FBTyxLQUFLLElBQUksV0FBVyxrQkFBa0IsTUFBTTs7QUFHekQsZ0JBQU0sTUFBTSxpQkFBaUIsS0FBSztBQUVsQyxjQUFJLEtBQUs7QUFDUCxnQkFBSSxRQUFRLENBQUMsS0FBSyxNQUFNLE9BQU8sS0FBSyxNQUFNO0FBQzFDLGdCQUFJLElBQUksUUFBUTtBQUFjLGtCQUFJLFVBQVU7QUFDNUMsZ0JBQUksSUFBSSxRQUFRO0FBQWUsa0JBQUksT0FBTyxLQUFLO0FBQy9DLGtCQUFNLEtBQUssU0FBUyxPQUFPLEtBQUs7QUFFaEMsZ0JBQUksSUFBSTtBQUNOLGtCQUFJLGdCQUFnQixJQUFJLGdCQUFnQixHQUFHLElBQUk7RUFBa0IsT0FBTzs7QUFHMUUsa0JBQU0sS0FBSyxTQUFTLE1BQU0sS0FBSztBQUMvQixnQkFBSTtBQUFJLGtCQUFJLFVBQVUsSUFBSSxVQUFVLEdBQUcsSUFBSTtFQUFZLE9BQU87O0FBR2hFLGlCQUFPLEtBQUssV0FBVzs7QUFHekIsNEJBQW9CLEtBQUssS0FBSztBQUM1QixjQUFJLElBQUksU0FBUyxXQUFXLEtBQUssT0FBTyxJQUFJLFNBQVMsV0FBVyxLQUFLLFVBQVU7QUFDN0Usa0JBQU0sTUFBTSxLQUFLLElBQUk7QUFDckIsZ0JBQUksT0FBTyxLQUFLLElBQUksV0FBVyxnQkFBZ0IsS0FBSztBQUNwRCxtQkFBTzs7QUFHVCxnQkFBTTtZQUNKO1lBQ0E7Y0FDRSxJQUFJLFNBQVMsV0FBVyxLQUFLLFdBQVcsb0JBQW9CLEtBQUssT0FBTyxxQkFBcUIsS0FBSztBQUN0RyxnQkFBTSxNQUFNLElBQUk7QUFDaEIsY0FBSSxRQUFRO0FBQ1osMEJBQWdCLEtBQUs7QUFDckIsY0FBSSxtQkFBbUI7QUFFdkIsbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEVBQUUsR0FBRztBQUNyQyxrQkFBTTtjQUNKLEtBQUs7Z0JBQ0gsTUFBTTtBQUNWLGdCQUFJLGdCQUFnQjtBQUFZLGlDQUFtQjtBQUVuRCxnQkFBSSxJQUFJLE9BQU8sU0FBUyxRQUFRLEtBQUssVUFBVSxXQUFXO0FBQ3hELG9CQUFNLEtBQUssSUFBSSxNQUFNLE1BQU07QUFDM0Isb0JBQU0sVUFBVSxNQUFNLEdBQUcsTUFBTTtBQUMvQixrQkFBSSxRQUFRO0FBQ1osc0JBQVEsS0FBSyxDQUFBLFNBQVE7QUFDbkIsb0JBQUksZ0JBQWdCLE9BQU87QUFHekIsd0JBQU07b0JBQ0o7c0JBQ0UsS0FBSztBQUNULHNCQUFJLFNBQVMsV0FBVyxLQUFLLE9BQU8sU0FBUyxXQUFXLEtBQUs7QUFBVSwyQkFBTztBQUM5RSx5QkFBTyxRQUFROztBQUdqQix1QkFBTyxRQUFROztBQUVqQixrQkFBSTtBQUFPLG9CQUFJLE9BQU8sS0FBSyxJQUFJLFdBQVcsa0JBQWtCLEtBQUs7bUJBQzVEO0FBQ0wsdUJBQVMsSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3pDLHNCQUFNO2tCQUNKLEtBQUs7b0JBQ0gsTUFBTTtBQUVWLG9CQUFJLFNBQVMsUUFBUSxRQUFRLFFBQVEsT0FBTyxVQUFVLGVBQWUsS0FBSyxNQUFNLFlBQVksS0FBSyxVQUFVLEtBQUssT0FBTztBQUNySCx3QkFBTSxNQUFNLDZCQUE2QjtBQUN6QyxzQkFBSSxPQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixLQUFLO0FBQ3REOzs7OztBQU1SLGNBQUksb0JBQW9CLENBQUMsSUFBSSxRQUFRLFVBQVU7QUFDN0Msa0JBQU0sT0FBTztBQUNiLGdCQUFJLFNBQVMsS0FBSyxJQUFJLFdBQVcsWUFBWSxLQUFLOztBQUdwRCxjQUFJLFdBQVc7QUFDZixpQkFBTzs7QUFHVCxZQUFNLHNCQUFzQixDQUFDO1VBQzNCLFNBQVM7WUFDUDtZQUNBO1lBQ0E7O1VBRUY7Y0FDSTtBQUNKLGNBQUksTUFBTSxXQUFXO0FBQUcsbUJBQU87QUFDL0IsZ0JBQU07WUFDSjtjQUNFLE1BQU07QUFDVixjQUFJLFFBQVEsUUFBUSxLQUFLLFdBQVc7QUFBTyxtQkFBTztBQUNsRCxjQUFJLElBQUksV0FBVyxXQUFXLEtBQUs7QUFBUyxtQkFBTztBQUVuRCxtQkFBUyxJQUFJLFdBQVcsSUFBSSxPQUFPLEVBQUU7QUFBRyxnQkFBSSxJQUFJLE9BQU87QUFBTSxxQkFBTztBQUVwRSxpQkFBTzs7QUFHVCxvQ0FBNEIsTUFBTSxNQUFNO0FBQ3RDLGNBQUksQ0FBQyxvQkFBb0I7QUFBTztBQUNoQyxnQkFBTSxVQUFVLEtBQUssYUFBYSxHQUFHLFdBQVcsS0FBSyxTQUFTO0FBQzlELGNBQUksUUFBUTtBQUNaLGdCQUFNLEtBQUssS0FBSyxNQUFNO0FBRXRCLGNBQUksTUFBTSxHQUFHLFdBQVcsVUFBVTtBQUNoQyxpQkFBSyxNQUFNLGdCQUFnQixHQUFHLE9BQU8sUUFBUSxTQUFTO0FBQ3RELG9CQUFRO2lCQUNIO0FBQ0wsa0JBQU0sS0FBSyxLQUFLLE1BQU07QUFFdEIsZ0JBQUksQ0FBQyxLQUFLLFFBQVEsTUFBTSxHQUFHLFdBQVcsVUFBVTtBQUM5QyxtQkFBSyxNQUFNLFVBQVUsR0FBRyxPQUFPLFFBQVEsU0FBUztBQUNoRCxzQkFBUTs7O0FBSVosY0FBSTtBQUFPLGlCQUFLLFVBQVU7O0FBRzVCLHNDQUE4QixLQUFLLEtBQUs7QUFDdEMsZ0JBQU0sV0FBVztBQUNqQixnQkFBTSxRQUFRO0FBQ2QsY0FBSSxNQUFNO0FBQ1YsY0FBSSxXQUFXO0FBRWYsbUJBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3pDLGtCQUFNLE9BQU8sSUFBSSxNQUFNO0FBRXZCLG9CQUFRLEtBQUs7bUJBQ04sV0FBVyxLQUFLO0FBQ25CLHlCQUFTLEtBQUs7a0JBQ1osVUFBVSxDQUFDLENBQUM7a0JBQ1osUUFBUSxNQUFNOztBQUVoQjttQkFFRyxXQUFXLEtBQUs7QUFDbkIseUJBQVMsS0FBSztrQkFDWixVQUFVLENBQUMsQ0FBQztrQkFDWixRQUFRLE1BQU07a0JBQ2QsU0FBUyxLQUFLOztBQUVoQjttQkFFRyxXQUFXLEtBQUs7QUFDbkIsb0JBQUksUUFBUTtBQUFXLHdCQUFNLEtBQUssSUFBSSxLQUFLO0FBQzNDLG9CQUFJLEtBQUs7QUFBTyxzQkFBSSxPQUFPLEtBQUssS0FBSztBQUNyQyxzQkFBTSxZQUFZLEtBQUssS0FBSztBQUM1QiwyQkFBVztBQUNYO21CQUVHLFdBQVcsS0FBSztBQUNuQjtBQUNFLHNCQUFJLFFBQVE7QUFBVywwQkFBTTtBQUM3QixzQkFBSSxLQUFLO0FBQU8sd0JBQUksT0FBTyxLQUFLLEtBQUs7QUFFckMsc0JBQUksQ0FBQyxLQUFLLFFBQVEsZUFBZSxLQUFLLFFBQVEsS0FBSyxLQUFLLFNBQVMsV0FBVyxLQUFLLE9BQU8sQ0FBQyxLQUFLLEtBQUssUUFBUSxhQUFhO0FBQ3RILDBCQUFNLE1BQU07QUFDWix3QkFBSSxPQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixLQUFLLE1BQU07O0FBRzlELHNCQUFJLFlBQVksS0FBSztBQUVyQixzQkFBSSxDQUFDLGFBQWEsS0FBSyxNQUFNLFNBQVMsR0FBRztBQUl2QyxnQ0FBWSxJQUFJLFdBQVcsV0FBVyxXQUFXLEtBQUssT0FBTztBQUM3RCw4QkFBVSxVQUFVO3NCQUNsQixRQUFRO3NCQUNSLEtBQUssS0FBSyxRQUFROztBQUVwQiwwQkFBTSxNQUFNLEtBQUssTUFBTSxRQUFRO0FBQy9CLDhCQUFVLFFBQVE7c0JBQ2hCLE9BQU87c0JBQ1AsS0FBSzs7QUFFUCw4QkFBVSxhQUFhO3NCQUNyQixPQUFPO3NCQUNQLEtBQUs7O0FBR1Asd0JBQUksT0FBTyxLQUFLLE1BQU0sY0FBYyxVQUFVO0FBQzVDLDRCQUFNLFVBQVUsS0FBSyxNQUFNLFlBQVk7QUFDdkMsZ0NBQVUsTUFBTSxZQUFZLFVBQVUsTUFBTSxVQUFVO0FBQ3RELGdDQUFVLFdBQVcsWUFBWSxVQUFVLFdBQVcsVUFBVTs7O0FBSXBFLHdCQUFNLE9BQU8sSUFBSSxLQUFLLEtBQUssWUFBWSxLQUFLO0FBQzVDLHFDQUFtQixNQUFNO0FBQ3pCLHdCQUFNLEtBQUs7QUFFWCxzQkFBSSxPQUFPLE9BQU8sYUFBYSxVQUFVO0FBQ3ZDLHdCQUFJLEtBQUssTUFBTSxRQUFRLFdBQVc7QUFBTSwwQkFBSSxPQUFPLEtBQUssZ0JBQWdCLEtBQUs7O0FBRy9FLHdCQUFNO0FBQ04sNkJBQVc7O0FBRWI7O0FBR0Esb0JBQUksUUFBUTtBQUFXLHdCQUFNLEtBQUssSUFBSSxLQUFLO0FBQzNDLHNCQUFNLFlBQVksS0FBSztBQUN2QiwyQkFBVyxLQUFLLE1BQU07QUFDdEIsb0JBQUksS0FBSztBQUFPLHNCQUFJLE9BQU8sS0FBSyxLQUFLO0FBRXJDO0FBQU0sMkJBQVMsSUFBSSxJQUFJLEtBQUksRUFBRSxHQUFHO0FBQzlCLDBCQUFNLFdBQVcsSUFBSSxNQUFNO0FBRTNCLDRCQUFRLFlBQVksU0FBUzsyQkFDdEIsV0FBVyxLQUFLOzJCQUNoQixXQUFXLEtBQUs7QUFDbkI7MkJBRUcsV0FBVyxLQUFLO0FBQ25COytCQUdBO0FBQ0UsOEJBQU0sTUFBTTtBQUNaLDRCQUFJLE9BQU8sS0FBSyxJQUFJLFdBQVcsa0JBQWtCLE1BQU07QUFDdkQ7Ozs7QUFLUixvQkFBSSxLQUFLLDJCQUEyQjtBQUNsQyx3QkFBTSxNQUFNO0FBQ1osc0JBQUksT0FBTyxLQUFLLElBQUksV0FBVyxrQkFBa0IsTUFBTTs7OztBQU0vRCxjQUFJLFFBQVE7QUFBVyxrQkFBTSxLQUFLLElBQUksS0FBSztBQUMzQyxpQkFBTztZQUNMO1lBQ0E7OztBQUlKLHFDQUE2QixLQUFLLEtBQUs7QUFDckMsZ0JBQU0sV0FBVztBQUNqQixnQkFBTSxRQUFRO0FBQ2QsY0FBSSxNQUFNO0FBQ1YsY0FBSSxjQUFjO0FBQ2xCLGNBQUksT0FBTztBQUVYLG1CQUFTLElBQUksR0FBRyxJQUFJLElBQUksTUFBTSxRQUFRLEVBQUUsR0FBRztBQUN6QyxrQkFBTSxPQUFPLElBQUksTUFBTTtBQUV2QixnQkFBSSxPQUFPLEtBQUssU0FBUyxVQUFVO0FBQ2pDLG9CQUFNO2dCQUNKO2dCQUNBO2tCQUNFO0FBRUosa0JBQUksU0FBUyxPQUFPLFFBQVEsVUFBYSxDQUFDLGFBQWE7QUFDckQsOEJBQWM7QUFDZCx1QkFBTztBQUNQOztBQUdGLGtCQUFJLFNBQVMsS0FBSztBQUNoQixvQkFBSSxRQUFRO0FBQVcsd0JBQU07QUFFN0Isb0JBQUksU0FBUyxLQUFLO0FBQ2hCLHlCQUFPO0FBQ1A7O3FCQUVHO0FBQ0wsb0JBQUksYUFBYTtBQUNmLHNCQUFJLFFBQVEsVUFBYSxTQUFTO0FBQUssMEJBQU07QUFDN0MsZ0NBQWM7O0FBR2hCLG9CQUFJLFFBQVEsUUFBVztBQUNyQix3QkFBTSxLQUFLLElBQUksS0FBSztBQUNwQix3QkFBTTtBQUVOLHNCQUFJLFNBQVMsS0FBSztBQUNoQiwyQkFBTztBQUNQOzs7O0FBS04sa0JBQUksU0FBUyxLQUFLO0FBQ2hCLG9CQUFJLE1BQU0sSUFBSSxNQUFNLFNBQVM7QUFBRzt5QkFDdkIsU0FBUyxNQUFNO0FBQ3hCLHVCQUFPO0FBQ1A7O0FBR0Ysb0JBQU0sTUFBTSxtQ0FBbUM7QUFDL0Msb0JBQU0sTUFBTSxJQUFJLFdBQVcsZ0JBQWdCLEtBQUs7QUFDaEQsa0JBQUksU0FBUztBQUNiLGtCQUFJLE9BQU8sS0FBSzt1QkFDUCxLQUFLLFNBQVMsV0FBVyxLQUFLLFlBQVk7QUFDbkQsdUJBQVMsS0FBSztnQkFDWixVQUFVLENBQUMsQ0FBQztnQkFDWixRQUFRLE1BQU07O3VCQUVQLEtBQUssU0FBUyxXQUFXLEtBQUssU0FBUztBQUNoRCxvQ0FBc0IsSUFBSSxRQUFRO0FBQ2xDLHVCQUFTLEtBQUs7Z0JBQ1osVUFBVSxDQUFDLENBQUM7Z0JBQ1osUUFBUSxNQUFNO2dCQUNkLFNBQVMsS0FBSzs7dUJBRVAsUUFBUSxRQUFXO0FBQzVCLGtCQUFJLFNBQVM7QUFBSyxvQkFBSSxPQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixNQUFNO0FBQ3pFLG9CQUFNLFlBQVksS0FBSzttQkFDbEI7QUFDTCxrQkFBSSxTQUFTO0FBQUssb0JBQUksT0FBTyxLQUFLLElBQUksV0FBVyxrQkFBa0IsTUFBTTtBQUN6RSxvQkFBTSxLQUFLLElBQUksS0FBSyxLQUFLLFlBQVksS0FBSztBQUMxQyxvQkFBTTtBQUNOLDRCQUFjOzs7QUFJbEIsaUNBQXVCLElBQUksUUFBUTtBQUNuQyxjQUFJLFFBQVE7QUFBVyxrQkFBTSxLQUFLLElBQUksS0FBSztBQUMzQyxpQkFBTztZQUNMO1lBQ0E7OztBQUlKLDRCQUFvQixLQUFLLEtBQUs7QUFDNUIsY0FBSSxJQUFJLFNBQVMsV0FBVyxLQUFLLE9BQU8sSUFBSSxTQUFTLFdBQVcsS0FBSyxVQUFVO0FBQzdFLGtCQUFNLE1BQU0sS0FBSyxJQUFJO0FBQ3JCLGdCQUFJLE9BQU8sS0FBSyxJQUFJLFdBQVcsZ0JBQWdCLEtBQUs7QUFDcEQsbUJBQU87O0FBR1QsZ0JBQU07WUFDSjtZQUNBO2NBQ0UsSUFBSSxTQUFTLFdBQVcsS0FBSyxXQUFXLG9CQUFvQixLQUFLLE9BQU8scUJBQXFCLEtBQUs7QUFDdEcsZ0JBQU0sTUFBTSxJQUFJO0FBQ2hCLGNBQUksUUFBUTtBQUNaLDBCQUFnQixLQUFLO0FBRXJCLGNBQUksQ0FBQyxJQUFJLFFBQVEsWUFBWSxNQUFNLEtBQUssQ0FBQSxPQUFNLGNBQWMsUUFBUSxHQUFHLGVBQWUsYUFBYTtBQUNqRyxrQkFBTSxPQUFPO0FBQ2IsZ0JBQUksU0FBUyxLQUFLLElBQUksV0FBVyxZQUFZLEtBQUs7O0FBR3BELGNBQUksV0FBVztBQUNmLGlCQUFPOztBQUdULHNDQUE4QixLQUFLLEtBQUs7QUFDdEMsZ0JBQU0sV0FBVztBQUNqQixnQkFBTSxRQUFRO0FBRWQsbUJBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3pDLGtCQUFNLE9BQU8sSUFBSSxNQUFNO0FBRXZCLG9CQUFRLEtBQUs7bUJBQ04sV0FBVyxLQUFLO0FBQ25CLHlCQUFTLEtBQUs7a0JBQ1osUUFBUSxNQUFNOztBQUVoQjttQkFFRyxXQUFXLEtBQUs7QUFDbkIseUJBQVMsS0FBSztrQkFDWixTQUFTLEtBQUs7a0JBQ2QsUUFBUSxNQUFNOztBQUVoQjttQkFFRyxXQUFXLEtBQUs7QUFDbkIsb0JBQUksS0FBSztBQUFPLHNCQUFJLE9BQU8sS0FBSyxLQUFLO0FBQ3JDLHNCQUFNLEtBQUssWUFBWSxLQUFLLEtBQUs7QUFFakMsb0JBQUksS0FBSyxVQUFVO0FBQ2pCLHdCQUFNLE1BQU07QUFDWixzQkFBSSxPQUFPLEtBQUssSUFBSSxXQUFXLGtCQUFrQixNQUFNOztBQUd6RDs7QUFHQSxvQkFBSSxLQUFLO0FBQU8sc0JBQUksT0FBTyxLQUFLLEtBQUs7QUFDckMsb0JBQUksT0FBTyxLQUFLLElBQUksV0FBVyxnQkFBZ0IsTUFBTSxjQUFjLEtBQUs7OztBQUk5RSxpQkFBTztZQUNMO1lBQ0E7OztBQUlKLHFDQUE2QixLQUFLLEtBQUs7QUFDckMsZ0JBQU0sV0FBVztBQUNqQixnQkFBTSxRQUFRO0FBQ2QsY0FBSSxjQUFjO0FBQ2xCLGNBQUksTUFBTTtBQUNWLGNBQUksV0FBVztBQUNmLGNBQUksT0FBTztBQUNYLGNBQUksV0FBVztBQUVmLG1CQUFTLElBQUksR0FBRyxJQUFJLElBQUksTUFBTSxRQUFRLEVBQUUsR0FBRztBQUN6QyxrQkFBTSxPQUFPLElBQUksTUFBTTtBQUV2QixnQkFBSSxPQUFPLEtBQUssU0FBUyxVQUFVO0FBQ2pDLG9CQUFNO2dCQUNKO2dCQUNBO2tCQUNFO0FBRUosa0JBQUksU0FBUyxPQUFRLGdCQUFlLFFBQVEsU0FBWTtBQUN0RCxvQkFBSSxlQUFlLFFBQVE7QUFBVyx3QkFBTSxPQUFPLE1BQU0sUUFBUTtBQUNqRSxzQkFBTSxLQUFLLElBQUksS0FBSztBQUNwQiw4QkFBYztBQUNkLHNCQUFNO0FBQ04sMkJBQVc7O0FBR2Isa0JBQUksU0FBUyxNQUFNO0FBQ2pCLHVCQUFPO3lCQUNFLENBQUMsUUFBUSxTQUFTLEtBQUs7QUFDaEMsOEJBQWM7eUJBQ0wsU0FBUyxPQUFPLFNBQVMsT0FBTyxRQUFRLFFBQVc7QUFDNUQsb0JBQUksU0FBUyxLQUFLO0FBQ2hCLHdCQUFNLE1BQU07QUFFWixzQkFBSSxlQUFlLE1BQU07QUFDdkIsMEJBQU0sTUFBTTtBQUNaLDBCQUFNLE1BQU0sSUFBSSxXQUFXLGtCQUFrQixLQUFLO0FBQ2xELHdCQUFJLFNBQVM7QUFDYix3QkFBSSxPQUFPLEtBQUs7O0FBR2xCLHNCQUFJLENBQUMsZUFBZSxPQUFPLGFBQWEsVUFBVTtBQUNoRCwwQkFBTSxTQUFTLEtBQUssUUFBUSxLQUFLLE1BQU0sUUFBUSxLQUFLO0FBQ3BELHdCQUFJLFNBQVMsV0FBVztBQUFNLDBCQUFJLE9BQU8sS0FBSyxnQkFBZ0IsS0FBSztBQUNuRSwwQkFBTTtzQkFDSjt3QkFDRSxTQUFTO0FBRWIsNkJBQVMsS0FBSSxVQUFVLEtBQUksUUFBUSxFQUFFO0FBQUcsMEJBQUksSUFBSSxRQUFPLE1BQU07QUFDM0QsOEJBQU0sTUFBTTtBQUNaLDRCQUFJLE9BQU8sS0FBSyxJQUFJLFdBQVcsa0JBQWtCLFVBQVU7QUFDM0Q7Ozt1QkFHQztBQUNMLHdCQUFNOztBQUdSLDJCQUFXO0FBQ1gsOEJBQWM7QUFDZCx1QkFBTzt5QkFDRSxTQUFTLE9BQU8sU0FBUyxPQUFPLElBQUksSUFBSSxNQUFNLFNBQVMsR0FBRztBQUNuRSxzQkFBTSxNQUFNLHdDQUF3QztBQUNwRCxzQkFBTSxNQUFNLElBQUksV0FBVyxnQkFBZ0IsS0FBSztBQUNoRCxvQkFBSSxTQUFTO0FBQ2Isb0JBQUksT0FBTyxLQUFLOzt1QkFFVCxLQUFLLFNBQVMsV0FBVyxLQUFLLFlBQVk7QUFDbkQsdUJBQVMsS0FBSztnQkFDWixRQUFRLE1BQU07O3VCQUVQLEtBQUssU0FBUyxXQUFXLEtBQUssU0FBUztBQUNoRCxvQ0FBc0IsSUFBSSxRQUFRO0FBQ2xDLHVCQUFTLEtBQUs7Z0JBQ1osU0FBUyxLQUFLO2dCQUNkLFFBQVEsTUFBTTs7bUJBRVg7QUFDTCxrQkFBSSxNQUFNO0FBQ1Isc0JBQU0sTUFBTSxjQUFjO0FBQzFCLG9CQUFJLE9BQU8sS0FBSyxJQUFJLFdBQVcsa0JBQWtCLE1BQU07O0FBR3pELG9CQUFNLFFBQVEsWUFBWSxLQUFLO0FBRS9CLGtCQUFJLFFBQVEsUUFBVztBQUNyQixzQkFBTSxLQUFLO0FBQ1gsMkJBQVc7cUJBQ047QUFDTCxzQkFBTSxLQUFLLElBQUksS0FBSyxLQUFLO0FBQ3pCLHNCQUFNOztBQUdSLHlCQUFXLEtBQUssTUFBTTtBQUN0QixxQkFBTzs7O0FBSVgsaUNBQXVCLElBQUksUUFBUTtBQUNuQyxjQUFJLFFBQVE7QUFBVyxrQkFBTSxLQUFLLElBQUksS0FBSztBQUMzQyxpQkFBTztZQUNMO1lBQ0E7OztBQUlKLGlCQUFRLFFBQVE7QUFDaEIsaUJBQVEsYUFBYTtBQUNyQixpQkFBUSxRQUFRO0FBQ2hCLGlCQUFRLE9BQU87QUFDZixpQkFBUSxPQUFPO0FBQ2YsaUJBQVEsU0FBUztBQUNqQixpQkFBUSxVQUFVO0FBQ2xCLGlCQUFRLFVBQVU7QUFDbEIsaUJBQVEsYUFBYTtBQUNyQixpQkFBUSxnQkFBZ0I7QUFDeEIsaUJBQVEsY0FBYztBQUN0QixpQkFBUSxXQUFXO0FBQ25CLGlCQUFRLGFBQWE7QUFDckIsaUJBQVEsY0FBYztBQUN0QixpQkFBUSxjQUFjO0FBQ3RCLGlCQUFRLGFBQWE7QUFDckIsaUJBQVEsY0FBYztBQUN0QixpQkFBUSxhQUFhO0FBQ3JCLGlCQUFRLGdCQUFnQjtBQUN4QixpQkFBUSxhQUFhO0FBQ3JCLGlCQUFRLGtCQUFrQjtBQUMxQixpQkFBUSxrQkFBa0I7QUFDMUIsaUJBQVEsU0FBUzs7O0FDaG5FakIsUUFBQSw0QkFBQSxZQUFBO01BQUEsOENBQUEsVUFBQTtBQUFBO0FBRUEsWUFBSSxhQUFhO0FBQ2pCLFlBQUksYUFBYTtBQUdqQixZQUFNLFNBQVM7VUFDYixVQUFVLENBQUEsVUFBUyxpQkFBaUI7VUFFcEMsU0FBUztVQUNULEtBQUs7VUFVTCxTQUFTLENBQUMsS0FBSyxTQUFTO0FBQ3RCLGtCQUFNLE1BQU0sV0FBVyxjQUFjLEtBQUs7QUFFMUMsZ0JBQUksT0FBTyxXQUFXLFlBQVk7QUFDaEMscUJBQU8sT0FBTyxLQUFLLEtBQUs7dUJBQ2YsT0FBTyxTQUFTLFlBQVk7QUFFckMsb0JBQU0sTUFBTSxLQUFLLElBQUksUUFBUSxXQUFXO0FBQ3hDLG9CQUFNLFNBQVMsSUFBSSxXQUFXLElBQUk7QUFFbEMsdUJBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUU7QUFBRyx1QkFBTyxLQUFLLElBQUksV0FBVztBQUVoRSxxQkFBTzttQkFDRjtBQUNMLG9CQUFNLE1BQU07QUFDWixrQkFBSSxPQUFPLEtBQUssSUFBSSxXQUFXLG1CQUFtQixNQUFNO0FBQ3hELHFCQUFPOzs7VUFHWCxTQUFTLFdBQVc7VUFDcEIsV0FBVyxDQUFDO1lBQ1Y7WUFDQTtZQUNBO2FBQ0MsS0FBSyxXQUFXLGdCQUFnQjtBQUNqQyxnQkFBSTtBQUVKLGdCQUFJLE9BQU8sV0FBVyxZQUFZO0FBQ2hDLG9CQUFNLGlCQUFpQixTQUFTLE1BQU0sU0FBUyxZQUFZLE9BQU8sS0FBSyxNQUFNLFFBQVEsU0FBUzt1QkFDckYsT0FBTyxTQUFTLFlBQVk7QUFDckMsa0JBQUksSUFBSTtBQUVSLHVCQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxFQUFFO0FBQUcscUJBQUssT0FBTyxhQUFhLE1BQU07QUFFdEUsb0JBQU0sS0FBSzttQkFDTjtBQUNMLG9CQUFNLElBQUksTUFBTTs7QUFHbEIsZ0JBQUksQ0FBQztBQUFNLHFCQUFPLFdBQVcsY0FBYztBQUUzQyxnQkFBSSxTQUFTLFdBQVcsS0FBSyxjQUFjO0FBQ3pDLHNCQUFRO21CQUNIO0FBQ0wsb0JBQU07Z0JBQ0o7a0JBQ0UsV0FBVztBQUNmLG9CQUFNLElBQUksS0FBSyxLQUFLLElBQUksU0FBUztBQUNqQyxvQkFBTSxRQUFRLElBQUksTUFBTTtBQUV4Qix1QkFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsS0FBSyxXQUFXO0FBQ2pELHNCQUFNLEtBQUssSUFBSSxPQUFPLEdBQUc7O0FBRzNCLHNCQUFRLE1BQU0sS0FBSyxTQUFTLFdBQVcsS0FBSyxnQkFBZ0IsT0FBTzs7QUFHckUsbUJBQU8sV0FBVyxnQkFBZ0I7Y0FDaEM7Y0FDQTtjQUNBO2VBQ0MsS0FBSyxXQUFXOzs7QUFJdkIsNEJBQW9CLEtBQUssS0FBSztBQUM1QixnQkFBTSxNQUFNLFdBQVcsV0FBVyxLQUFLO0FBRXZDLG1CQUFTLElBQUksR0FBRyxJQUFJLElBQUksTUFBTSxRQUFRLEVBQUUsR0FBRztBQUN6QyxnQkFBSSxPQUFPLElBQUksTUFBTTtBQUNyQixnQkFBSSxnQkFBZ0IsV0FBVztBQUFNO3FCQUFrQixnQkFBZ0IsV0FBVyxTQUFTO0FBQ3pGLGtCQUFJLEtBQUssTUFBTSxTQUFTLEdBQUc7QUFDekIsc0JBQU0sTUFBTTtBQUNaLHNCQUFNLElBQUksV0FBVyxrQkFBa0IsS0FBSzs7QUFHOUMsb0JBQU0sT0FBTyxLQUFLLE1BQU0sTUFBTSxJQUFJLFdBQVc7QUFDN0Msa0JBQUksS0FBSztBQUFlLHFCQUFLLGdCQUFnQixLQUFLLGdCQUFnQixHQUFHLEtBQUs7RUFBa0IsS0FBSyxrQkFBa0IsS0FBSztBQUN4SCxrQkFBSSxLQUFLO0FBQVMscUJBQUssVUFBVSxLQUFLLFVBQVUsR0FBRyxLQUFLO0VBQVksS0FBSyxZQUFZLEtBQUs7QUFDMUYscUJBQU87O0FBRVQsZ0JBQUksTUFBTSxLQUFLLGdCQUFnQixXQUFXLE9BQU8sT0FBTyxJQUFJLFdBQVcsS0FBSzs7QUFHOUUsaUJBQU87O0FBRVQsNkJBQXFCLFFBQVEsVUFBVSxLQUFLO0FBQzFDLGdCQUFNLFNBQVEsSUFBSSxXQUFXLFFBQVE7QUFDckMsaUJBQU0sTUFBTTtBQUVaLHFCQUFXLE1BQU0sVUFBVTtBQUN6QixnQkFBSSxLQUFLO0FBRVQsZ0JBQUksTUFBTSxRQUFRLEtBQUs7QUFDckIsa0JBQUksR0FBRyxXQUFXLEdBQUc7QUFDbkIsc0JBQU0sR0FBRztBQUNULHdCQUFRLEdBQUc7O0FBQ04sc0JBQU0sSUFBSSxVQUFVLGdDQUFnQzt1QkFDbEQsTUFBTSxjQUFjLFFBQVE7QUFDckMsb0JBQU0sT0FBTyxPQUFPLEtBQUs7QUFFekIsa0JBQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsc0JBQU0sS0FBSztBQUNYLHdCQUFRLEdBQUc7O0FBQ04sc0JBQU0sSUFBSSxVQUFVLGtDQUFrQzttQkFDeEQ7QUFDTCxvQkFBTTs7QUFHUixrQkFBTSxPQUFPLE9BQU8sV0FBVyxLQUFLLE9BQU87QUFDM0MsbUJBQU0sTUFBTSxLQUFLOztBQUduQixpQkFBTzs7QUFFVCxZQUFNLFFBQVE7VUFDWixTQUFTO1VBQ1QsS0FBSztVQUNMLFNBQVM7VUFDVCxZQUFZOztBQUdkLFlBQUEsV0FBQSxjQUF1QixXQUFXLFFBQVE7VUFDeEMsY0FBYztBQUNaO0FBRUEsdUJBQVcsZ0JBQWdCLE1BQU0sT0FBTyxXQUFXLFFBQVEsVUFBVSxJQUFJLEtBQUs7QUFFOUUsdUJBQVcsZ0JBQWdCLE1BQU0sVUFBVSxXQUFXLFFBQVEsVUFBVSxPQUFPLEtBQUs7QUFFcEYsdUJBQVcsZ0JBQWdCLE1BQU0sT0FBTyxXQUFXLFFBQVEsVUFBVSxJQUFJLEtBQUs7QUFFOUUsdUJBQVcsZ0JBQWdCLE1BQU0sT0FBTyxXQUFXLFFBQVEsVUFBVSxJQUFJLEtBQUs7QUFFOUUsdUJBQVcsZ0JBQWdCLE1BQU0sT0FBTyxXQUFXLFFBQVEsVUFBVSxJQUFJLEtBQUs7QUFFOUUsaUJBQUssTUFBTSxTQUFTOztVQUd0QixPQUFPLEdBQUcsS0FBSztBQUNiLGtCQUFNLE1BQU0sSUFBSTtBQUNoQixnQkFBSSxPQUFPLElBQUk7QUFBVSxrQkFBSSxTQUFTO0FBRXRDLHVCQUFXLFFBQVEsS0FBSyxPQUFPO0FBQzdCLGtCQUFJLEtBQUs7QUFFVCxrQkFBSSxnQkFBZ0IsV0FBVyxNQUFNO0FBQ25DLHNCQUFNLFdBQVcsT0FBTyxLQUFLLEtBQUssSUFBSTtBQUN0Qyx3QkFBUSxXQUFXLE9BQU8sS0FBSyxPQUFPLEtBQUs7cUJBQ3RDO0FBQ0wsc0JBQU0sV0FBVyxPQUFPLE1BQU0sSUFBSTs7QUFHcEMsa0JBQUksSUFBSSxJQUFJO0FBQU0sc0JBQU0sSUFBSSxNQUFNO0FBQ2xDLGtCQUFJLElBQUksS0FBSzs7QUFHZixtQkFBTzs7O0FBS1gsbUJBQVcsZ0JBQWdCLFVBQVUsT0FBTztBQUU1QywyQkFBbUIsS0FBSyxLQUFLO0FBQzNCLGdCQUFNLFNBQVEsV0FBVyxLQUFLO0FBQzlCLGdCQUFNLFdBQVc7QUFFakIscUJBQVc7WUFDVDtlQUNHLE9BQU0sT0FBTztBQUNoQixnQkFBSSxlQUFlLFdBQVcsUUFBUTtBQUNwQyxrQkFBSSxTQUFTLFNBQVMsSUFBSSxRQUFRO0FBQ2hDLHNCQUFNLE1BQU07QUFDWixzQkFBTSxJQUFJLFdBQVcsa0JBQWtCLEtBQUs7cUJBQ3ZDO0FBQ0wseUJBQVMsS0FBSyxJQUFJOzs7O0FBS3hCLGlCQUFPLE9BQU8sT0FBTyxJQUFJLFlBQVk7O0FBR3ZDLDRCQUFvQixRQUFRLFVBQVUsS0FBSztBQUN6QyxnQkFBTSxTQUFRLFlBQVksUUFBUSxVQUFVO0FBQzVDLGdCQUFNLFFBQU8sSUFBSTtBQUNqQixnQkFBSyxRQUFRLE9BQU07QUFDbkIsaUJBQU87O0FBR1QsWUFBTSxPQUFPO1VBQ1gsVUFBVSxDQUFBLFVBQVMsaUJBQWlCO1VBQ3BDLFdBQVc7VUFDWCxTQUFTO1VBQ1QsS0FBSztVQUNMLFNBQVM7VUFDVCxZQUFZOztBQUdkLFlBQUEsVUFBQSxjQUFzQixXQUFXLFFBQVE7VUFDdkMsY0FBYztBQUNaO0FBQ0EsaUJBQUssTUFBTSxRQUFROztVQUdyQixJQUFJLEtBQUs7QUFDUCxrQkFBTSxPQUFPLGVBQWUsV0FBVyxPQUFPLE1BQU0sSUFBSSxXQUFXLEtBQUs7QUFDeEUsa0JBQU0sT0FBTyxXQUFXLFNBQVMsS0FBSyxPQUFPLEtBQUs7QUFDbEQsZ0JBQUksQ0FBQztBQUFNLG1CQUFLLE1BQU0sS0FBSzs7VUFHN0IsSUFBSSxLQUFLLFVBQVU7QUFDakIsa0JBQU0sT0FBTyxXQUFXLFNBQVMsS0FBSyxPQUFPO0FBQzdDLG1CQUFPLENBQUMsWUFBWSxnQkFBZ0IsV0FBVyxPQUFPLEtBQUssZUFBZSxXQUFXLFNBQVMsS0FBSyxJQUFJLFFBQVEsS0FBSyxNQUFNOztVQUc1SCxJQUFJLEtBQUssT0FBTztBQUNkLGdCQUFJLE9BQU8sVUFBVTtBQUFXLG9CQUFNLElBQUksTUFBTSxpRUFBaUUsT0FBTztBQUN4SCxrQkFBTSxPQUFPLFdBQVcsU0FBUyxLQUFLLE9BQU87QUFFN0MsZ0JBQUksUUFBUSxDQUFDLE9BQU87QUFDbEIsbUJBQUssTUFBTSxPQUFPLEtBQUssTUFBTSxRQUFRLE9BQU87dUJBQ25DLENBQUMsUUFBUSxPQUFPO0FBQ3pCLG1CQUFLLE1BQU0sS0FBSyxJQUFJLFdBQVcsS0FBSzs7O1VBSXhDLE9BQU8sR0FBRyxLQUFLO0FBQ2IsbUJBQU8sTUFBTSxPQUFPLEdBQUcsS0FBSzs7VUFHOUIsU0FBUyxLQUFLLFdBQVcsYUFBYTtBQUNwQyxnQkFBSSxDQUFDO0FBQUsscUJBQU8sS0FBSyxVQUFVO0FBQ2hDLGdCQUFJLEtBQUs7QUFBb0IscUJBQU8sTUFBTSxTQUFTLEtBQUssV0FBVzs7QUFBa0Isb0JBQU0sSUFBSSxNQUFNOzs7QUFLekcsbUJBQVcsZ0JBQWdCLFNBQVMsT0FBTztBQUUzQywwQkFBa0IsS0FBSyxLQUFLO0FBQzFCLGdCQUFNLE1BQU0sV0FBVyxXQUFXLEtBQUs7QUFDdkMsY0FBSSxDQUFDLElBQUk7QUFBb0Isa0JBQU0sSUFBSSxXQUFXLGtCQUFrQixLQUFLO0FBQ3pFLGlCQUFPLE9BQU8sT0FBTyxJQUFJLFdBQVc7O0FBR3RDLDJCQUFtQixRQUFRLFVBQVUsS0FBSztBQUN4QyxnQkFBTSxPQUFNLElBQUk7QUFFaEIscUJBQVcsU0FBUztBQUFVLGlCQUFJLE1BQU0sS0FBSyxPQUFPLFdBQVcsT0FBTyxNQUFNO0FBRTVFLGlCQUFPOztBQUdULFlBQU0sTUFBTTtVQUNWLFVBQVUsQ0FBQSxVQUFTLGlCQUFpQjtVQUNwQyxXQUFXO1VBQ1gsU0FBUztVQUNULEtBQUs7VUFDTCxTQUFTO1VBQ1QsWUFBWTs7QUFHZCxZQUFNLG1CQUFtQixDQUFDLE1BQU0sVUFBVTtBQUN4QyxnQkFBTSxJQUFJLE1BQU0sTUFBTSxLQUFLLE9BQU8sQ0FBQyxJQUFHLE1BQU0sS0FBSSxLQUFLLE9BQU8sSUFBSTtBQUNoRSxpQkFBTyxTQUFTLE1BQU0sQ0FBQyxJQUFJOztBQUk3QixZQUFNLHVCQUF1QixDQUFDO1VBQzVCO2NBQ0k7QUFDSixjQUFJLE1BQU0sVUFBVSxDQUFDLFNBQVM7QUFBUSxtQkFBTyxXQUFXLGdCQUFnQjtBQUN4RSxjQUFJLE9BQU87QUFFWCxjQUFJLFFBQVEsR0FBRztBQUNiLG1CQUFPO0FBQ1Asb0JBQVEsS0FBSyxJQUFJOztBQUduQixnQkFBTSxRQUFRLENBQUMsUUFBUTtBQUV2QixjQUFJLFFBQVEsSUFBSTtBQUNkLGtCQUFNLFFBQVE7aUJBQ1Q7QUFDTCxvQkFBUSxLQUFLLE1BQU8sU0FBUSxNQUFNLE1BQU07QUFDeEMsa0JBQU0sUUFBUSxRQUFRO0FBRXRCLGdCQUFJLFNBQVMsSUFBSTtBQUNmLHNCQUFRLEtBQUssTUFBTyxTQUFRLE1BQU0sTUFBTTtBQUN4QyxvQkFBTSxRQUFROzs7QUFJbEIsaUJBQU8sT0FBTyxNQUFNLElBQUksQ0FBQSxNQUFLLElBQUksS0FBSyxNQUFNLE9BQU8sS0FBSyxPQUFPLElBQUksS0FBSyxLQUFLLFFBQVEsY0FBYzs7QUFJckcsWUFBTSxVQUFVO1VBQ2QsVUFBVSxDQUFBLFVBQVMsT0FBTyxVQUFVO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBQ0wsUUFBUTtVQUNSLE1BQU07VUFDTixTQUFTLENBQUMsS0FBSyxNQUFNLFVBQVUsaUJBQWlCLE1BQU0sTUFBTSxRQUFRLE1BQU07VUFDMUUsV0FBVzs7QUFFYixZQUFNLFlBQVk7VUFDaEIsVUFBVSxDQUFBLFVBQVMsT0FBTyxVQUFVO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBQ0wsUUFBUTtVQUNSLE1BQU07VUFDTixTQUFTLENBQUMsS0FBSyxNQUFNLFVBQVUsaUJBQWlCLE1BQU0sTUFBTSxRQUFRLE1BQU07VUFDMUUsV0FBVzs7QUFFYixZQUFNLFlBQVk7VUFDaEIsVUFBVSxDQUFBLFVBQVMsaUJBQWlCO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBSUwsTUFBTSxPQUFPO1VBS2IsU0FBUyxDQUFDLEtBQUssTUFBTSxPQUFPLEtBQUssTUFBTSxRQUFRLFFBQVEsVUFBVSxPQUFPO0FBQ3RFLGdCQUFJO0FBQVUseUJBQVksWUFBVyxNQUFNLE9BQU8sR0FBRztBQUNyRCxnQkFBSSxPQUFPLEtBQUssSUFBSSxNQUFNLFFBQVEsR0FBRyxLQUFLLFFBQVEsR0FBRyxVQUFVLEdBQUcsVUFBVSxHQUFHLFlBQVk7QUFFM0YsZ0JBQUksTUFBTSxPQUFPLEtBQUs7QUFDcEIsa0JBQUksSUFBSSxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsTUFBTTtBQUN6QyxrQkFBSSxLQUFLLElBQUksS0FBSztBQUFJLHFCQUFLO0FBQzNCLHNCQUFRLE1BQVE7O0FBR2xCLG1CQUFPLElBQUksS0FBSzs7VUFFbEIsV0FBVyxDQUFDO1lBQ1Y7Z0JBQ0ksTUFBTSxjQUFjLFFBQVEsMEJBQTBCOztBQUk5RCw0QkFBb0IsYUFBYTtBQUMvQixnQkFBTSxNQUFNLE9BQU8sWUFBWSxlQUFlLFFBQVEsT0FBTztBQUU3RCxjQUFJLGFBQWE7QUFDZixnQkFBSSxPQUFPLHNDQUFzQztBQUFhLHFCQUFPLENBQUM7QUFDdEUsbUJBQU8sQ0FBQyxJQUFJOztBQUdkLGNBQUksT0FBTywwQkFBMEI7QUFBYSxtQkFBTyxDQUFDO0FBQzFELGlCQUFPLENBQUMsSUFBSTs7QUFHZCxzQkFBYyxTQUFTLE1BQU07QUFDM0IsY0FBSSxXQUFXLFFBQVE7QUFDckIsa0JBQU0sT0FBTyxPQUFPLFlBQVksZUFBZSxRQUFRO0FBR3ZELGdCQUFJO0FBQU0sbUJBQUssU0FBUztpQkFBVztBQUVqQyxzQkFBUSxLQUFLLE9BQU8sR0FBRyxTQUFTLFlBQVk7Ozs7QUFJbEQscUNBQTZCLFVBQVU7QUFDckMsY0FBSSxXQUFXLE9BQU87QUFDcEIsa0JBQU0sT0FBTyxTQUFTLFFBQVEsZ0JBQWdCLElBQUksUUFBUSxTQUFTLElBQUksUUFBUSxPQUFPO0FBQ3RGLGlCQUFLLHNCQUFzQiw4Q0FBOEM7OztBQUc3RSxZQUFNLFNBQVM7QUFDZix1Q0FBK0IsTUFBTSxhQUFhO0FBQ2hELGNBQUksQ0FBQyxPQUFPLFNBQVMsV0FBVyxPQUFPO0FBQ3JDLG1CQUFPLFFBQVE7QUFDZixnQkFBSSxNQUFNLGVBQWU7QUFDekIsbUJBQU8sY0FBYyxVQUFVLDBCQUEwQjtBQUN6RCxpQkFBSyxLQUFLOzs7QUFJZCxpQkFBUSxTQUFTO0FBQ2pCLGlCQUFRLFlBQVk7QUFDcEIsaUJBQVEsVUFBVTtBQUNsQixpQkFBUSxPQUFPO0FBQ2YsaUJBQVEsUUFBUTtBQUNoQixpQkFBUSxNQUFNO0FBQ2QsaUJBQVEsWUFBWTtBQUNwQixpQkFBUSxPQUFPO0FBQ2YsaUJBQVEsc0JBQXNCO0FBQzlCLGlCQUFRLHdCQUF3Qjs7O0FDL1poQyxRQUFBLDBCQUFBLFlBQUE7TUFBQSw0Q0FBQSxVQUFBO0FBQUE7QUFFQSxZQUFJLGFBQWE7QUFDakIsWUFBSSxhQUFhO0FBQ2pCLFlBQUksV0FBVztBQUVmLDJCQUFtQixRQUFRLEtBQUssS0FBSztBQUNuQyxnQkFBTSxPQUFNLElBQUksV0FBVyxRQUFRO0FBRW5DLGNBQUksZUFBZSxLQUFLO0FBQ3RCLHVCQUFXLENBQUMsS0FBSyxVQUFVO0FBQUssbUJBQUksTUFBTSxLQUFLLE9BQU8sV0FBVyxLQUFLLE9BQU87cUJBQ3BFLE9BQU8sT0FBTyxRQUFRLFVBQVU7QUFDekMsdUJBQVcsT0FBTyxPQUFPLEtBQUs7QUFBTSxtQkFBSSxNQUFNLEtBQUssT0FBTyxXQUFXLEtBQUssSUFBSSxNQUFNOztBQUd0RixjQUFJLE9BQU8sT0FBTyxtQkFBbUIsWUFBWTtBQUMvQyxpQkFBSSxNQUFNLEtBQUssT0FBTzs7QUFHeEIsaUJBQU87O0FBR1QsWUFBTSxNQUFNO1VBQ1YsWUFBWTtVQUNaLFNBQVM7VUFDVCxXQUFXLFdBQVc7VUFDdEIsS0FBSztVQUNMLFNBQVMsV0FBVzs7QUFHdEIsMkJBQW1CLFFBQVEsS0FBSyxLQUFLO0FBQ25DLGdCQUFNLE9BQU0sSUFBSSxXQUFXLFFBQVE7QUFFbkMsY0FBSSxPQUFPLElBQUksT0FBTyxXQUFXO0FBQy9CLHVCQUFXLE1BQU0sS0FBSztBQUNwQixvQkFBTSxJQUFJLE9BQU8sV0FBVyxJQUFJLElBQUksYUFBYSxNQUFNO0FBQ3ZELG1CQUFJLE1BQU0sS0FBSzs7O0FBSW5CLGlCQUFPOztBQUdULFlBQU0sTUFBTTtVQUNWLFlBQVk7VUFDWixTQUFTO1VBQ1QsV0FBVyxXQUFXO1VBQ3RCLEtBQUs7VUFDTCxTQUFTLFdBQVc7O0FBR3RCLFlBQU0sU0FBUztVQUNiLFVBQVUsQ0FBQSxVQUFTLE9BQU8sVUFBVTtVQUNwQyxTQUFTO1VBQ1QsS0FBSztVQUNMLFNBQVMsV0FBVztVQUVwQixVQUFVLE1BQU0sS0FBSyxXQUFXLGFBQWE7QUFDM0Msa0JBQU0sT0FBTyxPQUFPO2NBQ2xCLGNBQWM7ZUFDYjtBQUNILG1CQUFPLFdBQVcsZ0JBQWdCLE1BQU0sS0FBSyxXQUFXOztVQUcxRCxTQUFTLFdBQVc7O0FBR3RCLFlBQU0sV0FBVyxDQUFDLEtBQUssS0FBSztBQUk1QixZQUFNLGdCQUFnQixDQUFBLFVBQVMsT0FBTyxVQUFVLFlBQVksT0FBTyxVQUFVO0FBRTdFLFlBQU0sZUFBZSxDQUFDLEtBQUssTUFBTSxVQUFVLFdBQVcsV0FBVyxXQUFXLE9BQU8sT0FBTyxTQUFTLE1BQU07QUFFekcsZ0NBQXdCLE1BQU0sT0FBTyxRQUFRO0FBQzNDLGdCQUFNO1lBQ0o7Y0FDRTtBQUNKLGNBQUksY0FBYyxVQUFVLFNBQVM7QUFBRyxtQkFBTyxTQUFTLE1BQU0sU0FBUztBQUN2RSxpQkFBTyxXQUFXLGdCQUFnQjs7QUFHcEMsWUFBTSxVQUFVO1VBQ2QsVUFBVSxDQUFBLFVBQVMsU0FBUztVQUM1QixZQUFZLENBQUMsUUFBUSxPQUFPLFFBQVEsSUFBSSxjQUFjLElBQUksV0FBVyxPQUFPLFFBQVE7VUFDcEYsU0FBUztVQUNULEtBQUs7VUFDTCxNQUFNO1VBQ04sU0FBUyxNQUFNO1VBQ2YsU0FBUyxXQUFXO1VBQ3BCLFdBQVcsTUFBTSxXQUFXLFlBQVk7O0FBRTFDLFlBQU0sVUFBVTtVQUNkLFVBQVUsQ0FBQSxVQUFTLE9BQU8sVUFBVTtVQUNwQyxTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLENBQUEsUUFBTyxJQUFJLE9BQU8sT0FBTyxJQUFJLE9BQU87VUFDN0MsU0FBUyxXQUFXO1VBQ3BCLFdBQVcsQ0FBQztZQUNWO2dCQUNJLFFBQVEsV0FBVyxZQUFZLFVBQVUsV0FBVyxZQUFZOztBQUV4RSxZQUFNLFNBQVM7VUFDYixVQUFVLENBQUEsVUFBUyxjQUFjLFVBQVUsU0FBUztVQUNwRCxTQUFTO1VBQ1QsS0FBSztVQUNMLFFBQVE7VUFDUixNQUFNO1VBQ04sU0FBUyxDQUFDLEtBQUssUUFBUSxhQUFhLEtBQUssS0FBSztVQUM5QyxTQUFTLFdBQVc7VUFDcEIsV0FBVyxDQUFBLFNBQVEsZUFBZSxNQUFNLEdBQUc7O0FBRTdDLFlBQU0sU0FBUztVQUNiLFVBQVU7VUFDVixTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLENBQUEsUUFBTyxhQUFhLEtBQUssS0FBSztVQUN2QyxTQUFTLFdBQVc7VUFDcEIsV0FBVyxXQUFXOztBQUV4QixZQUFNLFNBQVM7VUFDYixVQUFVLENBQUEsVUFBUyxjQUFjLFVBQVUsU0FBUztVQUNwRCxTQUFTO1VBQ1QsS0FBSztVQUNMLFFBQVE7VUFDUixNQUFNO1VBQ04sU0FBUyxDQUFDLEtBQUssUUFBUSxhQUFhLEtBQUssS0FBSztVQUM5QyxTQUFTLFdBQVc7VUFDcEIsV0FBVyxDQUFBLFNBQVEsZUFBZSxNQUFNLElBQUk7O0FBRTlDLFlBQU0sU0FBUztVQUNiLFVBQVUsQ0FBQSxVQUFTLE9BQU8sVUFBVTtVQUNwQyxTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLENBQUMsS0FBSyxRQUFRLE1BQU0sTUFBTSxJQUFJLE9BQU8sTUFBTSxPQUFPLG9CQUFvQixPQUFPO1VBQ3RGLFdBQVcsV0FBVzs7QUFFeEIsWUFBTSxTQUFTO1VBQ2IsVUFBVSxDQUFBLFVBQVMsT0FBTyxVQUFVO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBQ0wsUUFBUTtVQUNSLE1BQU07VUFDTixTQUFTLENBQUEsUUFBTyxXQUFXO1VBQzNCLFdBQVcsQ0FBQztZQUNWO2dCQUNJLE9BQU8sT0FBTzs7QUFFdEIsWUFBTSxXQUFXO1VBQ2YsVUFBVSxDQUFBLFVBQVMsT0FBTyxVQUFVO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBQ0wsTUFBTTtVQUVOLFFBQVEsS0FBSyxPQUFPLE9BQU87QUFDekIsa0JBQU0sT0FBTyxTQUFTO0FBQ3RCLGtCQUFNLE9BQU8sSUFBSSxXQUFXLE9BQU8sV0FBVztBQUM5QyxnQkFBSSxRQUFRLEtBQUssS0FBSyxTQUFTLE9BQU87QUFBSyxtQkFBSyxvQkFBb0IsS0FBSztBQUN6RSxtQkFBTzs7VUFHVCxXQUFXLFdBQVc7O0FBRXhCLFlBQU0sT0FBTyxTQUFTLE9BQU8sQ0FBQyxTQUFTLFNBQVMsUUFBUSxRQUFRLFFBQVEsUUFBUSxRQUFRO0FBSXhGLFlBQU0sZ0JBQWdCLENBQUEsVUFBUyxPQUFPLFVBQVUsWUFBWSxPQUFPLFVBQVU7QUFFN0UsWUFBTSxnQkFBZ0IsQ0FBQztVQUNyQjtjQUNJLEtBQUssVUFBVTtBQUVyQixZQUFNLE9BQU8sQ0FBQyxLQUFLLEtBQUs7VUFDdEIsVUFBVSxDQUFBLFVBQVMsT0FBTyxVQUFVO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBQ0wsU0FBUyxXQUFXO1VBQ3BCLFdBQVc7V0FDVjtVQUNELFVBQVUsQ0FBQSxVQUFTLFNBQVM7VUFDNUIsWUFBWSxDQUFDLFFBQVEsT0FBTyxRQUFRLElBQUksY0FBYyxJQUFJLFdBQVcsT0FBTyxRQUFRO1VBQ3BGLFNBQVM7VUFDVCxLQUFLO1VBQ0wsTUFBTTtVQUNOLFNBQVMsTUFBTTtVQUNmLFdBQVc7V0FDVjtVQUNELFVBQVUsQ0FBQSxVQUFTLE9BQU8sVUFBVTtVQUNwQyxTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLENBQUEsUUFBTyxRQUFRO1VBQ3hCLFdBQVc7V0FDVjtVQUNELFVBQVU7VUFDVixTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLENBQUEsUUFBTyxXQUFXLFdBQVcsV0FBVyxPQUFPLE9BQU8sU0FBUyxLQUFLO1VBQzdFLFdBQVcsQ0FBQztZQUNWO2dCQUNJLGNBQWMsU0FBUyxNQUFNLGFBQWEsS0FBSyxVQUFVO1dBQzlEO1VBQ0QsVUFBVSxDQUFBLFVBQVMsT0FBTyxVQUFVO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBQ0wsTUFBTTtVQUNOLFNBQVMsQ0FBQSxRQUFPLFdBQVc7VUFDM0IsV0FBVzs7QUFHYixhQUFLLGlCQUFpQixDQUFBLFFBQU87QUFDM0IsZ0JBQU0sSUFBSSxZQUFZLDJCQUEyQixLQUFLLFVBQVU7O0FBS2xFLFlBQU0sZ0JBQWdCLENBQUM7VUFDckI7Y0FDSSxRQUFRLFdBQVcsWUFBWSxVQUFVLFdBQVcsWUFBWTtBQUV0RSxZQUFNLGNBQWMsQ0FBQSxVQUFTLE9BQU8sVUFBVSxZQUFZLE9BQU8sVUFBVTtBQUUzRSw0QkFBb0IsTUFBTSxLQUFLLE9BQU87QUFDcEMsY0FBSSxNQUFNLElBQUksUUFBUSxNQUFNO0FBRTVCLGNBQUksV0FBVyxXQUFXLFVBQVU7QUFDbEMsb0JBQVE7bUJBQ0Q7QUFDSCxzQkFBTSxLQUFLO0FBQ1g7bUJBRUc7QUFDSCxzQkFBTSxLQUFLO0FBQ1g7bUJBRUc7QUFDSCxzQkFBTSxLQUFLO0FBQ1g7O0FBR0osa0JBQU0sS0FBSSxPQUFPO0FBQ2pCLG1CQUFPLFNBQVMsTUFBTSxPQUFPLE1BQU0sS0FBSTs7QUFHekMsZ0JBQU0sSUFBSSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sU0FBUyxNQUFNLEtBQUssSUFBSTs7QUFHakMsOEJBQXNCLE1BQU0sT0FBTyxRQUFRO0FBQ3pDLGdCQUFNO1lBQ0o7Y0FDRTtBQUVKLGNBQUksWUFBWSxRQUFRO0FBQ3RCLGtCQUFNLE1BQU0sTUFBTSxTQUFTO0FBQzNCLG1CQUFPLFFBQVEsSUFBSSxNQUFNLFNBQVMsSUFBSSxPQUFPLEtBQUssU0FBUzs7QUFHN0QsaUJBQU8sV0FBVyxnQkFBZ0I7O0FBR3BDLFlBQU0sU0FBUyxTQUFTLE9BQU8sQ0FBQztVQUM5QixVQUFVLENBQUEsVUFBUyxTQUFTO1VBQzVCLFlBQVksQ0FBQyxRQUFRLE9BQU8sUUFBUSxJQUFJLGNBQWMsSUFBSSxXQUFXLE9BQU8sUUFBUTtVQUNwRixTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLE1BQU07VUFDZixTQUFTLFdBQVc7VUFDcEIsV0FBVyxNQUFNLFdBQVcsWUFBWTtXQUN2QztVQUNELFVBQVUsQ0FBQSxVQUFTLE9BQU8sVUFBVTtVQUNwQyxTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLE1BQU07VUFDZixTQUFTLFdBQVc7VUFDcEIsV0FBVztXQUNWO1VBQ0QsVUFBVSxDQUFBLFVBQVMsT0FBTyxVQUFVO1VBQ3BDLFNBQVM7VUFDVCxLQUFLO1VBQ0wsTUFBTTtVQUNOLFNBQVMsTUFBTTtVQUNmLFNBQVMsV0FBVztVQUNwQixXQUFXO1dBQ1Y7VUFDRCxVQUFVO1VBQ1YsU0FBUztVQUNULEtBQUs7VUFDTCxRQUFRO1VBQ1IsTUFBTTtVQUNOLFNBQVMsQ0FBQyxLQUFLLE1BQU0sUUFBUSxXQUFXLE1BQU0sS0FBSztVQUNuRCxXQUFXLENBQUEsU0FBUSxhQUFhLE1BQU0sR0FBRztXQUN4QztVQUNELFVBQVU7VUFDVixTQUFTO1VBQ1QsS0FBSztVQUNMLFFBQVE7VUFDUixNQUFNO1VBQ04sU0FBUyxDQUFDLEtBQUssTUFBTSxRQUFRLFdBQVcsTUFBTSxLQUFLO1VBQ25ELFdBQVcsQ0FBQSxTQUFRLGFBQWEsTUFBTSxHQUFHO1dBQ3hDO1VBQ0QsVUFBVTtVQUNWLFNBQVM7VUFDVCxLQUFLO1VBQ0wsTUFBTTtVQUNOLFNBQVMsQ0FBQyxLQUFLLE1BQU0sUUFBUSxXQUFXLE1BQU0sS0FBSztVQUNuRCxXQUFXLFdBQVc7V0FDckI7VUFDRCxVQUFVO1VBQ1YsU0FBUztVQUNULEtBQUs7VUFDTCxRQUFRO1VBQ1IsTUFBTTtVQUNOLFNBQVMsQ0FBQyxLQUFLLE1BQU0sUUFBUSxXQUFXLE1BQU0sS0FBSztVQUNuRCxXQUFXLENBQUEsU0FBUSxhQUFhLE1BQU0sSUFBSTtXQUN6QztVQUNELFVBQVUsQ0FBQSxVQUFTLE9BQU8sVUFBVTtVQUNwQyxTQUFTO1VBQ1QsS0FBSztVQUNMLE1BQU07VUFDTixTQUFTLENBQUMsS0FBSyxRQUFRLE1BQU0sTUFBTSxJQUFJLE9BQU8sTUFBTSxPQUFPLG9CQUFvQixPQUFPO1VBQ3RGLFdBQVcsV0FBVztXQUNyQjtVQUNELFVBQVUsQ0FBQSxVQUFTLE9BQU8sVUFBVTtVQUNwQyxTQUFTO1VBQ1QsS0FBSztVQUNMLFFBQVE7VUFDUixNQUFNO1VBQ04sU0FBUyxDQUFBLFFBQU8sV0FBVyxJQUFJLFFBQVEsTUFBTTtVQUM3QyxXQUFXLENBQUM7WUFDVjtnQkFDSSxPQUFPLE9BQU87V0FDbkI7VUFDRCxVQUFVLENBQUEsVUFBUyxPQUFPLFVBQVU7VUFDcEMsU0FBUztVQUNULEtBQUs7VUFDTCxNQUFNO1VBRU4sUUFBUSxLQUFLLE1BQU07QUFDakIsa0JBQU0sT0FBTyxJQUFJLFdBQVcsT0FBTyxXQUFXLElBQUksUUFBUSxNQUFNO0FBRWhFLGdCQUFJLE1BQU07QUFDUixvQkFBTSxJQUFJLEtBQUssUUFBUSxNQUFNO0FBQzdCLGtCQUFJLEVBQUUsRUFBRSxTQUFTLE9BQU87QUFBSyxxQkFBSyxvQkFBb0IsRUFBRTs7QUFHMUQsbUJBQU87O1VBR1QsV0FBVyxXQUFXO1lBQ3BCLFNBQVMsUUFBUSxTQUFTLE1BQU0sU0FBUyxPQUFPLFNBQVMsS0FBSyxTQUFTLFNBQVMsU0FBUyxXQUFXLFNBQVM7QUFFakgsWUFBTSxVQUFVO1VBQ2Q7VUFDQTtVQUNBO1VBQ0E7O0FBRUYsWUFBTSxPQUFPO1VBQ1gsUUFBUSxTQUFTO1VBQ2pCLE1BQU07VUFDTixPQUFPO1VBQ1AsVUFBVTtVQUNWLFVBQVU7VUFDVixXQUFXLFNBQVM7VUFDcEIsS0FBSztVQUNMLFFBQVE7VUFDUixRQUFRO1VBQ1IsU0FBUyxTQUFTO1VBQ2xCO1VBQ0EsTUFBTTtVQUNOLE1BQU0sU0FBUztVQUNmLE9BQU8sU0FBUztVQUNoQjtVQUNBLEtBQUssU0FBUztVQUNkLFdBQVcsU0FBUzs7QUFHdEIsK0JBQXVCLE9BQU8sU0FBUyxPQUFNO0FBQzNDLGNBQUksU0FBUztBQUNYLGtCQUFNLFFBQVEsTUFBSyxPQUFPLENBQUEsTUFBSyxFQUFFLFFBQVE7QUFDekMsa0JBQU0sU0FBUyxNQUFNLEtBQUssQ0FBQSxNQUFLLENBQUMsRUFBRSxXQUFXLE1BQU07QUFDbkQsZ0JBQUksQ0FBQztBQUFRLG9CQUFNLElBQUksTUFBTSxPQUFPO0FBQ3BDLG1CQUFPOztBQUlULGlCQUFPLE1BQUssS0FBSyxDQUFBLE1BQU0sR0FBRSxZQUFZLEVBQUUsU0FBUyxVQUFVLEVBQUUsU0FBUyxpQkFBaUIsRUFBRSxVQUFVLENBQUMsRUFBRTs7QUFHdkcsNEJBQW9CLE9BQU8sU0FBUyxLQUFLO0FBQ3ZDLGNBQUksaUJBQWlCLFdBQVc7QUFBTSxtQkFBTztBQUM3QyxnQkFBTTtZQUNKO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7Y0FDRTtBQUNKLGNBQUksV0FBVyxRQUFRLFdBQVc7QUFBTyxzQkFBVSxnQkFBZ0IsUUFBUSxNQUFNO0FBQ2pGLGNBQUksU0FBUyxjQUFjLE9BQU8sU0FBUyxPQUFPO0FBRWxELGNBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQUksT0FBTyxNQUFNLFdBQVc7QUFBWSxzQkFBUSxNQUFNO0FBQ3RELGdCQUFJLENBQUMsU0FBUyxPQUFPLFVBQVU7QUFBVSxxQkFBTyxjQUFjLElBQUksV0FBVyxPQUFPLFNBQVM7QUFDN0YscUJBQVMsaUJBQWlCLE1BQU0sTUFBTSxNQUFNLE9BQU8sWUFBWSxNQUFNOztBQUd2RSxjQUFJLFVBQVU7QUFDWixxQkFBUztBQUNULG1CQUFPLElBQUk7O0FBS2IsZ0JBQU0sTUFBTTtZQUNWLE9BQU87WUFDUCxNQUFNOztBQUdSLGNBQUksU0FBUyxPQUFPLFVBQVUsWUFBWSxhQUFhO0FBQ3JELGtCQUFNLE9BQU8sWUFBWSxJQUFJO0FBRTdCLGdCQUFJLE1BQU07QUFDUixvQkFBTSxRQUFRLElBQUksV0FBVyxNQUFNO0FBRW5DLGtCQUFJLFdBQVcsS0FBSztBQUVwQixxQkFBTzs7QUFHVCxnQkFBSSxRQUFRO0FBQ1osd0JBQVksSUFBSSxPQUFPOztBQUd6QixjQUFJLE9BQU8sT0FBTyxhQUFhLE9BQU8sV0FBVyxJQUFJLFFBQVEsT0FBTyxPQUFPLGNBQWMsSUFBSSxXQUFXLE9BQU8sU0FBUztBQUN4SCxjQUFJLFdBQVcsSUFBSSxnQkFBZ0IsV0FBVztBQUFNLGdCQUFJLEtBQUssTUFBTTtBQUNuRSxpQkFBTyxJQUFJOztBQUdiLCtCQUF1QixVQUFTLFdBQVcsWUFBWSxVQUFVO0FBQy9ELGNBQUksUUFBTyxTQUFRLFNBQVMsUUFBUSxPQUFPO0FBRTNDLGNBQUksQ0FBQyxPQUFNO0FBQ1Qsa0JBQU0sT0FBTyxPQUFPLEtBQUssVUFBUyxJQUFJLENBQUEsUUFBTyxLQUFLLFVBQVUsTUFBTSxLQUFLO0FBQ3ZFLGtCQUFNLElBQUksTUFBTSxtQkFBbUIseUJBQXlCOztBQUc5RCxjQUFJLE1BQU0sUUFBUSxhQUFhO0FBQzdCLHVCQUFXLE9BQU87QUFBWSxzQkFBTyxNQUFLLE9BQU87cUJBQ3hDLE9BQU8sZUFBZSxZQUFZO0FBQzNDLG9CQUFPLFdBQVcsTUFBSzs7QUFHekIsbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBSyxRQUFRLEVBQUUsR0FBRztBQUNwQyxrQkFBTSxNQUFNLE1BQUs7QUFFakIsZ0JBQUksT0FBTyxRQUFRLFVBQVU7QUFDM0Isb0JBQU0sU0FBUyxVQUFVO0FBRXpCLGtCQUFJLENBQUMsUUFBUTtBQUNYLHNCQUFNLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFBSSxDQUFBLFFBQU8sS0FBSyxVQUFVLE1BQU0sS0FBSztBQUN6RSxzQkFBTSxJQUFJLE1BQU0sdUJBQXVCLG9CQUFvQjs7QUFHN0Qsb0JBQUssS0FBSzs7O0FBSWQsaUJBQU87O0FBR1QsWUFBTSxzQkFBc0IsQ0FBQyxHQUFHLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sSUFBSTtBQUUvRSxZQUFBLFNBQUEsTUFBYTtVQUdYLFlBQVk7WUFDVjtZQUNBO1lBQ0E7WUFDQTtZQUNBLE1BQU07YUFDTDtBQUNELGlCQUFLLFFBQVEsQ0FBQyxDQUFDO0FBQ2YsaUJBQUssT0FBTztBQUNaLGlCQUFLLGlCQUFpQixtQkFBbUIsT0FBTyxzQkFBc0Isa0JBQWtCO0FBQ3hGLGdCQUFJLENBQUMsY0FBYztBQUFzQix1QkFBUyxzQkFBc0IsUUFBUTtBQUNoRixpQkFBSyxPQUFPLGNBQWMsU0FBUyxNQUFNLGNBQWMsc0JBQXNCOztVQUcvRSxXQUFXLE9BQU8sYUFBYSxTQUFTLEtBQUs7QUFDM0Msa0JBQU0sVUFBVTtjQUNkLGVBQWUsT0FBTztjQUN0QixRQUFRO2NBQ1I7O0FBRUYsa0JBQU0sWUFBWSxNQUFNLE9BQU8sT0FBTyxLQUFLLFdBQVc7QUFDdEQsbUJBQU8sV0FBVyxPQUFPLFNBQVM7O1VBR3BDLFdBQVcsS0FBSyxPQUFPLEtBQUs7QUFDMUIsZ0JBQUksQ0FBQztBQUFLLG9CQUFNO2dCQUNkLGFBQWE7O0FBRWYsa0JBQU0sSUFBSSxLQUFLLFdBQVcsS0FBSyxJQUFJLGFBQWEsTUFBTTtBQUN0RCxrQkFBTSxJQUFJLEtBQUssV0FBVyxPQUFPLElBQUksYUFBYSxNQUFNO0FBQ3hELG1CQUFPLElBQUksV0FBVyxLQUFLLEdBQUc7OztBQUtsQyxtQkFBVyxnQkFBZ0IsUUFBUSxpQkFBaUIsV0FBVztBQUUvRCxtQkFBVyxnQkFBZ0IsUUFBUSxlQUFlLFdBQVc7QUFFN0QsaUJBQVEsU0FBUzs7O0FDNWdCakIsUUFBQSxpQkFBQSxZQUFBO01BQUEsa0NBQUEsVUFBQTtBQUFBO0FBRUEsWUFBSSxhQUFhO0FBQ2pCLFlBQUksU0FBUztBQUNiO0FBQ0E7QUFJQSxpQkFBUSxRQUFRLFdBQVc7QUFDM0IsaUJBQVEsYUFBYSxXQUFXO0FBQ2hDLGlCQUFRLFFBQVEsV0FBVztBQUMzQixpQkFBUSxPQUFPLFdBQVc7QUFDMUIsaUJBQVEsT0FBTyxXQUFXO0FBQzFCLGlCQUFRLFNBQVMsV0FBVztBQUM1QixpQkFBUSxVQUFVLFdBQVc7QUFDN0IsaUJBQVEsVUFBVSxXQUFXO0FBQzdCLGlCQUFRLGdCQUFnQixXQUFXO0FBQ25DLGlCQUFRLGNBQWMsV0FBVztBQUNqQyxpQkFBUSxhQUFhLFdBQVc7QUFDaEMsaUJBQVEsY0FBYyxXQUFXO0FBQ2pDLGlCQUFRLGFBQWEsV0FBVztBQUNoQyxpQkFBUSxTQUFTLE9BQU87OztBQ3RCeEIsUUFBQSxpQkFBQSxZQUFBO01BQUEsNkJBQUEsVUFBQTtBQUFBLFlBQU0sUUFBUTtBQUVkLGlCQUFRLGdCQUFnQixNQUFNO0FBQzlCLGlCQUFRLGNBQWMsTUFBTTtBQUM1QixpQkFBUSxhQUFhLE1BQU07QUFDM0IsaUJBQVEsY0FBYyxNQUFNO0FBQzVCLGlCQUFRLGFBQWEsTUFBTTtBQUUzQixpQkFBUSxTQUFTLE1BQU07QUFDdkIsaUJBQVEsUUFBUSxNQUFNO0FBQ3RCLGlCQUFRLGFBQWEsTUFBTTtBQUMzQixpQkFBUSxRQUFRLE1BQU07QUFDdEIsaUJBQVEsT0FBTyxNQUFNO0FBQ3JCLGlCQUFRLE9BQU8sTUFBTTtBQUNyQixpQkFBUSxTQUFTLE1BQU07QUFDdkIsaUJBQVEsVUFBVSxNQUFNO0FBQ3hCLGlCQUFRLFVBQVUsTUFBTTs7O0FDaEJ4QixRQUFBLGVBQUEsWUFBQTs7WUFBQSxPQUFBO0FBQ0EsWUFBQSxFQUFBLFNBQUEsWUFBQTtBQUNBLFlBQUEsWUFBQTtBQUVBLHVCQUFlLEtBQUssTUFBTTtBQUN4QixpQkFBTyxLQUFLLE9BQU8sQ0FBQyxHQUFHLE1BQU8sS0FBSyxJQUFJLEVBQUUsS0FBSyxJQUFLOztBQUdyRCw2QkFBcUIsU0FBUyxNQUFNLGFBQWEsV0FBVyxhQUFhO0FBQ3ZFLGdCQUFNLEVBQUUsT0FBTyxhQUFhLFlBQVksTUFBTSxTQUFTO0FBQ3ZELGdCQUFNLFFBQVE7QUFFZCxjQUFJLFVBQVUsa0JBQWtCLE9BQU87QUFDckMsa0JBQU0sS0FBSyxJQUFJLFNBQVM7O0FBRTFCLGNBQUksVUFBVSx3QkFBd0IsYUFBYTtBQUNqRCxrQkFBTSxLQUFLLElBQUk7O0FBRWpCLGNBQUksVUFBVSxvQkFBb0IsU0FBUztBQUN6QyxrQkFBTSxLQUFLLElBQUk7O0FBR2pCLHNCQUFZLGdCQUFnQixNQUFNLEtBQUs7QUFFdkMsY0FBSSxvQkFBb0IsU0FBUztBQUMvQixxQkFBUyxNQUFNLFFBQVEsQ0FBQSxNQUFLO0FBQzFCLDBCQUFZLFNBQVMsQ0FBQyxHQUFHLE1BQU0sU0FBUyxFQUFFLElBQUksUUFBUSxFQUFFLEtBQUssRUFBRTs7cUJBRXhELG9CQUFvQixTQUFTO0FBQ3RDLHFCQUFTLE1BQU0sUUFBUSxDQUFDLEdBQUcsTUFBTTtBQUMvQiwwQkFBWSxTQUFTLENBQUMsR0FBRyxNQUFNLFNBQVMsSUFBSTs7OztBQVdsRCw0QkFBb0IsRUFBRSxPQUFPLFdBQVc7QUFDdEMsZ0JBQU0sUUFBUSxLQUFLLFdBQVc7QUFFOUIsc0JBQVksU0FBUyxJQUFJO0FBRXpCLGdCQUFNLE1BQU0sSUFBSSxLQUFLO0FBQ3JCLGNBQUksV0FBVztBQUVmLGlCQUFPLElBQUk7O0FBR2IsWUFBTyxlQUFROzs7O0FDcERmLFFBQUEsb0JBQUEsWUFBQTs7WUFBQSxXQUFBO0FBQ0EsWUFBQSxhQUFBOzs7O0FDREEsUUFBQSxlQUFBLFlBQUE7O1lBQUEsRUFBQSxvQkFBQTtBQUNBLFlBQUEsWUFBQTtBQUNBLFlBQUEsU0FBQTtBQUNBLFlBQUEsU0FBQTtBQUNBLFlBQUEsTUFBQTtBQUNBLFlBQUEsU0FBQTtBQUNBLFlBQUEsUUFBQTtBQUNBLFlBQUEsTUFBQTtBQUNBLFlBQUEsRUFBQSxVQUFBLGVBQUE7QUFFQSxZQUFNLFlBQVksSUFBSTtBQUV0QixpQ0FBeUI7QUFFdkIsb0JBQVUsT0FBTyxpQkFBaUIsdUJBQXVCLE9BQU8sUUFBUTtBQUN0RSxnQkFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixvQkFBTSxNQUFNLE9BQU8sV0FBVztBQUM5QixvQkFBTSxNQUFNLE1BQU0sSUFBSTtBQUN0QixvQkFBTSxTQUFTLE1BQU0saUJBQWlCLE9BQU87QUFFN0MsbUJBQUssU0FBUyxVQUFVLE9BQU8sT0FBTyxLQUFLOztBQUc3QyxnQkFBSSxVQUFVLE1BQU07QUFDbEIscUJBQU8sS0FBSzs7QUFHZCxtQkFBTzs7QUFJVCxvQkFBVSxPQUFPLGtCQUFrQix3QkFBd0IsT0FBTyxRQUFRO0FBQ3hFLGdCQUFJLENBQUMsS0FBSyxLQUFLO0FBQ2IsbUJBQUssTUFBTSxPQUFPOztBQUdwQixnQkFBSSxPQUFPO0FBQ1QsdUJBQVMsS0FBSyxJQUFJO0FBQ2xCLHNCQUFRLFVBQVUsT0FDZCxTQUNBO0FBRUosa0JBQUksQ0FBQyxXQUFXLFdBQVcsU0FBUyxRQUFRLFNBQVMsVUFBVSxTQUFTLFFBQVEsV0FBVyxJQUFJO0FBQzdGLHNCQUFNLElBQUksTUFBTSw0QkFBNEIsTUFBTSxNQUFNOztBQUcxRCxtQkFBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFlBQVksT0FBTyxLQUFLOztBQUdwRCxtQkFBTzs7O0FBSVgseUJBQWlCLE1BQU0sUUFBUTtBQUM3QixjQUFJLFFBQVE7QUFFWixjQUFJLE1BQU0sUUFBUSxPQUFPO0FBQ3ZCLGlCQUFLLFFBQVEsQ0FBQSxZQUFXO0FBQ3RCLG9CQUFNLFFBQVEsT0FBTyxRQUFRLE1BQU07O2lCQUVoQztBQUNMLG9CQUFRLFFBQVE7O0FBR2xCLHdCQUFjLEtBQUs7QUFDakIsZ0JBQUksQ0FBQyxPQUFPLE9BQU8sUUFBUTtBQUFVO0FBQ3JDLGdCQUFJLE1BQU0sUUFBUTtBQUFNLHFCQUFPLElBQUksUUFBUTtBQUUzQyxrQkFBTSxNQUFNLElBQUksT0FBTyxJQUFJO0FBRTNCLGdCQUFJLE9BQU8sUUFBUSxZQUFZLENBQUMsTUFBTSxNQUFNO0FBQzFDLG9CQUFNLE9BQU87O0FBR2YsbUJBQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQSxRQUFPO0FBQzlCLG1CQUFLLElBQUk7OztBQUliLGVBQUs7QUFDTCxlQUFLO0FBRUwsaUJBQU87O0FBR1QsWUFBTSxNQUFNLENBQUMsUUFBUSxNQUFNLFFBQVE7QUFDakMsa0JBQVEsSUFBSTtBQUVaLGNBQUksS0FBSztBQUNQLG9CQUFRLElBQUk7O0FBR2QsaUJBQU8sSUFBSSxTQUFTLFFBQVE7O0FBRzlCLFlBQUksc0JBQXNCLENBQUMsUUFBUSxTQUFTO0FBQzFDLGdCQUFNLFFBQVEsUUFBUSxNQUFNO0FBRTVCLGlCQUFPLElBQUksT0FBTyxRQUFRLFdBQVc7O0FBR3ZDLFlBQUksV0FBVyxDQUFDLFFBQVEsU0FBUyxTQUM3QixJQUFJLG9CQUFvQixRQUFRO0FBR3BDLFlBQUksZUFBZSxDQUFDLFFBQVEsU0FBUyxXQUNqQyxJQUFJLG9CQUFvQixRQUFRO0FBR3BDLFlBQUkscUJBQXFCLENBQUMsUUFBUSxNQUFNLFFBQVE7QUFDOUMsY0FBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixrQkFBTTtBQUNOLG1CQUFPOztBQUlULGdCQUFNLE9BQVEsUUFBTyxZQUFZLGNBQWMsUUFBUSxRQUFRO0FBQy9ELGdCQUFNLEdBQUcsSUFBSSxRQUFRLFFBQVE7QUFFN0IsZ0JBQU0sUUFBUSxRQUFRLE1BQU07QUFHNUIsZ0JBQU0sWUFBWTtZQUNoQixPQUFPO1lBQ1AsUUFBUSxNQUFNO0FBQ1osb0JBQU0sTUFBTSxLQUFLLElBQUksUUFBUSxNQUFNO0FBRW5DLHFCQUFPLE1BQU0sUUFBUSxNQUFNLElBQUksTUFBTSxLQUFLOztZQUU1QyxLQUFLLE1BQU0sVUFBVTtBQUNuQixrQkFBSTtBQUNGLHlCQUFTLE1BQU0sS0FBSyxRQUFRO3VCQUNyQjtBQUNQLHlCQUFTOzs7O0FBS2YsZ0JBQU0sRUFBRSxZQUFBLGdCQUFlO0FBRXZCLGlCQUFPLFlBQ0osT0FBTyxLQUFLLFFBQVE7WUFDbkIsU0FBUztjQUNQLE1BQU0sRUFBRSxPQUFPO2NBQ2YsTUFBTSxFQUFFLE9BQU87Y0FDZjs7WUFFRixhQUFhO2NBQ1gsVUFBVTs7YUFFWCxLQUFLLENBQUEsUUFBTyxJQUFJLE9BQU8sS0FBSyxZQUM5QixNQUFNLENBQUEsTUFBSztBQUNWLGtCQUFNLElBQUksTUFBTSxpQ0FBaUMsRUFBRTs7O0FBSXpELFlBQUksVUFBVSxDQUFDLFFBQVEsTUFBTSxRQUFRLElBQUksbUJBQW1CLFFBQVEsTUFBTSxLQUFLLEtBQUs7QUFFcEYsWUFBSSxjQUFjLENBQUMsUUFBUSxNQUFNLFFBQVEsSUFBSSxtQkFBbUIsUUFBUSxNQUFNLEtBQUssS0FBSztBQUV4RjtBQUVBLFlBQUksU0FBUztBQUNiLFlBQUksU0FBUztBQUNiLFlBQUksU0FBUztBQUdiLFlBQUksU0FBUyxDQUFDLE1BQU0sT0FBTztBQUN6QixvQkFBVSxPQUFPLE1BQU07QUFDdkIsaUJBQU87O0FBR1QsWUFBSSxTQUFTLENBQUMsTUFBTSxPQUFPO0FBQ3pCLG9CQUFVLE9BQU8sTUFBTTtBQUN2QixpQkFBTzs7QUFHVCxZQUFJLFFBQVEsQ0FBQSxTQUFRO0FBQ2xCLG9CQUFVLE1BQU07QUFDaEI7QUFDQSxpQkFBTzs7QUFHVCxZQUFJLFNBQVMsQ0FBQSxTQUFRO0FBQ25CLGlCQUFPLFVBQVUsSUFBSTs7QUFJdkIsWUFBSSxPQUFPLFlBQVksYUFBYTtBQUNsQyxjQUFJLFVBQVU7O0FBR2hCLFlBQU8sY0FBUTs7OztBQ2hNZixhQUFBLFNBQUE7TUFBQSxTQUFBLE1BQUEsV0FBQTs7QUFBQSxRQUFBLGdDQUF1QixZQUFBLFVBQUE7QUFDdkIsUUFBQSx1QkFBeUIsWUFBQSxVQUFBO0FBRXpCLFFBQUEsZ0JBQWdDLFlBQUE7QUFJaEMsUUFBQSxhQUF3QixZQUFBO0FBRnhCLElBQUEsSUFBQSxjQUFBLGlCQUFnQixFQUFFLFlBQUEsOEJBQUEsU0FBWSxVQUFBLHFCQUFBOzs7OztBQ0w5QixzQkFBd0I7IiwibmFtZXMiOltdfQ==
